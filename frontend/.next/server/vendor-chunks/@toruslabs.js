"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/BaseController.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/lib.esm/BaseController.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseController: () => (/* binding */ BaseController)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web3auth/auth */ \"(ssr)/./node_modules/@web3auth/auth/dist/lib.esm/jrpc/safeEventEmitter.js\");\n\n\n\n\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */\nclass BaseController extends _web3auth_auth__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n  /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */\n  constructor({\n    config = {},\n    state = {}\n  }) {\n    super();\n    // Use assign since generics can't be spread: https://git.io/vpRhY\n    /**\n     * Default options used to configure this controller\n     */\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultConfig\", {});\n    /**\n     * Default state set on this controller\n     */\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultState\", {});\n    /**\n     * Determines if listeners are notified of state changes\n     */\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"disabled\", false);\n    /**\n     * Name of this controller used during composition\n     */\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseController\");\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialConfig\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialState\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalConfig\", this.defaultConfig);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalState\", this.defaultState);\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n\n  /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */\n  get config() {\n    return this.internalConfig;\n  }\n\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n  get state() {\n    return this.internalState;\n  }\n\n  /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */\n  configure(config, overwrite = false, fullUpdate = true) {\n    if (fullUpdate) {\n      this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n      for (const key in this.internalConfig) {\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          this[key] = this.internalConfig[key];\n        }\n      }\n    } else {\n      for (const key in config) {\n        /* istanbul ignore else */\n        if (typeof this.internalConfig[key] !== \"undefined\") {\n          this.internalConfig[key] = config[key];\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */\n  update(state, overwrite = false) {\n    this.internalState = overwrite ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, state) : _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.internalState), state);\n    this.emit(\"store\", this.internalState);\n  }\n\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */\n  initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvbGliLmVzbS9CYXNlQ29udHJvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDRztBQUNsQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDREQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJFQUFhLEdBQUcsV0FBVywyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMvZGlzdC9saWIuZXNtL0Jhc2VDb250cm9sbGVyLmpzP2RiZmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBTYWZlRXZlbnRFbWl0dGVyIH0gZnJvbSAnQHdlYjNhdXRoL2F1dGgnO1xuXG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBjb25maWd1cmF0aW9uLCBzdGF0ZSBtYW5hZ2VtZW50LCBhbmQgc3Vic2NyaXB0aW9uc1xuICovXG5jbGFzcyBCYXNlQ29udHJvbGxlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJhc2VDb250cm9sbGVyIGluc3RhbmNlLiBCb3RoIGluaXRpYWwgc3RhdGUgYW5kIGluaXRpYWxcbiAgICogY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBkZWZhdWx0cyB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZSA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIFVzZSBhc3NpZ24gc2luY2UgZ2VuZXJpY3MgY2FuJ3QgYmUgc3ByZWFkOiBodHRwczovL2dpdC5pby92cFJoWVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0Q29uZmlnXCIsIHt9KTtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0YXRlIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0U3RhdGVcIiwge30pO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgbGlzdGVuZXJzIGFyZSBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJhc2VDb250cm9sbGVyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxDb25maWdcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsU3RhdGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbENvbmZpZ1wiLCB0aGlzLmRlZmF1bHRDb25maWcpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVybmFsU3RhdGVcIiwgdGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5pbml0aWFsQ29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIC0gQ3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsQ29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMgLSBDdXJyZW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gTmV3IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIGNvbmZpZyBpbnN0ZWFkIG9mIG1lcmdpbmdcbiAgICogQHBhcmFtIGZ1bGxVcGRhdGUgLSBCb29sZWFuIHRoYXQgZGVmaW5lcyBpZiB0aGUgdXBkYXRlIGlzIHBhcnRpYWwgb3Igbm90XG4gICAqL1xuICBjb25maWd1cmUoY29uZmlnLCBvdmVyd3JpdGUgPSBmYWxzZSwgZnVsbFVwZGF0ZSA9IHRydWUpIHtcbiAgICBpZiAoZnVsbFVwZGF0ZSkge1xuICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IG92ZXJ3cml0ZSA/IGNvbmZpZyA6IE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcm5hbENvbmZpZywgY29uZmlnKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuaW50ZXJuYWxDb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGVcbiAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBzdGF0ZSBpbnN0ZWFkIG9mIG1lcmdpbmdcbiAgICovXG4gIHVwZGF0ZShzdGF0ZSwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSBvdmVyd3JpdGUgPyBfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSkgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuaW50ZXJuYWxTdGF0ZSksIHN0YXRlKTtcbiAgICB0aGlzLmVtaXQoXCJzdG9yZVwiLCB0aGlzLmludGVybmFsU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGNvbnRyb2xsZXIuIFRoaXMgc2V0cyBlYWNoIGNvbmZpZyBvcHRpb24gYXMgYSBtZW1iZXJcbiAgICogdmFyaWFibGUgb24gdGhpcyBpbnN0YW5jZSBhbmQgdHJpZ2dlcnMgYW55IGRlZmluZWQgc2V0dGVycy4gVGhpc1xuICAgKiBhbHNvIHNldHMgaW5pdGlhbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgYW55IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJldHVybnMgLSBUaGlzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IHRoaXMuZGVmYXVsdENvbmZpZztcbiAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLmluaXRpYWxDb25maWcpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuaW5pdGlhbFN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlQ29udHJvbGxlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/BaseController.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/createFetchMiddleware.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/createFetchMiddleware.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFetchConfigFromReq: () => (/* binding */ createFetchConfigFromReq),\n/* harmony export */   createFetchMiddleware: () => (/* binding */ createFetchMiddleware)\n/* harmony export */ });\n/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @web3auth/auth */ \"(ssr)/./node_modules/@web3auth/auth/dist/lib.esm/jrpc/errors/errors.js\");\n/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @web3auth/auth */ \"(ssr)/./node_modules/@web3auth/auth/dist/lib.esm/jrpc/jrpc.js\");\n\n\nconst RETRIABLE_ERRORS = [\n// ignore server overload errors\n\"Gateway timeout\", \"ETIMEDOUT\",\n// ignore server sent html error pages\n// or truncated json responses\n\"failed to parse response body\",\n// ignore errors where http req failed to establish\n\"Failed to fetch\"];\nfunction checkForHttpErrors(fetchRes) {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.methodNotFound();\n    case 418:\n      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.internal({\n        message: `Request is being rate limited.`,\n        data: {\n          cause: fetchRes\n        }\n      });\n    case 503:\n    case 504:\n      throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.internal({\n        message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`,\n        data: {\n          cause: fetchRes\n        }\n      });\n  }\n}\nfunction timeout(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction parseResponse(fetchRes, body) {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.internal({\n      message: `Non-200 status code: '${fetchRes.status}'`,\n      data: body\n    });\n  }\n  // check for rpc error\n  if (body.error) {\n    var _body$error;\n    throw _web3auth_auth__WEBPACK_IMPORTED_MODULE_0__.rpcErrors.internal({\n      data: body.error,\n      message: (_body$error = body.error) === null || _body$error === void 0 ? void 0 : _body$error.message\n    });\n  }\n  // return successful result\n  return body.result;\n}\nfunction createFetchConfigFromReq({\n  req,\n  rpcTarget,\n  originHttpHeaderKey\n}) {\n  const parsedUrl = new URL(rpcTarget);\n\n  // prepare payload\n  // copy only canonical json rpc properties\n  const payload = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params\n  };\n\n  // extract 'origin' parameter from request\n  const originDomain = req.origin;\n\n  // serialize request body\n  const serializedPayload = JSON.stringify(payload);\n\n  // configure fetch params\n  const fetchParams = {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\"\n    },\n    body: serializedPayload\n  };\n\n  // optional: add request origin as header\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n  return {\n    fetchUrl: parsedUrl.href,\n    fetchParams\n  };\n}\nfunction createFetchMiddleware({\n  rpcTarget,\n  originHttpHeaderKey\n}) {\n  return (0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_1__.createAsyncMiddleware)(async (req, res, _next) => {\n    const {\n      fetchUrl,\n      fetchParams\n    } = createFetchConfigFromReq({\n      req,\n      rpcTarget,\n      originHttpHeaderKey\n    });\n\n    // attempt request multiple times\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await fetch(fetchUrl, fetchParams);\n        // check for http errrors\n        checkForHttpErrors(fetchRes);\n        // parse response body\n        const fetchBody = await fetchRes.json();\n        const result = parseResponse(fetchRes, fetchBody);\n        // set result and exit retry loop\n        res.result = result;\n        return;\n      } catch (err) {\n        const errMsg = (err.message || err).toString();\n        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));\n        // re-throw error if not retriable\n        if (!isRetriable) {\n          throw err;\n        }\n      }\n      // delay before retrying\n      await timeout(retryInterval);\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvbGliLmVzbS9OZXR3b3JrL2NyZWF0ZUZldGNoTWlkZGxld2FyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFTO0FBQ3JCO0FBQ0EsWUFBWSxxREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsWUFBWSxxREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBUztBQUNuQix3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxREFBUztBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVMscUVBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRTJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMvZGlzdC9saWIuZXNtL05ldHdvcmsvY3JlYXRlRmV0Y2hNaWRkbGV3YXJlLmpzPzYxYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBycGNFcnJvcnMgfSBmcm9tICdAd2ViM2F1dGgvYXV0aCc7XG5cbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4vLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuXCJHYXRld2F5IHRpbWVvdXRcIiwgXCJFVElNRURPVVRcIixcbi8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4vLyBvciB0cnVuY2F0ZWQganNvbiByZXNwb25zZXNcblwiZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHlcIixcbi8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuXCJGYWlsZWQgdG8gZmV0Y2hcIl07XG5mdW5jdGlvbiBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICBzd2l0Y2ggKGZldGNoUmVzLnN0YXR1cykge1xuICAgIGNhc2UgNDA1OlxuICAgICAgdGhyb3cgcnBjRXJyb3JzLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgY2FzZSA0MTg6XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoe1xuICAgICAgICBtZXNzYWdlOiBgUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuYCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNhdXNlOiBmZXRjaFJlc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBjYXNlIDUwMzpcbiAgICBjYXNlIDUwNDpcbiAgICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICAgIG1lc3NhZ2U6IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy5gICsgYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY2F1c2U6IGZldGNoUmVzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICBtZXNzYWdlOiBgTm9uLTIwMCBzdGF0dXMgY29kZTogJyR7ZmV0Y2hSZXMuc3RhdHVzfSdgLFxuICAgICAgZGF0YTogYm9keVxuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBycGMgZXJyb3JcbiAgaWYgKGJvZHkuZXJyb3IpIHtcbiAgICB2YXIgX2JvZHkkZXJyb3I7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKHtcbiAgICAgIGRhdGE6IGJvZHkuZXJyb3IsXG4gICAgICBtZXNzYWdlOiAoX2JvZHkkZXJyb3IgPSBib2R5LmVycm9yKSA9PT0gbnVsbCB8fCBfYm9keSRlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JvZHkkZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICByZXR1cm4gYm9keS5yZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICByZXEsXG4gIHJwY1RhcmdldCxcbiAgb3JpZ2luSHR0cEhlYWRlcktleVxufSkge1xuICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1RhcmdldCk7XG5cbiAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gIC8vIGNvcHkgb25seSBjYW5vbmljYWwganNvbiBycGMgcHJvcGVydGllc1xuICBjb25zdCBwYXlsb2FkID0ge1xuICAgIGlkOiByZXEuaWQsXG4gICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgIHBhcmFtczogcmVxLnBhcmFtc1xuICB9O1xuXG4gIC8vIGV4dHJhY3QgJ29yaWdpbicgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICBjb25zdCBvcmlnaW5Eb21haW4gPSByZXEub3JpZ2luO1xuXG4gIC8vIHNlcmlhbGl6ZSByZXF1ZXN0IGJvZHlcbiAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcblxuICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSxcbiAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZFxuICB9O1xuXG4gIC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXG4gIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgIGZldGNoUGFyYW1zLmhlYWRlcnNbb3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmZXRjaFVybDogcGFyc2VkVXJsLmhyZWYsXG4gICAgZmV0Y2hQYXJhbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoTWlkZGxld2FyZSh7XG4gIHJwY1RhcmdldCxcbiAgb3JpZ2luSHR0cEhlYWRlcktleVxufSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgX25leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBmZXRjaFVybCxcbiAgICAgIGZldGNoUGFyYW1zXG4gICAgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XG4gICAgICByZXEsXG4gICAgICBycGNUYXJnZXQsXG4gICAgICBvcmlnaW5IdHRwSGVhZGVyS2V5XG4gICAgfSk7XG5cbiAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDU7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDEwMDA7XG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmZXRjaFJlcyA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaFBhcmFtcyk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgLy8gcGFyc2UgcmVzcG9uc2UgYm9keVxuICAgICAgICBjb25zdCBmZXRjaEJvZHkgPSBhd2FpdCBmZXRjaFJlcy5qc29uKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gKGVyci5tZXNzYWdlIHx8IGVycikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUocGhyYXNlID0+IGVyck1zZy5pbmNsdWRlcyhwaHJhc2UpKTtcbiAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxLCBjcmVhdGVGZXRjaE1pZGRsZXdhcmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/createFetchMiddleware.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/createEventEmitterProxy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/lib.esm/createEventEmitterProxy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEventEmitterProxy: () => (/* binding */ createEventEmitterProxy)\n/* harmony export */ });\nconst filterNoop = () => true;\nconst internalEvents = [\"newListener\", \"removeListener\"];\nconst externalEventFilter = name => !internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n  // prefer native\n  return typeof eventEmitter.rawListeners !== \"undefined\" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n  // parse options\n  const finalOpts = opts || {};\n  let eventFilter = finalOpts.eventFilter || filterNoop;\n  if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n  if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n  let target = initialTarget;\n  let setTarget = newTarget => {\n    if (target === newTarget) return;\n    const oldTarget = target;\n    target = newTarget;\n    const eventNames = oldTarget.eventNames();\n    eventNames.filter(eventFilter).forEach(name => {\n      getRawListeners(oldTarget, name).forEach(handler => {\n        newTarget.on(name, handler);\n      });\n    });\n\n    // remove old listeners\n    oldTarget.removeAllListeners();\n  };\n  const proxy = new Proxy({}, {\n    get: (_, name) => {\n      // override `setTarget` access\n      if (name === \"setTarget\") return setTarget;\n      return target[name];\n    },\n    set: (_, name, value) => {\n      // allow `setTarget` overrides\n      if (name === \"setTarget\") {\n        setTarget = value;\n        return true;\n      }\n      target[name] = value;\n      return true;\n    },\n    has: (_, key) => {\n      if (key[0] === \"_\") {\n        return false;\n      }\n      return key in target;\n    }\n  });\n  return proxy;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvbGliLmVzbS9jcmVhdGVFdmVudEVtaXR0ZXJQcm94eS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycy9kaXN0L2xpYi5lc20vY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkuanM/MWU4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IGludGVybmFsRXZlbnRzID0gW1wibmV3TGlzdGVuZXJcIiwgXCJyZW1vdmVMaXN0ZW5lclwiXTtcbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSBuYW1lID0+ICFpbnRlcm5hbEV2ZW50cy5pbmNsdWRlcyhuYW1lKTtcbmZ1bmN0aW9uIGdldFJhd0xpc3RlbmVycyhldmVudEVtaXR0ZXIsIG5hbWUpIHtcbiAgLy8gcHJlZmVyIG5hdGl2ZVxuICByZXR1cm4gdHlwZW9mIGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMgIT09IFwidW5kZWZpbmVkXCIgPyBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpIDogZXZlbnRFbWl0dGVyLmxpc3RlbmVycyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5KGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBjb25zdCBmaW5hbE9wdHMgPSBvcHRzIHx8IHt9O1xuICBsZXQgZXZlbnRGaWx0ZXIgPSBmaW5hbE9wdHMuZXZlbnRGaWx0ZXIgfHwgZmlsdGVyTm9vcDtcbiAgaWYgKHR5cGVvZiBldmVudEZpbHRlciA9PT0gXCJzdHJpbmdcIiAmJiBldmVudEZpbHRlciA9PT0gXCJza2lwSW50ZXJuYWxcIikgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyO1xuICBpZiAodHlwZW9mIGV2ZW50RmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImNyZWF0ZUV2ZW50RW1pdHRlclByb3h5IC0gSW52YWxpZCBldmVudEZpbHRlclwiKTtcbiAgbGV0IHRhcmdldCA9IGluaXRpYWxUYXJnZXQ7XG4gIGxldCBzZXRUYXJnZXQgPSBuZXdUYXJnZXQgPT4ge1xuICAgIGlmICh0YXJnZXQgPT09IG5ld1RhcmdldCkgcmV0dXJuO1xuICAgIGNvbnN0IG9sZFRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSBuZXdUYXJnZXQ7XG4gICAgY29uc3QgZXZlbnROYW1lcyA9IG9sZFRhcmdldC5ldmVudE5hbWVzKCk7XG4gICAgZXZlbnROYW1lcy5maWx0ZXIoZXZlbnRGaWx0ZXIpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBnZXRSYXdMaXN0ZW5lcnMob2xkVGFyZ2V0LCBuYW1lKS5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICBuZXdUYXJnZXQub24obmFtZSwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBvbGQgbGlzdGVuZXJzXG4gICAgb2xkVGFyZ2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9O1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgIGdldDogKF8sIG5hbWUpID0+IHtcbiAgICAgIC8vIG92ZXJyaWRlIGBzZXRUYXJnZXRgIGFjY2Vzc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHJldHVybiBzZXRUYXJnZXQ7XG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICAgIH0sXG4gICAgc2V0OiAoXywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIC8vIGFsbG93IGBzZXRUYXJnZXRgIG92ZXJyaWRlc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHtcbiAgICAgICAgc2V0VGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhczogKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGtleVswXSA9PT0gXCJfXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG5leHBvcnQgeyBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/createEventEmitterProxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/lodashUtils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/lodashUtils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   omitBy: () => (/* binding */ omitBy),\n/* harmony export */   pickBy: () => (/* binding */ pickBy)\n/* harmony export */ });\nfunction omitBy(object, predicate) {\n  // Create a new object to store the results\n  const result = {};\n\n  // Iterate over all own properties of the object\n  for (const [key, value] of Object.entries(object)) {\n    if (!predicate(value, key)) {\n      result[key] = value;\n    }\n  }\n  return result;\n}\nfunction pickBy(object, predicate) {\n  // Create a new object to store the results\n  const result = {};\n  for (const [key, value] of Object.entries(object)) {\n    if (predicate(value, key)) {\n      result[key] = value;\n    }\n  }\n  return result;\n}\nfunction cloneDeep(object) {\n  try {\n    return structuredClone(object);\n  } catch (error) {\n    return JSON.parse(JSON.stringify(object, (_, v) => typeof v === \"bigint\" ? v.toString() : v));\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvbGliLmVzbS91dGlscy9sb2Rhc2hVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycy9kaXN0L2xpYi5lc20vdXRpbHMvbG9kYXNoVXRpbHMuanM/YjQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0byBzdG9yZSB0aGUgcmVzdWx0c1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3RcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgIGlmICghcHJlZGljYXRlKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdG8gc3RvcmUgdGhlIHJlc3VsdHNcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xvbmVEZWVwKG9iamVjdCkge1xuICB0cnkge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QsIChfLCB2KSA9PiB0eXBlb2YgdiA9PT0gXCJiaWdpbnRcIiA/IHYudG9TdHJpbmcoKSA6IHYpKTtcbiAgfVxufVxuXG5leHBvcnQgeyBjbG9uZURlZXAsIG9taXRCeSwgcGlja0J5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/lodashUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UserError: () => (/* binding */ UserError),\n/* harmony export */   addressSlicer: () => (/* binding */ addressSlicer),\n/* harmony export */   broadcastChannelOptions: () => (/* binding */ broadcastChannelOptions),\n/* harmony export */   concatSig: () => (/* binding */ concatSig),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatSmallNumbers: () => (/* binding */ formatSmallNumbers),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   getCustomDeviceInfo: () => (/* binding */ getCustomDeviceInfo),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   handleRedirectParameters: () => (/* binding */ handleRedirectParameters),\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   intToHex: () => (/* binding */ intToHex),\n/* harmony export */   isUnauthorizedError: () => (/* binding */ isUnauthorizedError),\n/* harmony export */   padWithZeroes: () => (/* binding */ padWithZeroes),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   significantDigits: () => (/* binding */ significantDigits),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeout: () => (/* binding */ timeout),\n/* harmony export */   transactionMatchesNetwork: () => (/* binding */ transactionMatchesNetwork)\n/* harmony export */ });\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/esm/index.js\");\n/* harmony import */ var _web3auth_auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @web3auth/auth */ \"(ssr)/./node_modules/@web3auth/auth/dist/lib.esm/utils/utils.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n\n\n\n\n/**\n * General utility functions\n */\n\nfunction intToHex(i) {\n  const hex = i.toString(16);\n  return `0x${hex}`;\n}\n\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */\nconst randomId = () => Math.random().toString(36).slice(2);\n\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\nfunction padWithZeroes(hexString, targetLength) {\n  if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n    throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n  }\n  if (targetLength < 0) {\n    throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n  }\n  return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */\nfunction concatSig(v, r, s) {\n  const rSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.fromSigned)(r);\n  const sSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.fromSigned)(s);\n  const vSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.bytesToBigInt)(v);\n  const rStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.toUnsigned)(rSig)).toString(\"hex\"), 64);\n  const sStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.toUnsigned)(sSig)).toString(\"hex\"), 64);\n  const vStr = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.stripHexPrefix)((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.bigIntToHex)(vSig));\n  return (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.addHexPrefix)(rStr.concat(sStr, vStr));\n}\nfunction timeout(duration) {\n  return new Promise(resolve => {\n    const timeoutRef = window.setTimeout(() => {\n      resolve();\n      window.clearTimeout(timeoutRef);\n    }, duration);\n  });\n}\nconst getHeaders = (jwt, publicAddress) => {\n  return {\n    headers: {\n      Authorization: `Bearer ${jwt}`,\n      \"Content-Type\": \"application/json; charset=utf-8\",\n      \"public-address\": publicAddress\n    }\n  };\n};\n\n/**\n * Text/number formatting utilities\n */\nconst formatSmallNumbers = (number, currency = \"usd\", noTilde = false) => {\n  const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBigNumber(number) ? number.toNumber() : number;\n  if (!Number.isFinite(finalNumber)) return \"\";\n  const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n  const tilde = value > 0 ? \"~ \" : \"\";\n  return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\nconst addressSlicer = (address, sliceLength = 5) => {\n  if (!address) return \"\";\n  if (address.length < 11) {\n    return address;\n  }\n  if (typeof address !== \"string\") return \"\";\n  return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\nconst significantDigits = (number, perc = false, length_ = 2) => {\n  let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](number) : number;\n  if (input.isZero()) return input;\n  if (perc) {\n    input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](100));\n  }\n  let depth;\n  if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1))) {\n    depth = length_;\n  } else {\n    depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"1\").div(input).toNumber()));\n  }\n  const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](depth));\n  const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n  return roundedNumber;\n};\nconst formatDate = inputDate => {\n  const monthList = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n  const date = new Date(inputDate);\n  const day = date.getDate();\n  const month = monthList[date.getMonth()];\n  const year = date.getFullYear();\n  return `${day} ${month} ${year}`;\n};\nconst formatTime = time => {\n  return new Date(time).toTimeString().slice(0, 8);\n};\n\n/**\n * Network utilities\n */\nconst transactionMatchesNetwork = (transaction, chainId) => {\n  if (typeof transaction.chainId !== \"undefined\") {\n    return transaction.chainId === chainId;\n  }\n  return false;\n};\n\n/**\n * Signing utils\n */\nconst hashMessage = message => {\n  const bufferedMessage = Buffer.from(message, \"utf8\");\n  const el = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.hashPersonalMessage)(bufferedMessage);\n  return Buffer.from(el);\n};\nconst signMessage = async (privateKey, data) => {\n  const privKey = Buffer.from(privateKey, \"hex\");\n  const message = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.stripHexPrefix)(data);\n  const msgSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.ecsign)(Buffer.from(message, \"hex\"), privKey);\n  const rawMsgSig = concatSig(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_0__.bigIntToBytes)(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));\n  return rawMsgSig;\n};\n\n/**\n * popup handler utils\n */\nfunction getPopupFeatures({\n  width: w,\n  height: h\n}) {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n  return features;\n}\nconst broadcastChannelOptions = {\n  type: \"server\",\n  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n  var _navigator;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n    return {\n      browser: \"Brave\"\n    };\n  }\n}\nclass UserError extends Error {}\nconst handleRedirectParameters = (hash, queryParameters) => {\n  const hashParameters = {};\n  const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n  hashUrl.searchParams.forEach((value, key) => {\n    hashParameters[key] = value;\n  });\n  let instanceParameters = {};\n  let error = \"\";\n  if (!queryParameters.windowId) {\n    if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n      instanceParameters = JSON.parse((0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_2__.safeatob)(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n      error = hashParameters.error_description || hashParameters.error || error;\n    } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n      instanceParameters = JSON.parse((0,_web3auth_auth__WEBPACK_IMPORTED_MODULE_2__.safeatob)(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n      if (queryParameters.error) error = queryParameters.error;\n    }\n  }\n  return {\n    error,\n    instanceParameters,\n    hashParameters\n  };\n};\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\nconst isUnauthorizedError = error => {\n  return error instanceof Response && error.status === 401;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvbGliLmVzbS91dGlscy91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0s7QUFDdEg7QUFDTDs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBVTtBQUN6QixlQUFlLDREQUFVO0FBQ3pCLGVBQWUsK0RBQWE7QUFDNUIseUNBQXlDLDREQUFVO0FBQ25ELHlDQUF5Qyw0REFBVTtBQUNuRCxlQUFlLGdFQUFjLENBQUMsNkRBQVc7QUFDekMsU0FBUyw4REFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQXlELEVBQUUsZUFBZSxFQUFFLHVCQUF1QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCLEtBQUssNEJBQTRCO0FBQzNFO0FBQ0E7QUFDQSxlQUFlLG9EQUFTLDJCQUEyQixvREFBUztBQUM1RDtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFTO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQVM7QUFDN0I7QUFDQSxJQUFJO0FBQ0osbURBQW1ELG9EQUFTO0FBQzVEO0FBQ0Esb0JBQW9CLG9EQUFTLGFBQWEsb0RBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFFQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRUFBYztBQUNoQyxpQkFBaUIsd0RBQU07QUFDdkIsMENBQTBDLCtEQUFhO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxnRkFBZ0YsZUFBZSxTQUFTLGVBQWUsT0FBTyxJQUFJLFFBQVEsS0FBSztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUIsSUFBSSxjQUFjO0FBQ3RFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQVE7QUFDOUM7QUFDQSxNQUFNO0FBQ04sc0NBQXNDLHdEQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFaVYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1jb250cm9sbGVycy9kaXN0L2xpYi5lc20vdXRpbHMvdXRpbHMuanM/ZWJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmcm9tU2lnbmVkLCBieXRlc1RvQmlnSW50LCB0b1Vuc2lnbmVkLCBzdHJpcEhleFByZWZpeCwgYmlnSW50VG9IZXgsIGFkZEhleFByZWZpeCwgaGFzaFBlcnNvbmFsTWVzc2FnZSwgZWNzaWduLCBiaWdJbnRUb0J5dGVzIH0gZnJvbSAnQGV0aGVyZXVtanMvdXRpbCc7XG5pbXBvcnQgeyBzYWZlYXRvYiB9IGZyb20gJ0B3ZWIzYXV0aC9hdXRoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICBjb25zdCBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuIERvbid0IHVzZSBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3Nlcy5cbiAqIEByZXR1cm5zIGEgcmFuZG9tIG51bWJlclxuICovXG5jb25zdCByYW5kb21JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgaWYgKGhleFN0cmluZyAhPT0gXCJcIiAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gdW5wcmVmaXhlZCBoZXggc3RyaW5nLiBSZWNlaXZlZDogJHtoZXhTdHJpbmd9YCk7XG4gIH1cbiAgaWYgKHRhcmdldExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICB9XG4gIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0LmNhbGwoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgsIFwiMFwiKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGUgYW4gZXh0ZW5kZWQgRUNEU0Egc2lnbmF0dXJlIGludG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2IC0gVGhlICd2JyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gciAtIFRoZSAncicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHMgLSBUaGUgJ3MnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgRUNEU0Egc2lnbmF0dXJlLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICBjb25zdCByU2lnID0gZnJvbVNpZ25lZChyKTtcbiAgY29uc3Qgc1NpZyA9IGZyb21TaWduZWQocyk7XG4gIGNvbnN0IHZTaWcgPSBieXRlc1RvQmlnSW50KHYpO1xuICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhCdWZmZXIuZnJvbSh0b1Vuc2lnbmVkKHJTaWcpKS50b1N0cmluZyhcImhleFwiKSwgNjQpO1xuICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhCdWZmZXIuZnJvbSh0b1Vuc2lnbmVkKHNTaWcpKS50b1N0cmluZyhcImhleFwiKSwgNjQpO1xuICBjb25zdCB2U3RyID0gc3RyaXBIZXhQcmVmaXgoYmlnSW50VG9IZXgodlNpZykpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRSZWYgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgIH0sIGR1cmF0aW9uKTtcbiAgfSk7XG59XG5jb25zdCBnZXRIZWFkZXJzID0gKGp3dCwgcHVibGljQWRkcmVzcykgPT4ge1xuICByZXR1cm4ge1xuICAgIGhlYWRlcnM6IHtcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtqd3R9YCxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgXCJwdWJsaWMtYWRkcmVzc1wiOiBwdWJsaWNBZGRyZXNzXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBUZXh0L251bWJlciBmb3JtYXR0aW5nIHV0aWxpdGllc1xuICovXG5jb25zdCBmb3JtYXRTbWFsbE51bWJlcnMgPSAobnVtYmVyLCBjdXJyZW5jeSA9IFwidXNkXCIsIG5vVGlsZGUgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBmaW5hbE51bWJlciA9IEJpZ051bWJlci5pc0JpZ051bWJlcihudW1iZXIpID8gbnVtYmVyLnRvTnVtYmVyKCkgOiBudW1iZXI7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZpbmFsTnVtYmVyKSkgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHZhbHVlID0gY3VycmVuY3kudG9Mb3dlckNhc2UoKSA9PT0gXCJ1c2RcIiA/IHBhcnNlRmxvYXQoTnVtYmVyKGZpbmFsTnVtYmVyKS50b0ZpeGVkKDIpKSA6IHBhcnNlRmxvYXQoTnVtYmVyKGZpbmFsTnVtYmVyKS50b0ZpeGVkKDUpKTtcbiAgY29uc3QgdGlsZGUgPSB2YWx1ZSA+IDAgPyBcIn4gXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7Y3VycmVuY3kudG9Mb3dlckNhc2UoKSA9PT0gXCJ1c2RcIiB8fCBub1RpbGRlID8gXCJcIiA6IHRpbGRlfSR7TnVtYmVyKHZhbHVlKX0gJHtjdXJyZW5jeS50b1VwcGVyQ2FzZSgpfWA7XG59O1xuY29uc3QgYWRkcmVzc1NsaWNlciA9IChhZGRyZXNzLCBzbGljZUxlbmd0aCA9IDUpID0+IHtcbiAgaWYgKCFhZGRyZXNzKSByZXR1cm4gXCJcIjtcbiAgaWYgKGFkZHJlc3MubGVuZ3RoIDwgMTEpIHtcbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuICBpZiAodHlwZW9mIGFkZHJlc3MgIT09IFwic3RyaW5nXCIpIHJldHVybiBcIlwiO1xuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBzbGljZUxlbmd0aCl9Li4uJHthZGRyZXNzLnNsaWNlKC1zbGljZUxlbmd0aCl9YDtcbn07XG5jb25zdCBzaWduaWZpY2FudERpZ2l0cyA9IChudW1iZXIsIHBlcmMgPSBmYWxzZSwgbGVuZ3RoXyA9IDIpID0+IHtcbiAgbGV0IGlucHV0ID0gIUJpZ051bWJlci5pc0JpZ051bWJlcihudW1iZXIpID8gbmV3IEJpZ051bWJlcihudW1iZXIpIDogbnVtYmVyO1xuICBpZiAoaW5wdXQuaXNaZXJvKCkpIHJldHVybiBpbnB1dDtcbiAgaWYgKHBlcmMpIHtcbiAgICBpbnB1dCA9IGlucHV0LnRpbWVzKG5ldyBCaWdOdW1iZXIoMTAwKSk7XG4gIH1cbiAgbGV0IGRlcHRoO1xuICBpZiAoaW5wdXQuZ3RlKG5ldyBCaWdOdW1iZXIoMSkpKSB7XG4gICAgZGVwdGggPSBsZW5ndGhfO1xuICB9IGVsc2Uge1xuICAgIGRlcHRoID0gbGVuZ3RoXyAtIDEgKyBNYXRoLmNlaWwoTWF0aC5sb2cxMChuZXcgQmlnTnVtYmVyKFwiMVwiKS5kaXYoaW5wdXQpLnRvTnVtYmVyKCkpKTtcbiAgfVxuICBjb25zdCBzaGlmdCA9IG5ldyBCaWdOdW1iZXIoMTApLnBvdyhuZXcgQmlnTnVtYmVyKGRlcHRoKSk7XG4gIGNvbnN0IHJvdW5kZWROdW1iZXIgPSBNYXRoLnJvdW5kKHNoaWZ0LnRpbWVzKGlucHV0KS50b051bWJlcigpKSAvIHNoaWZ0LnRvTnVtYmVyKCk7XG4gIHJldHVybiByb3VuZGVkTnVtYmVyO1xufTtcbmNvbnN0IGZvcm1hdERhdGUgPSBpbnB1dERhdGUgPT4ge1xuICBjb25zdCBtb250aExpc3QgPSBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl07XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpbnB1dERhdGUpO1xuICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgY29uc3QgbW9udGggPSBtb250aExpc3RbZGF0ZS5nZXRNb250aCgpXTtcbiAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgcmV0dXJuIGAke2RheX0gJHttb250aH0gJHt5ZWFyfWA7XG59O1xuY29uc3QgZm9ybWF0VGltZSA9IHRpbWUgPT4ge1xuICByZXR1cm4gbmV3IERhdGUodGltZSkudG9UaW1lU3RyaW5nKCkuc2xpY2UoMCwgOCk7XG59O1xuXG4vKipcbiAqIE5ldHdvcmsgdXRpbGl0aWVzXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgPSAodHJhbnNhY3Rpb24sIGNoYWluSWQpID0+IHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmNoYWluSWQgPT09IGNoYWluSWQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaWduaW5nIHV0aWxzXG4gKi9cbmNvbnN0IGhhc2hNZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcmVkTWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwidXRmOFwiKTtcbiAgY29uc3QgZWwgPSBoYXNoUGVyc29uYWxNZXNzYWdlKGJ1ZmZlcmVkTWVzc2FnZSk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlbCk7XG59O1xuY29uc3Qgc2lnbk1lc3NhZ2UgPSBhc3luYyAocHJpdmF0ZUtleSwgZGF0YSkgPT4ge1xuICBjb25zdCBwcml2S2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgXCJoZXhcIik7XG4gIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgY29uc3QgbXNnU2lnID0gZWNzaWduKEJ1ZmZlci5mcm9tKG1lc3NhZ2UsIFwiaGV4XCIpLCBwcml2S2V5KTtcbiAgY29uc3QgcmF3TXNnU2lnID0gY29uY2F0U2lnKEJ1ZmZlci5mcm9tKGJpZ0ludFRvQnl0ZXMobXNnU2lnLnYpKSwgQnVmZmVyLmZyb20obXNnU2lnLnIpLCBCdWZmZXIuZnJvbShtc2dTaWcucykpO1xuICByZXR1cm4gcmF3TXNnU2lnO1xufTtcblxuLyoqXG4gKiBwb3B1cCBoYW5kbGVyIHV0aWxzXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoe1xuICB3aWR0aDogdyxcbiAgaGVpZ2h0OiBoXG59KSB7XG4gIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3N0IGJyb3dzZXJzICAgICAgRmlyZWZveFxuICBjb25zdCBkdWFsU2NyZWVuTGVmdCA9IHdpbmRvdy5zY3JlZW5MZWZ0ICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuTGVmdCA6IHdpbmRvdy5zY3JlZW5YO1xuICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlblRvcCA6IHdpbmRvdy5zY3JlZW5ZO1xuICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW5kb3cuc2NyZWVuLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBzeXN0ZW1ab29tID0gMTsgLy8gTm8gcmVsaWFibGUgZXN0aW1hdGVcblxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBgdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PSR7aCAvIHN5c3RlbVpvb219LHdpZHRoPSR7dyAvIHN5c3RlbVpvb219LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YDtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuY29uc3QgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMgPSB7XG4gIHR5cGU6IFwic2VydmVyXCIsXG4gIC8vIHR5cGU6ICdsb2NhbHN0b3JhZ2UnLCAvLyAob3B0aW9uYWwpIGVuZm9yY2UgYSB0eXBlLCBvbmVPZlsnbmF0aXZlJywgJ2lkYicsICdsb2NhbHN0b3JhZ2UnLCAnbm9kZSddXG4gIHdlYldvcmtlclN1cHBvcnQ6IGZhbHNlIC8vIChvcHRpb25hbCkgc2V0IHRoaXMgdG8gZmFsc2UgaWYgeW91IGtub3cgdGhhdCB5b3VyIGNoYW5uZWwgd2lsbCBuZXZlciBiZSB1c2VkIGluIGEgV2ViV29ya2VyIChpbmNyZWFzZXMgcGVyZm9ybWFuY2UpXG59O1xuZnVuY3Rpb24gZ2V0Q3VzdG9tRGV2aWNlSW5mbygpIHtcbiAgdmFyIF9uYXZpZ2F0b3I7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGlmICgoX25hdmlnYXRvciA9IG5hdmlnYXRvcikgIT09IG51bGwgJiYgX25hdmlnYXRvciAhPT0gdm9pZCAwICYmIF9uYXZpZ2F0b3IuYnJhdmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlcjogXCJCcmF2ZVwiXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVXNlckVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNvbnN0IGhhbmRsZVJlZGlyZWN0UGFyYW1ldGVycyA9IChoYXNoLCBxdWVyeVBhcmFtZXRlcnMpID0+IHtcbiAgY29uc3QgaGFzaFBhcmFtZXRlcnMgPSB7fTtcbiAgY29uc3QgaGFzaFVybCA9IG5ldyBVUkwoYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vPyR7aGFzaC5zbGljZSgxKX1gKTtcbiAgaGFzaFVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGhhc2hQYXJhbWV0ZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGxldCBpbnN0YW5jZVBhcmFtZXRlcnMgPSB7fTtcbiAgbGV0IGVycm9yID0gXCJcIjtcbiAgaWYgKCFxdWVyeVBhcmFtZXRlcnMud2luZG93SWQpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoaGFzaFBhcmFtZXRlcnMpLmxlbmd0aCA+IDAgJiYgaGFzaFBhcmFtZXRlcnMuc3RhdGUpIHtcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVycyA9IEpTT04ucGFyc2Uoc2FmZWF0b2IoZGVjb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudChoYXNoUGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XG4gICAgICBlcnJvciA9IGhhc2hQYXJhbWV0ZXJzLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGhhc2hQYXJhbWV0ZXJzLmVycm9yIHx8IGVycm9yO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMocXVlcnlQYXJhbWV0ZXJzKS5sZW5ndGggPiAwICYmIHF1ZXJ5UGFyYW1ldGVycy5zdGF0ZSkge1xuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzID0gSlNPTi5wYXJzZShzYWZlYXRvYihkZWNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHF1ZXJ5UGFyYW1ldGVycy5zdGF0ZSkpKSkgfHwge307XG4gICAgICBpZiAocXVlcnlQYXJhbWV0ZXJzLmVycm9yKSBlcnJvciA9IHF1ZXJ5UGFyYW1ldGVycy5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlcnJvcixcbiAgICBpbnN0YW5jZVBhcmFtZXRlcnMsXG4gICAgaGFzaFBhcmFtZXRlcnNcbiAgfTtcbn07XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtcyk7XG4gIH0pO1xufVxuY29uc3QgaXNVbmF1dGhvcml6ZWRFcnJvciA9IGVycm9yID0+IHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDE7XG59O1xuXG5leHBvcnQgeyBVc2VyRXJyb3IsIGFkZHJlc3NTbGljZXIsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zLCBjb25jYXRTaWcsIGZvcm1hdERhdGUsIGZvcm1hdFNtYWxsTnVtYmVycywgZm9ybWF0VGltZSwgZ2V0Q3VzdG9tRGV2aWNlSW5mbywgZ2V0SGVhZGVycywgZ2V0UG9wdXBGZWF0dXJlcywgaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzLCBoYXNoTWVzc2FnZSwgaW50VG9IZXgsIGlzVW5hdXRob3JpemVkRXJyb3IsIHBhZFdpdGhaZXJvZXMsIHJhbmRvbUlkLCBzaWduTWVzc2FnZSwgc2lnbmlmaWNhbnREaWdpdHMsIHNsZWVwLCB0aW1lb3V0LCB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-session-manager/dist/baseSessionManager.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-session-manager/dist/baseSessionManager.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSessionManager: () => (/* binding */ BaseSessionManager)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/base-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n\n\n\nclass BaseSessionManager {\n  constructor() {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionId\", void 0);\n  }\n  checkSessionParams() {\n    if (!this.sessionId) throw new Error(\"Session id is required\");\n    this.sessionId = this.sessionId.padStart(64, \"0\");\n  }\n\n  /**\n   * Common handler method for making an http request.\n   *\n   * Note: Embed all the query parameters in the path itself.\n   */\n  request(_ref) {\n    let {\n      method = \"GET\",\n      url,\n      data = {},\n      headers = {}\n    } = _ref;\n    const options = {\n      headers\n    };\n    switch (method) {\n      case \"GET\":\n        return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.get)(url, options);\n      case \"POST\":\n        return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.post)(url, data, options);\n      case \"PUT\":\n        return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.put)(url, data, options);\n      case \"PATCH\":\n        return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_1__.patch)(url, data, options);\n    }\n    throw new Error(\"Invalid method type\");\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLXNlc3Npb24tbWFuYWdlci9kaXN0L2Jhc2VTZXNzaW9uTWFuYWdlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRTtBQUNKOztBQUVoRTtBQUNBO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBRztBQUNsQjtBQUNBLGVBQWUsNkRBQUk7QUFDbkI7QUFDQSxlQUFlLDREQUFHO0FBQ2xCO0FBQ0EsZUFBZSw4REFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYmFzZS1zZXNzaW9uLW1hbmFnZXIvZGlzdC9iYXNlU2Vzc2lvbk1hbmFnZXIuZXNtLmpzP2JkMjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IHBhdGNoLCBwdXQsIHBvc3QsIGdldCB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcblxuY2xhc3MgQmFzZVNlc3Npb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2Vzc2lvbklkXCIsIHZvaWQgMCk7XG4gIH1cbiAgY2hlY2tTZXNzaW9uUGFyYW1zKCkge1xuICAgIGlmICghdGhpcy5zZXNzaW9uSWQpIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gaWQgaXMgcmVxdWlyZWRcIik7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLnNlc3Npb25JZC5wYWRTdGFydCg2NCwgXCIwXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1vbiBoYW5kbGVyIG1ldGhvZCBmb3IgbWFraW5nIGFuIGh0dHAgcmVxdWVzdC5cbiAgICpcbiAgICogTm90ZTogRW1iZWQgYWxsIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIGluIHRoZSBwYXRoIGl0c2VsZi5cbiAgICovXG4gIHJlcXVlc3QoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBtZXRob2QgPSBcIkdFVFwiLFxuICAgICAgdXJsLFxuICAgICAgZGF0YSA9IHt9LFxuICAgICAgaGVhZGVycyA9IHt9XG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGhlYWRlcnNcbiAgICB9O1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgIHJldHVybiBnZXQodXJsLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgXCJQT1NUXCI6XG4gICAgICAgIHJldHVybiBwb3N0KHVybCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICBjYXNlIFwiUFVUXCI6XG4gICAgICAgIHJldHVybiBwdXQodXJsLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIGNhc2UgXCJQQVRDSFwiOlxuICAgICAgICByZXR1cm4gcGF0Y2godXJsLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXRob2QgdHlwZVwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlU2Vzc2lvbk1hbmFnZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-session-manager/dist/baseSessionManager.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/base-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n}\n\n// #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n  return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\nfunction debugLogResponse(response) {\n  log.info(`Response: ${response.status} ${response.statusText}`);\n  log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n  const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n  if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise) => {\n  let timeoutFunc = null;\n  try {\n    const timeout = new Promise((_resolve, reject) => {\n      timeoutFunc = setTimeout(() => {\n        reject(new Error(`Timed out in ${ms}ms`));\n      }, ms);\n    });\n    const result = await Promise.race([promise, timeout]);\n    // promise.race will return the first resolved promise\n    // then we clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    return result;\n  } catch (err) {\n    // clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    // rethrow the original error\n    throw err;\n  }\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"POST\"\n  });\n\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (customOptions.logTracingHeader) {\n      logTracingHeader(response);\n    }\n    if (response.ok) {\n      const responseContentType = response.headers.get(\"content-type\");\n      if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n        return response.json();\n      }\n      return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PATCH\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PUT\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLXNlc3Npb24tbWFuYWdlci9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ2hDO0FBQ1c7O0FBRTVDLFlBQVkseURBQWtCO0FBQzlCLGFBQWEsNENBQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0EsbUJBQW1COztBQUVuQiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQy9ELG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRXlQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2Jhc2Utc2Vzc2lvbi1tYW5hZ2VyL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2h0dHAtaGVscGVycy9kaXN0L2h0dHBIZWxwZXJzLmVzbS5qcz9jY2RhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCBsb2dMZXZlbCwgeyBsZXZlbHMgfSBmcm9tICdsb2dsZXZlbCc7XG5cbmNvbnN0IGxvZyA9IGxvZ0xldmVsLmdldExvZ2dlcihcImh0dHAtaGVscGVyc1wiKTtcbmxvZy5zZXRMZXZlbChsZXZlbHMuSU5GTyk7XG5sZXQgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG5sZXQgZW1iZWRIb3N0ID0gXCJcIjtcblxuLy8gI3JlZ2lvbiBBUEkgS2V5c1xuY29uc3QgZ2F0ZXdheUF1dGhIZWFkZXIgPSBcIngtYXBpLWtleVwiO1xuY29uc3QgZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciA9IFwieC1lbWJlZC1ob3N0XCI7XG5sZXQgc2VudHJ5ID0gbnVsbDtcbmNvbnN0IHRyYWNpbmdPcmlnaW5zID0gW107XG5jb25zdCB0cmFjaW5nUGF0aHMgPSBbXTtcbmZ1bmN0aW9uIGVuYWJsZVNlbnRyeVRyYWNpbmcoX3NlbnRyeSwgX3RyYWNpbmdPcmlnaW5zLCBfdHJhY2luZ1BhdGhzKSB7XG4gIHNlbnRyeSA9IF9zZW50cnk7XG4gIHRyYWNpbmdPcmlnaW5zLnB1c2goLi4uX3RyYWNpbmdPcmlnaW5zKTtcbiAgdHJhY2luZ1BhdGhzLnB1c2goLi4uX3RyYWNpbmdQYXRocyk7XG59XG5mdW5jdGlvbiBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0Xykge1xuICBlbWJlZEhvc3QgPSBlbWJlZEhvc3RfO1xufVxuZnVuY3Rpb24gY2xlYXJFbWJlZEhvc3QoKSB7XG4gIGVtYmVkSG9zdCA9IFwiXCI7XG59XG5mdW5jdGlvbiBnZXRFbWJlZEhvc3QoKSB7XG4gIHJldHVybiBlbWJlZEhvc3Q7XG59XG5mdW5jdGlvbiBzZXRBUElLZXkoYXBpS2V5Xykge1xuICBhcGlLZXkgPSBhcGlLZXlfO1xufVxuZnVuY3Rpb24gY2xlYXJBUElLZXkoKSB7XG4gIGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xufVxuZnVuY3Rpb24gZ2V0QVBJS2V5KCkge1xuICByZXR1cm4gYXBpS2V5O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIGxvZy5zZXRMZXZlbChsZXZlbCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZFRyYWNlKHVybCwgaW5pdCkge1xuICBsZXQgX3VybCA9IG51bGw7XG4gIHRyeSB7XG4gICAgX3VybCA9IG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIGlmIChzZW50cnkgJiYgX3VybCAmJiAodHJhY2luZ09yaWdpbnMuaW5jbHVkZXMoX3VybC5vcmlnaW4pIHx8IHRyYWNpbmdQYXRocy5pbmNsdWRlcyhfdXJsLnBhdGhuYW1lKSkpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHNlbnRyeS5zdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgIG5hbWU6IHVybFxuICAgIH0pO1xuICAgIGNvbnN0IHNwYW4gPSB0cmFuc2FjdGlvbi5zdGFydENoaWxkKHtcbiAgICAgIG9wOiBcImh0dHBcIlxuICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBTcGFuXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gICAgc3Bhbi5maW5pc2goKTsgLy8gUmVtZW1iZXIgdGhhdCBvbmx5IGZpbmlzaGVkIHNwYW5zIHdpbGwgYmUgc2VudCB3aXRoIHRoZSB0cmFuc2FjdGlvblxuXG4gICAgdHJhbnNhY3Rpb24uZmluaXNoKCk7IC8vIEZpbmlzaGluZyB0aGUgdHJhbnNhY3Rpb24gd2lsbCBzZW5kIGl0IHRvIFNlbnRyeVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIHJldHVybiBmZXRjaCh1cmwsIGluaXQpO1xufVxuZnVuY3Rpb24gZ2V0QXBpS2V5SGVhZGVycygpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYXBpS2V5KSBoZWFkZXJzW2dhdGV3YXlBdXRoSGVhZGVyXSA9IGFwaUtleTtcbiAgaWYgKGVtYmVkSG9zdCkgaGVhZGVyc1tnYXRld2F5RW1iZWRIb3N0SGVhZGVyXSA9IGVtYmVkSG9zdDtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGxvZy5pbmZvKGBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgbG9nLmluZm8oYFVybDogJHtyZXNwb25zZS51cmx9YCk7XG59XG5mdW5jdGlvbiBsb2dUcmFjaW5nSGVhZGVyKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHRyYWNpbmdIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtd2ViMy1jb3JyZWxhdGlvbi1pZFwiKTtcbiAgaWYgKHRyYWNpbmdIZWFkZXIpIGxvZy5pbmZvKGBSZXF1ZXN0IHRyYWNpbmcgd2l0aCB0cmFjZUlEID0gJHt0cmFjaW5nSGVhZGVyfWApO1xufVxuY29uc3QgcHJvbWlzZVRpbWVvdXQgPSBhc3luYyAobXMsIHByb21pc2UpID0+IHtcbiAgbGV0IHRpbWVvdXRGdW5jID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXRGdW5jID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVkIG91dCBpbiAke21zfW1zYCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dF0pO1xuICAgIC8vIHByb21pc2UucmFjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZVxuICAgIC8vIHRoZW4gd2UgY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgLy8gcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5jb25zdCBnZXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge31cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJHRVRcIlxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHBvc3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgfSk7XG5cbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIHJldHVybiBwcm9taXNlVGltZW91dChjdXN0b21PcHRpb25zLnRpbWVvdXQgfHwgNjAwMDAsIGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAoY3VzdG9tT3B0aW9ucy5sb2dUcmFjaW5nSGVhZGVyKSB7XG4gICAgICBsb2dUcmFjaW5nSGVhZGVyKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfVxuICAgIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHRocm93IHJlc3BvbnNlO1xuICB9KSk7XG59O1xuY29uc3QgcGF0Y2ggPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQQVRDSFwiXG4gIH0pO1xuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHB1dCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBVVFwiXG4gIH0pO1xuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gIH0pO1xuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgZ2VuZXJhdGVKc29uUlBDT2JqZWN0ID0gKG1ldGhvZCwgcGFyYW1ldGVycykgPT4gKHtcbiAganNvbnJwYzogXCIyLjBcIixcbiAgbWV0aG9kLFxuICBpZDogMTAsXG4gIHBhcmFtczogcGFyYW1ldGVyc1xufSk7XG5jb25zdCBwcm9taXNlUmFjZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDYwMDAwO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtnZXQodXJsLCBvcHRpb25zKSwgbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lZCBvdXRcIikpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9KV0pO1xufTtcblxuZXhwb3J0IHsgY2xlYXJBUElLZXksIGNsZWFyRW1iZWRIb3N0LCBlbmFibGVTZW50cnlUcmFjaW5nLCBnYXRld2F5QXV0aEhlYWRlciwgZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciwgZ2VuZXJhdGVKc29uUlBDT2JqZWN0LCBnZXQsIGdldEFQSUtleSwgZ2V0RW1iZWRIb3N0LCBwYXRjaCwgcG9zdCwgcHJvbWlzZVJhY2UsIHByb21pc2VUaW1lb3V0LCBwdXQsIHJlbW92ZSwgc2V0QVBJS2V5LCBzZXRFbWJlZEhvc3QsIHNldExvZ0xldmVsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/constants/dist/lib.esm/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toruslabs/constants/dist/lib.esm/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AUTHJS_SERVER_URL: () => (/* binding */ AUTHJS_SERVER_URL),\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER_API_URL: () => (/* binding */ SESSION_SERVER_API_URL),\n/* harmony export */   SESSION_SERVER_SOCKET_URL: () => (/* binding */ SESSION_SERVER_SOCKET_URL),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   SIG_TYPE: () => (/* binding */ SIG_TYPE),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  AQUA: \"aqua\",\n  CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n  SAPPHIRE_DEVNET: \"sapphire_devnet\",\n  SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [\n  // TORUS_LEGACY_NETWORK.AQUA,\n  // TORUS_LEGACY_NETWORK.CELESTE,\n  // TORUS_LEGACY_NETWORK.CYAN,\n];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n  [TORUS_LEGACY_NETWORK.AQUA]: {\n    migrationCompleted: true,\n    networkIdentifier: \"aqua\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CELESTE]: {\n    migrationCompleted: true,\n    networkIdentifier: \"celeste\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CYAN]: {\n    migrationCompleted: true,\n    networkIdentifier: \"cyan\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.MAINNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"mainnet\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.TESTNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"teal\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n  }\n};\nconst NETWORK_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://api.web3auth.io/signer-service\",\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://api.web3auth.io/signer-service\",\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://api.web3auth.io/signer-service\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://api.web3auth.io/signer-service\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://api.web3auth.io/signer-polygon-service\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://api.web3auth.io/signer-polygon-service\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://api.web3auth.io/signer-polygon-service\"\n};\nconst METADATA_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://api.web3auth.io/metadata-service\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://api.web3auth.io/metadata-service\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://api.web3auth.io/metadata-service\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://api.web3auth.io/metadata-service\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://api.web3auth.io/metadata-service\"\n};\n\n// FND backend service\nconst FND_SERVER = \"https://api.web3auth.io/fnd-service\";\n\n// Session backend service\nconst SESSION_SERVER_API_URL = \"https://api.web3auth.io/session-service\";\nconst SESSION_SERVER_SOCKET_URL = \"https://session.web3auth.io\";\n\n// Authjs backend service\nconst AUTHJS_SERVER_URL = \"https://api.web3auth.io/authjs-service\";\nconst KEY_TYPE = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\nconst SIG_TYPE = {\n  ECDSA_SECP256K1: \"ecdsa-secp256k1\",\n  ED25519: \"ed25519\",\n  BIP340: \"bip340\"\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9jb25zdGFudHMvZGlzdC9saWIuZXNtL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvbGliLmVzbS9jb25zdGFudHMuanM/ZDEwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBUT1JVU19MRUdBQ1lfTkVUV09SSyA9IHtcbiAgTUFJTk5FVDogXCJtYWlubmV0XCIsXG4gIFRFU1RORVQ6IFwidGVzdG5ldFwiLFxuICBDWUFOOiBcImN5YW5cIixcbiAgQVFVQTogXCJhcXVhXCIsXG4gIENFTEVTVEU6IFwiY2VsZXN0ZVwiXG59O1xuY29uc3QgVE9SVVNfU0FQUEhJUkVfTkVUV09SSyA9IHtcbiAgU0FQUEhJUkVfREVWTkVUOiBcInNhcHBoaXJlX2Rldm5ldFwiLFxuICBTQVBQSElSRV9NQUlOTkVUOiBcInNhcHBoaXJlX21haW5uZXRcIlxufTtcbmNvbnN0IFBST1hZX0NPTlRSQUNUX0FERFJFU1MgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCIweGYyMDMzNmUxNkI1MTgyNjM3ZjA5ODIxYzI3QkRlMjliMEFGY2ZlODBcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcIjB4ZDA4NDYwNGU1RkEzODdGYkMyRGE4YkFhYjA3ZkRENmFERUQ0NjE0QVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiMHg5ZjA3MmJhMTliMzM3MGU1MTJhYTFiNGJmY2RhZjk3MjgzMTY4MDA1XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXTogXCIweDI5RGVhODJhMDUwOTE1M2I5MTA0MGVlMTNjREJiYTBmMDNlZmI2MjVcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcIjB4NkJmZmI0ZTg5NDUzMDY5RTc0ODdmMGZhNWM5ZjRhMkQ3NzFjY2U2Y1wiXG59O1xuY29uc3QgTVVMVElfQ0xVU1RFUl9ORVRXT1JLUyA9IFtcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQSxcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURSxcbiAgLy8gVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTixcbl07XG5jb25zdCBMRUdBQ1lfTkVUV09SS1NfUk9VVEVfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiYXF1YVwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImNlbGVzdGVcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJjeWFuXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwibWFpbm5ldFwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcInRlYWxcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9ERVZORVRcbiAgfVxufTtcbmNvbnN0IE5FVFdPUktfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwibWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiZ29lcmxpXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCJwb2x5Z29uLW1haW5uZXRcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwicG9seWdvbi1tYWlubmV0XCJcbn07XG5jb25zdCBTSUdORVJfTUFQID0ge1xuICBbVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXTogXCJodHRwczovL2FwaS53ZWIzYXV0aC5pby9zaWduZXItc2VydmljZVwiLFxuICBbVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9ERVZORVRdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL3NpZ25lci1zZXJ2aWNlXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJodHRwczovL2FwaS53ZWIzYXV0aC5pby9zaWduZXItc2VydmljZVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiaHR0cHM6Ly9hcGkud2ViM2F1dGguaW8vc2lnbmVyLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL3NpZ25lci1wb2x5Z29uLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL3NpZ25lci1wb2x5Z29uLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL3NpZ25lci1wb2x5Z29uLXNlcnZpY2VcIlxufTtcbmNvbnN0IE1FVEFEQVRBX01BUCA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL21ldGFkYXRhLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL21ldGFkYXRhLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL21ldGFkYXRhLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL21ldGFkYXRhLXNlcnZpY2VcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL21ldGFkYXRhLXNlcnZpY2VcIlxufTtcblxuLy8gRk5EIGJhY2tlbmQgc2VydmljZVxuY29uc3QgRk5EX1NFUlZFUiA9IFwiaHR0cHM6Ly9hcGkud2ViM2F1dGguaW8vZm5kLXNlcnZpY2VcIjtcblxuLy8gU2Vzc2lvbiBiYWNrZW5kIHNlcnZpY2VcbmNvbnN0IFNFU1NJT05fU0VSVkVSX0FQSV9VUkwgPSBcImh0dHBzOi8vYXBpLndlYjNhdXRoLmlvL3Nlc3Npb24tc2VydmljZVwiO1xuY29uc3QgU0VTU0lPTl9TRVJWRVJfU09DS0VUX1VSTCA9IFwiaHR0cHM6Ly9zZXNzaW9uLndlYjNhdXRoLmlvXCI7XG5cbi8vIEF1dGhqcyBiYWNrZW5kIHNlcnZpY2VcbmNvbnN0IEFVVEhKU19TRVJWRVJfVVJMID0gXCJodHRwczovL2FwaS53ZWIzYXV0aC5pby9hdXRoanMtc2VydmljZVwiO1xuY29uc3QgS0VZX1RZUEUgPSB7XG4gIFNFQ1AyNTZLMTogXCJzZWNwMjU2azFcIixcbiAgRUQyNTUxOTogXCJlZDI1NTE5XCJcbn07XG5jb25zdCBTSUdfVFlQRSA9IHtcbiAgRUNEU0FfU0VDUDI1NksxOiBcImVjZHNhLXNlY3AyNTZrMVwiLFxuICBFRDI1NTE5OiBcImVkMjU1MTlcIixcbiAgQklQMzQwOiBcImJpcDM0MFwiXG59O1xuXG5leHBvcnQgeyBBVVRISlNfU0VSVkVSX1VSTCwgRk5EX1NFUlZFUiwgS0VZX1RZUEUsIExFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAsIE1FVEFEQVRBX01BUCwgTVVMVElfQ0xVU1RFUl9ORVRXT1JLUywgTkVUV09SS19NQVAsIFBST1hZX0NPTlRSQUNUX0FERFJFU1MsIFNFU1NJT05fU0VSVkVSX0FQSV9VUkwsIFNFU1NJT05fU0VSVkVSX1NPQ0tFVF9VUkwsIFNJR05FUl9NQVAsIFNJR19UWVBFLCBUT1JVU19MRUdBQ1lfTkVUV09SSywgVE9SVVNfU0FQUEhJUkVfTkVUV09SSyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/constants/dist/lib.esm/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_0__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, n/no-unsupported-features/node-builtins\nconst browserCrypto = globalThis.crypto || globalThis.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(browserCrypto.randomBytes(size));\n  }\n  const arr = new Uint8Array(size);\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (!browserCrypto.createHash) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = browserCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle && subtle[op] && subtle.importKey) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      // encrypt and decrypt ops are not implemented in react-native-quick-crypto yet.\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\" && browserCrypto.createCipheriv) {\n      // This is available if crypto is polyfilled in react native environment\n      const cipher = browserCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\" && browserCrypto.createDecipheriv) {\n      const decipher = browserCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (!browserCrypto.createHmac) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = browserCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDOztBQUV0QyxlQUFlLHdDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9saWIuZXNtL2luZGV4LmpzP2E2NTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZWMgYXMgZWMkMSB9IGZyb20gJ2VsbGlwdGljJztcblxuY29uc3QgZWMgPSBuZXcgZWMkMShcInNlY3AyNTZrMVwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBuL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbmNvbnN0IGJyb3dzZXJDcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0byB8fCBnbG9iYWxUaGlzLm1zQ3J5cHRvIHx8IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbShcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiwgXCJoZXhcIik7XG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY2FsYXIoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFpc1NjYWxhcihwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleS5jb21wYXJlKFpFUk8zMikgPiAwICYmXG4gIC8vID4gMFxuICBwcml2YXRlS2V5LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMDsgLy8gPCBHXG59XG5cbi8vIENvbXBhcmUgdHdvIGJ1ZmZlcnMgaW4gY29uc3RhbnQgdGltZSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzLlxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjEsIGIyKSB7XG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIHJlcyB8PSBiMVtpXSBeIGIyW2ldOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxuICByZXR1cm4gcmVzID09PSAwO1xufVxuXG4vKiBUaGlzIG11c3QgY2hlY2sgaWYgd2UncmUgaW4gdGhlIGJyb3dzZXIgb3Jcbm5vdCwgc2luY2UgdGhlIGZ1bmN0aW9ucyBhcmUgZGlmZmVyZW50IGFuZCBkb2VzXG5ub3QgY29udmVydCB1c2luZyBicm93c2VyaWZ5ICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhzaXplKSB7XG4gIGlmICh0eXBlb2YgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnJvd3NlckNyeXB0by5yYW5kb21CeXRlcyhzaXplKSk7XG4gIH1cbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGJyb3dzZXJDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2hhNTEyKG1zZykge1xuICBpZiAoIWJyb3dzZXJDcnlwdG8uY3JlYXRlSGFzaCkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaGFzaCA9IGJyb3dzZXJDcnlwdG8uY3JlYXRlSGFzaChcInNoYTUxMlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gaGFzaC51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRBZXMob3ApIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdiwga2V5LCBkYXRhKSB7XG4gICAgaWYgKHN1YnRsZSAmJiBzdWJ0bGVbb3BdICYmIHN1YnRsZS5pbXBvcnRLZXkpIHtcbiAgICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW29wXSk7XG4gICAgICBjb25zdCBlbmNBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdlxuICAgICAgfTtcbiAgICAgIC8vIGVuY3J5cHQgYW5kIGRlY3J5cHQgb3BzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gcmVhY3QtbmF0aXZlLXF1aWNrLWNyeXB0byB5ZXQuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdWJ0bGVbb3BdKGVuY0FsZ29yaXRobSwgY3J5cHRvS2V5LCBkYXRhKTtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImVuY3J5cHRcIiAmJiBicm93c2VyQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KSB7XG4gICAgICAvLyBUaGlzIGlzIGF2YWlsYWJsZSBpZiBjcnlwdG8gaXMgcG9seWZpbGxlZCBpbiByZWFjdCBuYXRpdmUgZW52aXJvbm1lbnRcbiAgICAgIGNvbnN0IGNpcGhlciA9IGJyb3dzZXJDcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgY29uc3Qgc2Vjb25kQ2h1bmsgPSBjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZGVjcnlwdFwiICYmIGJyb3dzZXJDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdikge1xuICAgICAgY29uc3QgZGVjaXBoZXIgPSBicm93c2VyQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRDaHVuayA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7b3B9YCk7XG4gIH07XG59XG5jb25zdCBhZXNDYmNFbmNyeXB0ID0gZ2V0QWVzKFwiZW5jcnlwdFwiKTtcbmNvbnN0IGFlc0NiY0RlY3J5cHQgPSBnZXRBZXMoXCJkZWNyeXB0XCIpO1xuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpIHtcbiAgaWYgKCFicm93c2VyQ3J5cHRvLmNyZWF0ZUhtYWMpIHtcbiAgICBjb25zdCBpbXBvcnRBbGdvcml0aG0gPSB7XG4gICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogXCJTSEEtMjU2XCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgbmV3IFVpbnQ4QXJyYXkoa2V5KSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG4gICAgY29uc3Qgc2lnID0gYXdhaXQgc3VidGxlLnNpZ24oXCJITUFDXCIsIGNyeXB0b0tleSwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzaWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhtYWMgPSBicm93c2VyQ3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgQnVmZmVyLmZyb20oa2V5KSk7XG4gIGhtYWMudXBkYXRlKG1zZyk7XG4gIGNvbnN0IHJlc3VsdCA9IGhtYWMuZGlnZXN0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBobWFjU2hhMjU2VmVyaWZ5KGtleSwgbXNnLCBzaWcpIHtcbiAgY29uc3QgZXhwZWN0ZWRTaWcgPSBhd2FpdCBobWFjU2hhMjU2U2lnbihrZXksIG1zZyk7XG4gIHJldHVybiBlcXVhbENvbnN0VGltZShleHBlY3RlZFNpZywgc2lnKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyB2YWxpZCBwcml2YXRlIGtleS4gV2lsbCB1c2UgdGhlIHdpbmRvdy5jcnlwdG8gb3Igd2luZG93Lm1zQ3J5cHRvIGFzIHNvdXJjZVxuICogZGVwZW5kaW5nIG9uIHlvdXIgYnJvd3Nlci5cbiAqL1xuY29uc3QgZ2VuZXJhdGVQcml2YXRlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSkge1xuICAgIHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIH1cbiAgcmV0dXJuIHByaXZhdGVLZXk7XG59O1xuY29uc3QgZ2V0UHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgc3luYyBBUEkgc28gd2UgdGhyb3cgYW4gZXJyb3IgaW1tZWRpYXRlbHkuXG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICAvLyBYWFgoS2FnYW1pKTogYGVsbGlwdGljLnV0aWxzLmVuY29kZWAgcmV0dXJucyBhcnJheSBmb3IgZXZlcnlcbiAgLy8gZW5jb2RpbmcgZXhjZXB0IGBoZXhgLlxuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKFwiYXJyYXlcIikpO1xufTtcblxuLyoqXG4gKiBHZXQgY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHB1YmxpYyBrZXkuXG4gKi9cbmNvbnN0IGdldFB1YmxpY0NvbXByZXNzZWQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2FuZGVyZXIvc2VjcDI1NmsxLW5vZGUvaXNzdWVzLzQ2XG4gIGNvbnN0IGNvbXByZXNzZWQgPSB0cnVlO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKGNvbXByZXNzZWQsIFwiYXJyYXlcIikpO1xufTtcblxuLy8gTk9URShLYWdhbWkpOiBXZSBkb24ndCB1c2UgcHJvbWlzZSBzaGltIGluIEJyb3dzZXIgaW1wbGVtZW50YXRpb25cbi8vIGJlY2F1c2UgaXQncyBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gbmV3IGJyb3dzZXJzIChzZWVcbi8vIDxodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9cHJvbWlzZXM+KSBhbmQgd2UgY2FuIHVzZSBvbmx5IG5ldyBicm93c2Vyc1xuLy8gYmVjYXVzZSBvZiB0aGUgV2ViQ3J5cHRvQVBJIChzZWVcbi8vIDxodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9Y3J5cHRvZ3JhcGh5PikuXG5jb25zdCBzaWduID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZykge1xuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPiAwLCBcIk1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gMzIsIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLnNpZ24obXNnLCBwcml2YXRlS2V5LCB7XG4gICAgY2Fub25pY2FsOiB0cnVlXG4gIH0pLnRvREVSKCkpO1xufTtcbmNvbnN0IHZlcmlmeSA9IGFzeW5jIGZ1bmN0aW9uIChwdWJsaWNLZXksIG1zZywgc2lnKSB7XG4gIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXkubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleVswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSAyIHx8IHB1YmxpY0tleVswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBhc3NlcnQobXNnLmxlbmd0aCA+IDAsIFwiTWVzc2FnZSBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA8PSAzMiwgXCJNZXNzYWdlIGlzIHRvbyBsb25nXCIpO1xuICBpZiAoZWMudmVyaWZ5KG1zZywgc2lnLCBwdWJsaWNLZXkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNpZ25hdHVyZVwiKTtcbn07XG5jb25zdCBkZXJpdmUgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleUEsIHB1YmxpY0tleUIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUIpLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBhc3NlcnQocHJpdmF0ZUtleUEubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQocHVibGljS2V5Qi5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleUIubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gMiB8fCBwdWJsaWNLZXlCWzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleUEgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5QSk7XG4gIGNvbnN0IGtleUIgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleUIpO1xuICBjb25zdCBQeCA9IGtleUEuZGVyaXZlKGtleUIuZ2V0UHVibGljKCkpOyAvLyBCTiBpbnN0YW5jZVxuICByZXR1cm4gQnVmZmVyLmZyb20oUHgudG9BcnJheSgpKTtcbn07XG5jb25zdCBkZXJpdmVVbnBhZGRlZCA9IGRlcml2ZTtcbmNvbnN0IGRlcml2ZVBhZGRlZCA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b1N0cmluZygxNiwgNjQpLCBcImhleFwiKTtcbn07XG5jb25zdCBlbmNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleVRvLCBtc2csIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGxldCBlcGhlbVByaXZhdGVLZXkgPSBvcHRzLmVwaGVtUHJpdmF0ZUtleSB8fCByYW5kb21CeXRlcygzMik7XG4gIC8vIFRoZXJlIGlzIGEgdmVyeSB1bmxpa2VseSBwb3NzaWJpbGl0eSB0aGF0IGl0IGlzIG5vdCBhIHZhbGlkIGtleVxuICB3aGlsZSAoIWlzVmFsaWRQcml2YXRlS2V5KGVwaGVtUHJpdmF0ZUtleSkpIHtcbiAgICBlcGhlbVByaXZhdGVLZXkgPSBvcHRzLmVwaGVtUHJpdmF0ZUtleSB8fCByYW5kb21CeXRlcygzMik7XG4gIH1cbiAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBnZXRQdWJsaWMoZXBoZW1Qcml2YXRlS2V5KTtcbiAgY29uc3QgUHggPSBhd2FpdCBkZXJpdmVVbnBhZGRlZChlcGhlbVByaXZhdGVLZXksIHB1YmxpY0tleVRvKTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihQeCk7XG4gIGNvbnN0IGl2ID0gb3B0cy5pdiB8fCByYW5kb21CeXRlcygxNik7XG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgY29uc3QgbWFjS2V5ID0gaGFzaC5zbGljZSgzMik7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBhZXNDYmNFbmNyeXB0KGl2LCBCdWZmZXIuZnJvbShlbmNyeXB0aW9uS2V5KSwgbXNnKTtcbiAgY29uc3QgY2lwaGVydGV4dCA9IGRhdGE7XG4gIGNvbnN0IGRhdGFUb01hYyA9IEJ1ZmZlci5jb25jYXQoW2l2LCBlcGhlbVB1YmxpY0tleSwgY2lwaGVydGV4dF0pO1xuICBjb25zdCBtYWMgPSBhd2FpdCBobWFjU2hhMjU2U2lnbihCdWZmZXIuZnJvbShtYWNLZXkpLCBkYXRhVG9NYWMpO1xuICByZXR1cm4ge1xuICAgIGl2LFxuICAgIGVwaGVtUHVibGljS2V5LFxuICAgIGNpcGhlcnRleHQsXG4gICAgbWFjXG4gIH07XG59O1xuY29uc3QgZGVjcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5LCBvcHRzLCBfcGFkZGluZykge1xuICBjb25zdCBwYWRkaW5nID0gX3BhZGRpbmcgIT09IG51bGwgJiYgX3BhZGRpbmcgIT09IHZvaWQgMCA/IF9wYWRkaW5nIDogZmFsc2U7XG4gIGNvbnN0IGRlcml2ZUxvY2FsID0gcGFkZGluZyA/IGRlcml2ZVBhZGRlZCA6IGRlcml2ZVVucGFkZGVkO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZUxvY2FsKHByaXZhdGVLZXksIG9wdHMuZXBoZW1QdWJsaWNLZXkpO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YVRvTWFjID0gQnVmZmVyLmNvbmNhdChbb3B0cy5pdiwgb3B0cy5lcGhlbVB1YmxpY0tleSwgb3B0cy5jaXBoZXJ0ZXh0XSk7XG4gIGNvbnN0IG1hY0dvb2QgPSBhd2FpdCBobWFjU2hhMjU2VmVyaWZ5KEJ1ZmZlci5mcm9tKG1hY0tleSksIGRhdGFUb01hYywgb3B0cy5tYWMpO1xuICBpZiAoIW1hY0dvb2QgJiYgcGFkZGluZyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZGVjcnlwdChwcml2YXRlS2V5LCBvcHRzLCB0cnVlKTtcbiAgfSBlbHNlIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIE1BQyBhZnRlciB0cnlpbmcgcGFkZGVkXCIpO1xuICB9XG4gIGNvbnN0IG1zZyA9IGF3YWl0IGFlc0NiY0RlY3J5cHQob3B0cy5pdiwgQnVmZmVyLmZyb20oZW5jcnlwdGlvbktleSksIG9wdHMuY2lwaGVydGV4dCk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShtc2cpKTtcbn07XG5cbmV4cG9ydCB7IGRlY3J5cHQsIGRlcml2ZSwgZGVyaXZlUGFkZGVkLCBkZXJpdmVVbnBhZGRlZCwgZW5jcnlwdCwgZ2VuZXJhdGVQcml2YXRlLCBnZXRQdWJsaWMsIGdldFB1YmxpY0NvbXByZXNzZWQsIHNpZ24sIHZlcmlmeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/http-helpers/dist/lib.esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@toruslabs/http-helpers/dist/lib.esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"(ssr)/./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\n\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n}\n\n// #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n  try {\n    _url = new URL(url);\n  } catch {\n    // ignore\n  }\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const result = await sentry.startSpan({\n      name: url,\n      op: \"http.client\"\n    }, async () => {\n      const response = await fetch(url, init);\n      return response;\n    });\n    return result;\n  }\n  return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\nfunction debugLogResponse(response) {\n  log.info(`Response: ${response.status} ${response.statusText}`);\n  log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n  const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n  if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise) => {\n  let timeoutFunc = null;\n  try {\n    const timeout = new Promise((_resolve, reject) => {\n      timeoutFunc = setTimeout(() => {\n        reject(new Error(`Timed out in ${ms}ms`));\n      }, ms);\n    });\n    const result = await Promise.race([promise, timeout]);\n    // promise.race will return the first resolved promise\n    // then we clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    return result;\n  } catch (err) {\n    // clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    // rethrow the original error\n    throw err;\n  }\n};\nconst get = async (url, options_ = {}, customOptions = {}) => {\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  options_.method = \"GET\";\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_);\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst post = (url, data = {}, options_ = {}, customOptions = {}) => {\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  options_.method = \"POST\";\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_);\n\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (customOptions.logTracingHeader) {\n      logTracingHeader(response);\n    }\n    if (response.ok) {\n      const responseContentType = response.headers.get(\"content-type\");\n      if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n        return response.json();\n      }\n      return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async (url, data = {}, options_ = {}, customOptions = {}) => {\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  options_.method = \"PATCH\";\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_);\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async (url, data = {}, options_ = {}, customOptions = {}) => {\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  options_.method = \"PUT\";\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_);\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async (url, data = {}, options_ = {}, customOptions = {}) => {\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  options_.method = \"DELETE\";\n  const options = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_);\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = (url, options, timeout = 60000) => Promise.race([get(url, options), new Promise((_resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error(\"timed out\"));\n  }, timeout);\n})]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNuQztBQUNjOztBQUU1QyxZQUFZLHlEQUFrQjtBQUM5QixhQUFhLDRDQUFNOztBQUVuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsRUFBRSxvQkFBb0I7QUFDL0QsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQTtBQUNBLGtCQUFrQixnREFBSzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DLGVBQWUsb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZSxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQTtBQUNBLGtCQUFrQixnREFBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlLG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUV3UCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9saWIuZXNtL2luZGV4LmpzP2FmNGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IGxvZ0xldmVsLCB7IGxldmVscyB9IGZyb20gJ2xvZ2xldmVsJztcblxuY29uc3QgbG9nID0gbG9nTGV2ZWwuZ2V0TG9nZ2VyKFwiaHR0cC1oZWxwZXJzXCIpO1xubG9nLnNldExldmVsKGxldmVscy5JTkZPKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuXG5sZXQgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG5sZXQgZW1iZWRIb3N0ID0gXCJcIjtcblxuLy8gI3JlZ2lvbiBBUEkgS2V5c1xuY29uc3QgZ2F0ZXdheUF1dGhIZWFkZXIgPSBcIngtYXBpLWtleVwiO1xuY29uc3QgZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciA9IFwieC1lbWJlZC1ob3N0XCI7XG5sZXQgc2VudHJ5ID0gbnVsbDtcbmNvbnN0IHRyYWNpbmdPcmlnaW5zID0gW107XG5jb25zdCB0cmFjaW5nUGF0aHMgPSBbXTtcbmZ1bmN0aW9uIGVuYWJsZVNlbnRyeVRyYWNpbmcoX3NlbnRyeSwgX3RyYWNpbmdPcmlnaW5zLCBfdHJhY2luZ1BhdGhzKSB7XG4gIHNlbnRyeSA9IF9zZW50cnk7XG4gIHRyYWNpbmdPcmlnaW5zLnB1c2goLi4uX3RyYWNpbmdPcmlnaW5zKTtcbiAgdHJhY2luZ1BhdGhzLnB1c2goLi4uX3RyYWNpbmdQYXRocyk7XG59XG5mdW5jdGlvbiBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0Xykge1xuICBlbWJlZEhvc3QgPSBlbWJlZEhvc3RfO1xufVxuZnVuY3Rpb24gY2xlYXJFbWJlZEhvc3QoKSB7XG4gIGVtYmVkSG9zdCA9IFwiXCI7XG59XG5mdW5jdGlvbiBnZXRFbWJlZEhvc3QoKSB7XG4gIHJldHVybiBlbWJlZEhvc3Q7XG59XG5mdW5jdGlvbiBzZXRBUElLZXkoYXBpS2V5Xykge1xuICBhcGlLZXkgPSBhcGlLZXlfO1xufVxuZnVuY3Rpb24gY2xlYXJBUElLZXkoKSB7XG4gIGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xufVxuZnVuY3Rpb24gZ2V0QVBJS2V5KCkge1xuICByZXR1cm4gYXBpS2V5O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIGxvZy5zZXRMZXZlbChsZXZlbCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZFRyYWNlKHVybCwgaW5pdCkge1xuICBsZXQgX3VybCA9IG51bGw7XG4gIHRyeSB7XG4gICAgX3VybCA9IG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlXG4gIH1cbiAgaWYgKHNlbnRyeSAmJiBfdXJsICYmICh0cmFjaW5nT3JpZ2lucy5pbmNsdWRlcyhfdXJsLm9yaWdpbikgfHwgdHJhY2luZ1BhdGhzLmluY2x1ZGVzKF91cmwucGF0aG5hbWUpKSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbnRyeS5zdGFydFNwYW4oe1xuICAgICAgbmFtZTogdXJsLFxuICAgICAgb3A6IFwiaHR0cC5jbGllbnRcIlxuICAgIH0sIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBpbml0KTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBmZXRjaCh1cmwsIGluaXQpO1xufVxuZnVuY3Rpb24gZ2V0QXBpS2V5SGVhZGVycygpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYXBpS2V5KSBoZWFkZXJzW2dhdGV3YXlBdXRoSGVhZGVyXSA9IGFwaUtleTtcbiAgaWYgKGVtYmVkSG9zdCkgaGVhZGVyc1tnYXRld2F5RW1iZWRIb3N0SGVhZGVyXSA9IGVtYmVkSG9zdDtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGxvZy5pbmZvKGBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgbG9nLmluZm8oYFVybDogJHtyZXNwb25zZS51cmx9YCk7XG59XG5mdW5jdGlvbiBsb2dUcmFjaW5nSGVhZGVyKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHRyYWNpbmdIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtd2ViMy1jb3JyZWxhdGlvbi1pZFwiKTtcbiAgaWYgKHRyYWNpbmdIZWFkZXIpIGxvZy5pbmZvKGBSZXF1ZXN0IHRyYWNpbmcgd2l0aCB0cmFjZUlEID0gJHt0cmFjaW5nSGVhZGVyfWApO1xufVxuY29uc3QgcHJvbWlzZVRpbWVvdXQgPSBhc3luYyAobXMsIHByb21pc2UpID0+IHtcbiAgbGV0IHRpbWVvdXRGdW5jID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXRGdW5jID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVkIG91dCBpbiAke21zfW1zYCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dF0pO1xuICAgIC8vIHByb21pc2UucmFjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZVxuICAgIC8vIHRoZW4gd2UgY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgLy8gcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5jb25zdCBnZXQgPSBhc3luYyAodXJsLCBvcHRpb25zXyA9IHt9LCBjdXN0b21PcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge31cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgb3B0aW9uc18ubWV0aG9kID0gXCJHRVRcIjtcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXyk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gKHVybCwgZGF0YSA9IHt9LCBvcHRpb25zXyA9IHt9LCBjdXN0b21PcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIG9wdGlvbnNfLm1ldGhvZCA9IFwiUE9TVFwiO1xuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfKTtcblxuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2VUaW1lb3V0KGN1c3RvbU9wdGlvbnMudGltZW91dCB8fCA2MDAwMCwgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmIChjdXN0b21PcHRpb25zLmxvZ1RyYWNpbmdIZWFkZXIpIHtcbiAgICAgIGxvZ1RyYWNpbmdIZWFkZXIocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gICAgdGhyb3cgcmVzcG9uc2U7XG4gIH0pKTtcbn07XG5jb25zdCBwYXRjaCA9IGFzeW5jICh1cmwsIGRhdGEgPSB7fSwgb3B0aW9uc18gPSB7fSwgY3VzdG9tT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBvcHRpb25zXy5tZXRob2QgPSBcIlBBVENIXCI7XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18pO1xuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHB1dCA9IGFzeW5jICh1cmwsIGRhdGEgPSB7fSwgb3B0aW9uc18gPSB7fSwgY3VzdG9tT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBvcHRpb25zXy5tZXRob2QgPSBcIlBVVFwiO1xuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfKTtcbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCByZW1vdmUgPSBhc3luYyAodXJsLCBkYXRhID0ge30sIG9wdGlvbnNfID0ge30sIGN1c3RvbU9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgb3B0aW9uc18ubWV0aG9kID0gXCJERUxFVEVcIjtcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXyk7XG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBnZW5lcmF0ZUpzb25SUENPYmplY3QgPSAobWV0aG9kLCBwYXJhbWV0ZXJzKSA9PiAoe1xuICBqc29ucnBjOiBcIjIuMFwiLFxuICBtZXRob2QsXG4gIGlkOiAxMCxcbiAgcGFyYW1zOiBwYXJhbWV0ZXJzXG59KTtcbmNvbnN0IHByb21pc2VSYWNlID0gKHVybCwgb3B0aW9ucywgdGltZW91dCA9IDYwMDAwKSA9PiBQcm9taXNlLnJhY2UoW2dldCh1cmwsIG9wdGlvbnMpLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICByZWplY3QobmV3IEVycm9yKFwidGltZWQgb3V0XCIpKTtcbiAgfSwgdGltZW91dCk7XG59KV0pO1xuXG5leHBvcnQgeyBjbGVhckFQSUtleSwgY2xlYXJFbWJlZEhvc3QsIGVuYWJsZVNlbnRyeVRyYWNpbmcsIGdhdGV3YXlBdXRoSGVhZGVyLCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyLCBnZW5lcmF0ZUpzb25SUENPYmplY3QsIGdldCwgZ2V0QVBJS2V5LCBnZXRFbWJlZEhvc3QsIHBhdGNoLCBwb3N0LCBwcm9taXNlUmFjZSwgcHJvbWlzZVRpbWVvdXQsIHB1dCwgcmVtb3ZlLCBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgc2V0TG9nTGV2ZWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/http-helpers/dist/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   EthereumProviderError: () => (/* binding */ EthereumProviderError),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   JSON_RPC_SERVER_ERROR_MESSAGE: () => (/* binding */ JSON_RPC_SERVER_ERROR_MESSAGE),\n/* harmony export */   JsonRpcError: () => (/* binding */ JsonRpcError),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   dataHasCause: () => (/* binding */ dataHasCause),\n/* harmony export */   errorCodes: () => (/* binding */ errorCodes),\n/* harmony export */   errorValues: () => (/* binding */ errorValues),\n/* harmony export */   getMessageFromCode: () => (/* binding */ getMessageFromCode),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isValidCode: () => (/* binding */ isValidCode),\n/* harmony export */   isValidString: () => (/* binding */ isValidString),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerErrors: () => (/* binding */ providerErrors),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   rpcErrors: () => (/* binding */ rpcErrors),\n/* harmony export */   serializeCause: () => (/* binding */ serializeCause),\n/* harmony export */   serializeError: () => (/* binding */ serializeError),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/lib/ours/index.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/./node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\n\nfunction noop() {\n  return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n  constructor(_ref) {\n    let {\n      name,\n      target,\n      targetWindow = window,\n      targetOrigin = \"*\"\n    } = _ref;\n    super({\n      objectMode: true\n    });\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n    this._init = false;\n    this._haveSyn = false;\n    this._name = name;\n    this._target = target; // target origin\n    this._targetWindow = targetWindow;\n    this._targetOrigin = targetOrigin;\n    this._onMessage = this.onMessage.bind(this);\n    this._synIntervalId = null;\n    window.addEventListener(\"message\", this._onMessage, false);\n    this._handShake();\n  }\n  _break() {\n    this.cork();\n    this._write(BRK, null, noop);\n    this._haveSyn = false;\n    this._init = false;\n  }\n  _handShake() {\n    this._write(SYN, null, noop);\n    this.cork();\n  }\n  _onData(data) {\n    if (!this._init) {\n      // listen for handshake\n      if (data === SYN) {\n        this._haveSyn = true;\n        this._write(ACK, null, noop);\n      } else if (data === ACK) {\n        this._init = true;\n        if (!this._haveSyn) {\n          this._write(ACK, null, noop);\n        }\n        this.uncork();\n      }\n    } else if (data === BRK) {\n      this._break();\n    } else {\n      // forward message\n      try {\n        this.push(data);\n      } catch (err) {\n        this.emit(\"error\", err);\n      }\n    }\n  }\n  _postMessage(data) {\n    const originConstraint = this._targetOrigin;\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n  onMessage(event) {\n    const message = event.data;\n\n    // validate message\n    if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n      return;\n    }\n    this._onData(message.data);\n  }\n  _read() {\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _write(data, _, cb) {\n    this._postMessage(data);\n    cb();\n  }\n  _destroy() {\n    window.removeEventListener(\"message\", this._onMessage, false);\n  }\n}\n\nconst errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nconst errorValues = {\n  \"-32700\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n  },\n  \"-32600\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The JSON sent is not a valid Request object.\"\n  },\n  \"-32601\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The method does not exist / is not available.\"\n  },\n  \"-32602\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid method parameter(s).\"\n  },\n  \"-32603\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Internal JSON-RPC error.\"\n  },\n  \"-32000\": {\n    standard: \"EIP-1474\",\n    message: \"Invalid input.\"\n  },\n  \"-32001\": {\n    standard: \"EIP-1474\",\n    message: \"Resource not found.\"\n  },\n  \"-32002\": {\n    standard: \"EIP-1474\",\n    message: \"Resource unavailable.\"\n  },\n  \"-32003\": {\n    standard: \"EIP-1474\",\n    message: \"Transaction rejected.\"\n  },\n  \"-32004\": {\n    standard: \"EIP-1474\",\n    message: \"Method not supported.\"\n  },\n  \"-32005\": {\n    standard: \"EIP-1474\",\n    message: \"Request limit exceeded.\"\n  },\n  \"4001\": {\n    standard: \"EIP-1193\",\n    message: \"User rejected the request.\"\n  },\n  \"4100\": {\n    standard: \"EIP-1193\",\n    message: \"The requested account and/or method has not been authorized by the user.\"\n  },\n  \"4200\": {\n    standard: \"EIP-1193\",\n    message: \"The requested method is not supported by this Ethereum provider.\"\n  },\n  \"4900\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from all chains.\"\n  },\n  \"4901\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from the specified chain.\"\n  }\n};\n\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nconst JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */\nfunction isValidCode(code) {\n  return Number.isInteger(code);\n}\nfunction isValidString(value) {\n  return typeof value === \"string\" && value.length > 0;\n}\n\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n  return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */\nfunction isJsonRpcServerError(code) {\n  return code >= -32099 && code <= -32000;\n}\nfunction isJsonRpcError(value) {\n  const castValue = value;\n  if (!castValue) return false;\n  if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;\n  if (castValue.stack && !isValidString(castValue.stack)) return false;\n  return true;\n}\n\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */\nfunction getMessageFromCode(code) {\n  let fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n    if (Object.hasOwn(errorValues, codeString)) {\n      return errorValues[codeString].message;\n    }\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\nconst FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nfunction isValidJson(str) {\n  try {\n    JSON.parse(JSON.stringify(str, (strKey, strVal) => {\n      if (strKey === \"__proto__\" || strKey === \"constructor\") {\n        throw new Error(\"Not valid json\");\n      }\n      if (typeof strVal === \"function\" || typeof strVal === \"symbol\") {\n        throw new Error(\"Not valid json\");\n      }\n      return strVal;\n    }), (propKey, propValue) => {\n      // Strip __proto__ and constructor properties to prevent prototype pollution.\n      if (propKey === \"__proto__\" || propKey === \"constructor\") {\n        return undefined;\n      }\n      return propValue;\n    });\n    // this means, it's a valid json so far\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */\nfunction serializeObject(object) {\n  return Object.getOwnPropertyNames(object).reduce((acc, key) => {\n    const value = object[key];\n    if (isValidJson(value)) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */\nfunction serializeCause(error) {\n  if (Array.isArray(error)) {\n    return error.map(entry => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject(error)) {\n    return serializeObject(error);\n  }\n  if (isValidJson(error)) {\n    return error;\n  }\n  return null;\n}\n\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */\nfunction buildError(error, fallbackError) {\n  // If an error specifies a `serialize` function, we call it and return the result.\n  if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n    return error.serialize();\n  }\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n\n  // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n  const cause = serializeCause(error);\n  const fallbackWithCause = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, fallbackError), {}, {\n    data: {\n      cause\n    }\n  });\n  return fallbackWithCause;\n}\n\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */\nfunction serializeError(error) {\n  let {\n    fallbackError = FALLBACK_ERROR,\n    shouldIncludeStack = true\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\"Must provide fallback error with integer number code and string message.\");\n  }\n  const serialized = buildError(error, fallbackError);\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n  return serialized;\n}\n\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */\nfunction dataHasCause(data) {\n  return isObject(data) && Object.hasOwn(data, \"cause\") && isObject(data.cause);\n}\n\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */\nfunction stringifyReplacer(_, value) {\n  if (value === \"[Circular]\") {\n    return undefined;\n  }\n  return value;\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */\nclass JsonRpcError extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n    if (dataHasCause(data)) {\n      super(message, {\n        cause: data.cause\n      });\n\n      // Browser backwards-compatibility fallback\n      // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n      if (!Object.hasOwn(this, \"cause\")) {\n        Object.assign(this, {\n          cause: data.cause\n        });\n      }\n    } else {\n      super(message);\n      // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n      _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n    }\n    if (data !== undefined) {\n      this.data = data;\n    }\n    this.code = code;\n    this.cause = data === null || data === void 0 ? void 0 : data.cause;\n  }\n\n  /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== undefined) {\n      // `this.data` is not guaranteed to be a plain object, but this simplifies\n      // the type guard below. We can safely cast it because we know it's a\n      // JSON-serializable value.\n      serialized.data = this.data;\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n\n  /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */\n  toString() {\n    return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()(this.serialize(), stringifyReplacer, 2);\n  }\n}\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nclass EthereumProviderError extends JsonRpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(code, message, data);\n  }\n}\n\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === \"string\") {\n      return [arg];\n    } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n      const {\n        message,\n        data\n      } = arg;\n      if (message && typeof message !== \"string\") {\n        throw new Error(\"Must specify string message.\");\n      }\n      return [message !== null && message !== void 0 ? message : undefined, data];\n    }\n  }\n  return [];\n}\n\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */\nfunction getJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\n\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\nconst rpcErrors = {\n  /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  parse: arg => getJsonRpcError(errorCodes.rpc.parse, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidRequest: arg => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidParams: arg => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n  /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotFound: arg => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n  /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  internal: arg => getJsonRpcError(errorCodes.rpc.internal, arg),\n  /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  server: opts => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n    }\n    const {\n      code\n    } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n    }\n    return getJsonRpcError(code, opts);\n  },\n  /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidInput: arg => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceNotFound: arg => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceUnavailable: arg => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n  /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  transactionRejected: arg => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n  /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotSupported: arg => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n  /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  limitExceeded: arg => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nconst providerErrors = {\n  /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  userRejectedRequest: arg => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unauthorized: arg => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unsupportedMethod: arg => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n  /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  disconnected: arg => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n  /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  chainDisconnected: arg => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n  /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  custom: opts => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n    }\n    const {\n      code,\n      message,\n      data\n    } = opts;\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  }\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n  return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n  emit(type) {\n    let doError = type === \"error\";\n    const events = this._events;\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    }\n\n    // If there is no 'error' event listener then throw.\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (doError) {\n      let er;\n      if (args.length > 0) {\n        [er] = args;\n      }\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      }\n      // At least give some kind of context to the user\n      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n    const handler = events[type];\n    if (handler === undefined) {\n      return false;\n    }\n    if (typeof handler === \"function\") {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n    return true;\n  }\n}\n\nclass SerializableError extends Error {\n  constructor(_ref) {\n    let {\n      code,\n      message,\n      data\n    } = _ref;\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n    super(message);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n    this.code = code;\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n  toString() {\n    return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()({\n      code: this.code,\n      message: this.message,\n      data: this.data,\n      stack: this.stack\n    });\n  }\n}\n\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return (req, res, next, end) => {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n      next(done => {\n        const {\n          error\n        } = res;\n        if (!error) {\n          return done();\n        }\n        log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n        return done();\n      });\n    } catch (error) {\n      log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  const idMap = {};\n  function readNoop() {\n    return false;\n  }\n  const events = new SafeEventEmitter();\n  function processResponse(res) {\n    const context = idMap[res.id];\n    if (!context) {\n      throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n    }\n    delete idMap[res.id];\n    // copy whole res onto original res\n    Object.assign(context.res, res);\n    // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n    setTimeout(context.end);\n  }\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n  function processMessage(res, _encoding, cb) {\n    let err;\n    try {\n      const isNotification = !res.id;\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    }\n    // continue processing stream\n    cb(err);\n  }\n  const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n  const middleware = (req, res, next, end) => {\n    // write req to stream\n    stream.push(req);\n    // register request on id map\n    idMap[req.id] = {\n      req,\n      res,\n      next,\n      end\n    };\n  };\n  return {\n    events,\n    middleware,\n    stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method];\n    // if no handler, return\n    if (handler === undefined) {\n      return next();\n    }\n    // if handler is fn, call as middleware\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    }\n    // if handler is some other value, use as result\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return (req, res, next, _end) => {\n    const originalId = req.id;\n    const newId = Math.random().toString(36).slice(2);\n    req.id = newId;\n    res.id = newId;\n    next(done => {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return (req, res, next, _) => {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false;\n\n    // This will be called by the consumer's async middleware.\n    const asyncNext = async () => {\n      nextWasCalled = true;\n\n      // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n\n      next(runReturnHandlersCallback => {\n        // This callback comes from JRPCEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (err) {\n      const error = err;\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JRPCEngine extends SafeEventEmitter {\n  constructor() {\n    super();\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n    this._middleware = [];\n  }\n\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n  static async _runAllMiddleware(req, res, middlewareStack) {\n    const returnHandlers = [];\n    let error = null;\n    let isComplete = false;\n\n    // Go down stack of middleware, call and collect optional returnHandlers\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n      if (isComplete) {\n        break;\n      }\n    }\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * and a boolean indicating whether the request should end.\n   */\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n        if (error) {\n          if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n          res.error = serializeError(error, {\n            shouldIncludeStack: true,\n            fallbackError: {\n              message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()),\n              code: (error === null || error === void 0 ? void 0 : error.code) || -32603,\n              stack: (error === null || error === void 0 ? void 0 : error.stack) || \"Stack trace is not available.\",\n              data: (error === null || error === void 0 ? void 0 : error.data) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString())\n            }\n          });\n        }\n        // True indicates that the request should end\n        resolve([error, true]);\n      };\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== \"function\") {\n              end(new SerializableError({\n                code: -32603,\n                message: \"JRPCEngine: 'next' return handlers must be functions\"\n              }));\n            }\n            returnHandlers.push(returnHandler);\n          }\n\n          // False indicates that the request should not end\n          resolve([null, false]);\n        }\n      };\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n  static async _runReturnHandlers(handlers) {\n    for (const handler of handlers) {\n      await new Promise((resolve, reject) => {\n        handler(err => err ? reject(err) : resolve());\n      });\n    }\n  }\n\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n  static _checkForCompletion(_req, res, isComplete) {\n    if (!(\"result\" in res) && !(\"error\" in res)) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Response has no error or result for request\"\n      });\n    }\n    if (!isComplete) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Nothing ended request\"\n      });\n    }\n  }\n\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */\n\n  /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */\n\n  /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @returns A promise that resolves with the response, or rejects with an\n   * error.\n   */\n\n  /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @returns A promise that resolves with the array of responses, or rejects\n   * with an error.\n   */\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handle(req, cb) {\n    if (cb && typeof cb !== \"function\") {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n      return this._handleBatch(req);\n    }\n    if (cb) {\n      return this._handle(req, cb);\n    }\n    return this._promiseHandle(req);\n  }\n\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n  asMiddleware() {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        if (isComplete) {\n          await JRPCEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n        return next(async handlerCallback => {\n          try {\n            await JRPCEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n\n  /**\n   * Like _handle, but for batch requests.\n   */\n\n  async _handleBatch(reqs, cb) {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all(\n      // 1. Begin executing each request in the order received\n      reqs.map(this._promiseHandle.bind(this)));\n\n      // 3. Return batch response\n      if (cb) {\n        return cb(null, responses);\n      }\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * A promise-wrapped _handle.\n   */\n  _promiseHandle(req) {\n    return new Promise((resolve, reject) => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        if (_err && res === undefined) {\n          reject(_err);\n        } else resolve(res);\n      }).catch(reject);\n    });\n  }\n\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n  async _handle(callerReq, cb) {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"request must be plain object\"\n      });\n      return cb(error, {\n        id: undefined,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n    if (typeof callerReq.method !== \"string\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"method must be string\"\n      });\n      return cb(error, {\n        id: callerReq.id,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n    const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, callerReq);\n    const res = {\n      id: req.id,\n      jsonrpc: req.jsonrpc\n    };\n    let error = null;\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n      if (!res.error) {\n        var _error2, _error3, _error4, _error5, _error6, _error7, _error8;\n        if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n        res.error = serializeError(error, {\n          shouldIncludeStack: true,\n          fallbackError: {\n            message: ((_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.toString()),\n            code: ((_error4 = error) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,\n            stack: ((_error5 = error) === null || _error5 === void 0 ? void 0 : _error5.stack) || \"Stack trace is not available.\",\n            data: ((_error6 = error) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error) === null || _error8 === void 0 ? void 0 : _error8.toString())\n          }\n        });\n      }\n    }\n    return cb(error, res);\n  }\n\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n  async _processRequest(req, res) {\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n    // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n    JRPCEngine._checkForCompletion(req, res, isComplete);\n\n    // The return handlers should run even if an error was encountered during\n    // middleware processing.\n    await JRPCEngine._runReturnHandlers(returnHandlers);\n\n    // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n    if (error) {\n      throw error;\n    }\n  }\n}\nfunction mergeMiddleware(middlewareStack) {\n  const engine = new JRPCEngine();\n  middlewareStack.forEach(middleware => engine.push(middleware));\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n  const {\n    engine\n  } = opts;\n  // eslint-disable-next-line prefer-const\n  let stream;\n  function read() {\n    return undefined;\n  }\n  function write(req, _encoding, cb) {\n    engine.handle(req, (_err, res) => {\n      stream.push(res);\n    });\n    cb();\n  }\n  stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n    objectMode: true,\n    read,\n    write\n  });\n\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      stream.push(message);\n    });\n  }\n  return stream;\n}\nfunction providerFromEngine(engine) {\n  const provider = new SafeEventEmitter();\n  // handle both rpc send methods\n  provider.sendAsync = async req => {\n    const res = await engine.handle(req);\n    if (res.error) {\n      var _res$error, _res$error2, _res$error3, _res$error4, _res$error5, _res$error6, _res$error7;\n      if (typeof res.error === \"object\" && Object.keys(res.error).includes(\"stack\") === false) res.error.stack = \"Stack trace is not available.\";\n      const err = serializeError(res.error, {\n        fallbackError: {\n          message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.toString()),\n          code: ((_res$error3 = res.error) === null || _res$error3 === void 0 ? void 0 : _res$error3.code) || -32603,\n          stack: ((_res$error4 = res.error) === null || _res$error4 === void 0 ? void 0 : _res$error4.stack) || \"Stack trace is not available.\",\n          data: ((_res$error5 = res.error) === null || _res$error5 === void 0 ? void 0 : _res$error5.data) || ((_res$error6 = res.error) === null || _res$error6 === void 0 ? void 0 : _res$error6.message) || ((_res$error7 = res.error) === null || _res$error7 === void 0 ? void 0 : _res$error7.toString())\n        },\n        shouldIncludeStack: true\n      });\n      throw rpcErrors.internal(err);\n    }\n    return res.result;\n  };\n  provider.send = (req, callback) => {\n    if (typeof callback !== \"function\") {\n      throw new Error('Must provide callback to \"send\" method.');\n    }\n    engine.handle(req, callback);\n  };\n  // forward notifications\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      provider.emit(\"data\", null, message);\n    });\n  }\n  provider.request = async args => {\n    const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, args), {}, {\n      id: Math.random().toString(36).slice(2),\n      jsonrpc: \"2.0\"\n    });\n    const res = await provider.sendAsync(req);\n    return res;\n  };\n  return provider;\n}\nfunction providerFromMiddleware(middleware) {\n  const engine = new JRPCEngine();\n  engine.push(middleware);\n  const provider = providerFromEngine(engine);\n  return provider;\n}\nfunction providerAsMiddleware(provider) {\n  return async (req, res, _next, end) => {\n    // send request to provider\n    try {\n      const providerRes = await provider.sendAsync(req);\n      res.result = providerRes;\n      return end();\n    } catch (error) {\n      return end(error);\n    }\n  };\n}\n\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n  constructor(_ref) {\n    let {\n      parent,\n      name\n    } = _ref;\n    super({\n      objectMode: true\n    });\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n    this._parent = parent;\n    this._name = name;\n  }\n\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n  _read() {\n    return undefined;\n  }\n\n  /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */\n  _write(chunk, _encoding, callback) {\n    this._parent.push({\n      name: this._name,\n      data: chunk\n    });\n    callback();\n  }\n}\n\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, opts), {}, {\n      objectMode: true\n    }));\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n    this._substreams = {};\n  }\n  createStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n\n    // create substream\n    const substream = new Substream({\n      parent: this,\n      name\n    });\n    this._substreams[name] = substream;\n\n    // listen for parent stream to end\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    anyStreamEnd(this, _error => substream.destroy(_error || undefined));\n    return substream;\n  }\n\n  // ignore streams (dont display orphaned data warning)\n  ignoreStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n    if (this._substreams[name]) {\n      throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n    }\n    // set\n    this._substreams[name] = IGNORE_SUBSTREAM;\n  }\n  _read() {\n    return undefined;\n  }\n  _write(chunk, _encoding, callback) {\n    const {\n      name,\n      data\n    } = chunk;\n    if (!name) {\n      window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n      return callback();\n    }\n\n    // get corresponding substream\n    const substream = this._substreams[name];\n    if (!substream) {\n      window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n      return callback();\n    }\n\n    // push data into substream\n    if (substream !== IGNORE_SUBSTREAM) {\n      substream.push(data);\n    }\n    return callback();\n  }\n}\n\n// util\nfunction anyStreamEnd(stream, _cb) {\n  const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\n  end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n    readable: false\n  }, cb);\n  end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n    writable: false\n  }, cb);\n}\nfunction setupMultiplex(stream) {\n  const mux = new ObjectMultiplex();\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n    return this.createStream(name);\n  };\n  pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, err => {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nclass PostMessageStream extends BasePostMessageStream {\n  _postMessage(data) {\n    let originConstraint = this._targetOrigin;\n    if (typeof data === \"object\") {\n      const dataObj = data;\n      if (typeof dataObj.data === \"object\") {\n        const dataObjData = dataObj.data;\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n          const dataObjDataParam = dataObjData.params[0];\n          if (dataObjDataParam._origin) {\n            originConstraint = dataObjDataParam._origin;\n          }\n\n          // add a constraint for the response\n          dataObjDataParam._origin = window.location.origin;\n        }\n      }\n    }\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDM0I7QUFDTztBQUNpQjtBQUMzQjtBQUNOO0FBQ1I7QUFDQTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUcsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsTUFBTSw0RUFBZTtBQUNyQixNQUFNLDRFQUFlO0FBQ3JCLE1BQU0sNEVBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLDRFQUFlO0FBQ3JCLE1BQU0sNEVBQWU7QUFDckIsTUFBTSw0RUFBZTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBEQUFhO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkJBQTZCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnREFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsV0FBVyxRQUFRO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMERBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEVBQWU7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsMkVBQWEsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxtREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLDJFQUFhLENBQUMsMkVBQWEsR0FBRyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtREFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1EQUFNO0FBQ3BDO0FBQ0E7QUFDQSxVQUFVLDJFQUFhLENBQUMsMkVBQWEsR0FBRyxXQUFXO0FBQ25EO0FBQ0EsS0FBSztBQUNMLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2RUFBNkUsTUFBTTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxLQUFLO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMkNBQUk7QUFDakIsRUFBRSxvREFBRztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUUsb0RBQUc7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFJO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVpcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLWpycGMvZGlzdC9vcGVubG9naW5KcnBjLmVzbS5qcz84ZTJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tICdyZWFkYWJsZS1zdHJlYW0nO1xuaW1wb3J0IHNhZmVTdHJpbmdpZnkgZnJvbSAnZmFzdC1zYWZlLXN0cmluZ2lmeSc7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBlb3MgZnJvbSAnZW5kLW9mLXN0cmVhbSc7XG5pbXBvcnQgb25jZSBmcm9tICdvbmNlJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuXG5mdW5jdGlvbiBub29wKCkge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY29uc3QgU1lOID0gXCJTWU5cIjtcbmNvbnN0IEFDSyA9IFwiQUNLXCI7XG5jb25zdCBCUksgPSBcIkJSS1wiO1xuY2xhc3MgQmFzZVBvc3RNZXNzYWdlU3RyZWFtIGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBuYW1lLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGFyZ2V0V2luZG93ID0gd2luZG93LFxuICAgICAgdGFyZ2V0T3JpZ2luID0gXCIqXCJcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2luaXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaGF2ZVN5blwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRXaW5kb3dcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0T3JpZ2luXCIsIHZvaWQgMCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N5bkludGVydmFsSWRcIiwgdm9pZCAwKTtcbiAgICBpZiAoIW5hbWUgfHwgIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgfVxuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0OyAvLyB0YXJnZXQgb3JpZ2luXG4gICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gdGFyZ2V0V2luZG93O1xuICAgIHRoaXMuX3RhcmdldE9yaWdpbiA9IHRhcmdldE9yaWdpbjtcbiAgICB0aGlzLl9vbk1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3N5bkludGVydmFsSWQgPSBudWxsO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kU2hha2UoKTtcbiAgfVxuICBfYnJlYWsoKSB7XG4gICAgdGhpcy5jb3JrKCk7XG4gICAgdGhpcy5fd3JpdGUoQlJLLCBudWxsLCBub29wKTtcbiAgICB0aGlzLl9oYXZlU3luID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdCA9IGZhbHNlO1xuICB9XG4gIF9oYW5kU2hha2UoKSB7XG4gICAgdGhpcy5fd3JpdGUoU1lOLCBudWxsLCBub29wKTtcbiAgICB0aGlzLmNvcmsoKTtcbiAgfVxuICBfb25EYXRhKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuX2luaXQpIHtcbiAgICAgIC8vIGxpc3RlbiBmb3IgaGFuZHNoYWtlXG4gICAgICBpZiAoZGF0YSA9PT0gU1lOKSB7XG4gICAgICAgIHRoaXMuX2hhdmVTeW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBBQ0spIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faGF2ZVN5bikge1xuICAgICAgICAgIHRoaXMuX3dyaXRlKEFDSywgbnVsbCwgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IEJSSykge1xuICAgICAgdGhpcy5fYnJlYWsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yd2FyZCBtZXNzYWdlXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Bvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBvcmlnaW5Db25zdHJhaW50ID0gdGhpcy5fdGFyZ2V0T3JpZ2luO1xuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcblxuICAgIC8vIHZhbGlkYXRlIG1lc3NhZ2VcbiAgICBpZiAodGhpcy5fdGFyZ2V0T3JpZ2luICE9PSBcIipcIiAmJiBldmVudC5vcmlnaW4gIT09IHRoaXMuX3RhcmdldE9yaWdpbiB8fCBldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdyB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlLnRhcmdldCAhPT0gdGhpcy5fbmFtZSB8fCAhbWVzc2FnZS5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX29uRGF0YShtZXNzYWdlLmRhdGEpO1xuICB9XG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBfd3JpdGUoZGF0YSwgXywgY2IpIHtcbiAgICB0aGlzLl9wb3N0TWVzc2FnZShkYXRhKTtcbiAgICBjYigpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbk1lc3NhZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG5jb25zdCBlcnJvckNvZGVzID0ge1xuICBycGM6IHtcbiAgICBpbnZhbGlkSW5wdXQ6IC0zMjAwMCxcbiAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogLTMyMDAyLFxuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IC0zMjAwMyxcbiAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICBsaW1pdEV4Y2VlZGVkOiAtMzIwMDUsXG4gICAgcGFyc2U6IC0zMjcwMCxcbiAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgIG1ldGhvZE5vdEZvdW5kOiAtMzI2MDEsXG4gICAgaW52YWxpZFBhcmFtczogLTMyNjAyLFxuICAgIGludGVybmFsOiAtMzI2MDNcbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgIHVuYXV0aG9yaXplZDogNDEwMCxcbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogNDIwMCxcbiAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IDQ5MDFcbiAgfVxufTtcbmNvbnN0IGVycm9yVmFsdWVzID0ge1xuICBcIi0zMjcwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LlwiXG4gIH0sXG4gIFwiLTMyNjAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXCJcbiAgfSxcbiAgXCItMzI2MDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgfSxcbiAgXCItMzI2MDJcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLlwiXG4gIH0sXG4gIFwiLTMyNjAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludGVybmFsIEpTT04tUlBDIGVycm9yLlwiXG4gIH0sXG4gIFwiLTMyMDAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBpbnB1dC5cIlxuICB9LFxuICBcIi0zMjAwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIG5vdCBmb3VuZC5cIlxuICB9LFxuICBcIi0zMjAwMlwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlc291cmNlIHVuYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyMDAzXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gcmVqZWN0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDRcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJNZXRob2Qgbm90IHN1cHBvcnRlZC5cIlxuICB9LFxuICBcIi0zMjAwNVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlJlcXVlc3QgbGltaXQgZXhjZWVkZWQuXCJcbiAgfSxcbiAgXCI0MDAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC5cIlxuICB9LFxuICBcIjQxMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci5cIlxuICB9LFxuICBcIjQyMDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xMTkzXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuXCJcbiAgfSxcbiAgXCI0OTAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIGFsbCBjaGFpbnMuXCJcbiAgfSxcbiAgXCI0OTAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uXCJcbiAgfVxufTtcblxuY29uc3QgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yQ29kZXMucnBjLmludGVybmFsO1xuY29uc3QgRkFMTEJBQ0tfTUVTU0FHRSA9IFwiVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC5cIjtcbmNvbnN0IEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gXCJVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuXCI7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqIEEgY29kZSBpcyB2YWxpZCBpZiBpdCBpcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGFuIG9iamVjdCBpcyB0aGUgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsXG4gKiBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBwbGFpbiAoZS5nLiBmdW5jdGlvbikuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgc2VydmVyIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBzZXJ2ZXIgZXJyb3IgY29kZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAtMzIwOTkgJiYgY29kZSA8PSAtMzIwMDA7XG59XG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICBjb25zdCBjYXN0VmFsdWUgPSB2YWx1ZTtcbiAgaWYgKCFjYXN0VmFsdWUpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc1ZhbGlkQ29kZShjYXN0VmFsdWUuY29kZSkgfHwgIWlzVmFsaWRTdHJpbmcoY2FzdFZhbHVlLm1lc3NhZ2UpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChjYXN0VmFsdWUuc3RhY2sgJiYgIWlzVmFsaWRTdHJpbmcoY2FzdFZhbHVlLnN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtZXNzYWdlIGZvciBhIGdpdmVuIGNvZGUsIG9yIGEgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZSBoYXNcbiAqIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGZhbGxiYWNrTWVzc2FnZSAtIFRoZSBmYWxsYmFjayBtZXNzYWdlIHRvIHVzZSBpZiB0aGUgY29kZSBoYXMgbm9cbiAqIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gY29kZSwgb3IgdGhlIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGVcbiAqIGhhcyBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSB7XG4gIGxldCBmYWxsYmFja01lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IEZBTExCQUNLX01FU1NBR0U7XG4gIGlmIChpc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgaWYgKE9iamVjdC5oYXNPd24oZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XG4gICAgICByZXR1cm4gZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10ubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpXG59O1xuZnVuY3Rpb24gaXNWYWxpZEpzb24oc3RyKSB7XG4gIHRyeSB7XG4gICAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzdHIsIChzdHJLZXksIHN0clZhbCkgPT4ge1xuICAgICAgaWYgKHN0cktleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBzdHJLZXkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgdmFsaWQganNvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3RyVmFsID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHN0clZhbCA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgdmFsaWQganNvblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJWYWw7XG4gICAgfSksIChwcm9wS2V5LCBwcm9wVmFsdWUpID0+IHtcbiAgICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgICBpZiAocHJvcEtleSA9PT0gXCJfX3Byb3RvX19cIiB8fCBwcm9wS2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfSk7XG4gICAgLy8gdGhpcyBtZWFucywgaXQncyBhIHZhbGlkIGpzb24gc28gZmFyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYWxsIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgaW4gcXVlc3Rpb24uXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYgKGlzVmFsaWRKc29uKHZhbHVlKSkge1xuICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYW4gdW5rbm93biBlcnJvciB0byBiZSB1c2VkIGFzIHRoZSBgY2F1c2VgIGluIGEgZmFsbGJhY2sgZXJyb3IuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHVua25vd24gZXJyb3IuXG4gKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCBjb250YWluaW5nIGFzIG11Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGVycm9yIGFzIHBvc3NpYmxlLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVDYXVzZShlcnJvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3IubWFwKGVudHJ5ID0+IHtcbiAgICAgIGlmIChpc1ZhbGlkSnNvbihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChlcnJvcikpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVycm9yKTtcbiAgfVxuICBpZiAoaXNWYWxpZEpzb24oZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCBnaXZlbiBhbiBlcnJvciBhbmQgYSBKU09OIHNlcmlhbGl6YWJsZSBgZmFsbGJhY2tFcnJvcmBcbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgaW4gcXVlc3Rpb24uXG4gKiBAcGFyYW0gZmFsbGJhY2tFcnJvciAtIEEgSlNPTiBzZXJpYWxpemFibGUgZmFsbGJhY2sgZXJyb3IuXG4gKiBAcmV0dXJucyBBIEpTT04gc2VyaWFsaXphYmxlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvcikge1xuICAvLyBJZiBhbiBlcnJvciBzcGVjaWZpZXMgYSBgc2VyaWFsaXplYCBmdW5jdGlvbiwgd2UgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzZXJpYWxpemVcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gIH1cbiAgaWYgKGlzSnNvblJwY0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIElmIHRoZSBlcnJvciBkb2VzIG5vdCBtYXRjaCB0aGUgSnNvblJwY0Vycm9yIHR5cGUsIHVzZSB0aGUgZmFsbGJhY2sgZXJyb3IsIGJ1dCB0cnkgdG8gaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgYXMgYGNhdXNlYC5cbiAgY29uc3QgY2F1c2UgPSBzZXJpYWxpemVDYXVzZShlcnJvcik7XG4gIGNvbnN0IGZhbGxiYWNrV2l0aENhdXNlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBmYWxsYmFja0Vycm9yKSwge30sIHtcbiAgICBkYXRhOiB7XG4gICAgICBjYXVzZVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmYWxsYmFja1dpdGhDYXVzZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXG4gKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLmNhdXNlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMuZmFsbGJhY2tFcnJvciAtIFRoZSBlcnJvciB0byByZXR1cm4gaWYgdGhlIGdpdmVuIGVycm9yIGlzXG4gKiBub3QgY29tcGF0aWJsZS4gU2hvdWxkIGJlIGEgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRJbmNsdWRlU3RhY2sgLSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGVycm9yJ3Mgc3RhY2tcbiAqIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0Vycm9yID0gRkFMTEJBQ0tfRVJST1IsXG4gICAgc2hvdWxkSW5jbHVkZVN0YWNrID0gdHJ1ZVxuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgaWYgKCFpc0pzb25ScGNFcnJvcihmYWxsYmFja0Vycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBmYWxsYmFjayBlcnJvciB3aXRoIGludGVnZXIgbnVtYmVyIGNvZGUgYW5kIHN0cmluZyBtZXNzYWdlLlwiKTtcbiAgfVxuICBjb25zdCBzZXJpYWxpemVkID0gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvcik7XG4gIGlmICghc2hvdWxkSW5jbHVkZVN0YWNrKSB7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuc3RhY2s7XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHN1cHBsaWVkIGVycm9yIGRhdGEgaGFzIGEgdXNhYmxlIGBjYXVzZWAgcHJvcGVydHk7IGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIGNhdXNlIHByb3BlcnR5IGlzIHByZXNlbnQgYW5kIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGF0YUhhc0NhdXNlKGRhdGEpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGRhdGEpICYmIE9iamVjdC5oYXNPd24oZGF0YSwgXCJjYXVzZVwiKSAmJiBpc09iamVjdChkYXRhLmNhdXNlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29kZSBpcyBhIHZhbGlkIEpTT04tUlBDIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGNvZGUgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuXG4vKipcbiAqIEEgSlNPTiByZXBsYWNlciBmdW5jdGlvbiB0aGF0IG9taXRzIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIF8gLSBUaGUga2V5IGJlaW5nIHJlcGxhY2VkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHJlcGxhY2VkLlxuICogQHJldHVybnMgVGhlIHZhbHVlIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJbQ2lyY3VsYXJdXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgSlNPTiBSUEMgMi4wIGVycm9ycyBhbmQgRXRoZXJldW0gUlBDIGVycm9yc1xuICogcGVyIEVJUC0xNDc0LlxuICpcbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xuY2xhc3MgSnNvblJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YUhhc0NhdXNlKGRhdGEpKSB7XG4gICAgICBzdXBlcihtZXNzYWdlLCB7XG4gICAgICAgIGNhdXNlOiBkYXRhLmNhdXNlXG4gICAgICB9KTtcblxuICAgICAgLy8gQnJvd3NlciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmYWxsYmFja1xuICAgICAgLy8gVGhlIGBjYXVzZWAgZGVmaW5pdGlvbiBjYW4gYmUgcmVtb3ZlZCB3aGVuIHRzY29uZmlnIGxpYiBhbmQvb3IgdGFyZ2V0IGhhdmUgY2hhbmdlZCB0byA+PWVzMjAyMlxuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICAgIGlmICghT2JqZWN0Lmhhc093bih0aGlzLCBcImNhdXNlXCIpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgIGNhdXNlOiBkYXRhLmNhdXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIC8vIFRoZSBgY2F1c2VgIGRlZmluaXRpb24gY2FuIGJlIHJlbW92ZWQgd2hlbiB0c2NvbmZpZyBsaWIgYW5kL29yIHRhcmdldCBoYXZlIGNoYW5nZWQgdG8gPj1lczIwMjJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5jYXVzZSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jYXVzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVycm9yIGFzIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBgdGhpcy5kYXRhYCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHBsYWluIG9iamVjdCwgYnV0IHRoaXMgc2ltcGxpZmllc1xuICAgICAgLy8gdGhlIHR5cGUgZ3VhcmQgYmVsb3cuIFdlIGNhbiBzYWZlbHkgY2FzdCBpdCBiZWNhdXNlIHdlIGtub3cgaXQncyBhXG4gICAgICAvLyBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRoaXMuZGF0YSkpIHtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhLmNhdXNlID0gc2VyaWFsaXplQ2F1c2UodGhpcy5kYXRhLmNhdXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgIHNlcmlhbGl6ZWQuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IsIG9taXR0aW5nIGFueSBjaXJjdWxhclxuICAgKiByZWZlcmVuY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvci5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgfVxufVxuXG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBFdGhlcmV1bSBQcm92aWRlciBlcnJvcnMgcGVyIEVJUC0xMTkzLlxuICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIDEwMDAgPD0gNDk5OSBdIHJhbmdlLlxuICovXG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgZXh0ZW5kcyBKc29uUnBjRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gY29kZSAtIFRoZSBKU09OLVJQQyBlcnJvciBjb2RlLiBNdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlXG4gICAqIGAxMDAwIDw9IG4gPD0gNDk5OWAgcmFuZ2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIEpTT04tUlBDIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSBkYXRhIC0gT3B0aW9uYWwgZGF0YSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICBpZiAoIWlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcbiAgICB9XG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gZXJyb3IgbWVzc2FnZSBhbmQgb3B0aW9uYWwgZGF0YSBmcm9tIGFuIG9wdGlvbnMgYmFnLlxuICpcbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgZXJyb3IgbWVzc2FnZSBhbmQgb3B0aW9uYWwgZGF0YS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VPcHRzKGFyZykge1xuICBpZiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBkYXRhXG4gICAgICB9ID0gYXJnO1xuICAgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogdW5kZWZpbmVkLCBkYXRhXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIEdldCBhIGdlbmVyaWMgSlNPTi1SUEMgZXJyb3IgY2xhc3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IoY29kZSwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgZXJyb3IgY2xhc3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RXRoUHJvdmlkZXJFcnJvcihjb2RlLCBhcmcpIHtcbiAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5jb25zdCBycGNFcnJvcnMgPSB7XG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgcGFyc2U6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucGFyc2UsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBSZXF1ZXN0ICgtMzI2MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRSZXF1ZXN0OiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRSZXF1ZXN0LCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUGFyYW1zICgtMzI2MDIpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRQYXJhbXM6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBNZXRob2QgTm90IEZvdW5kICgtMzI2MDEpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIG1ldGhvZE5vdEZvdW5kOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludGVybmFsOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFNlcnZlciBlcnJvci5cbiAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cbiAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBUaGUgZXJyb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHNlcnZlcjogb3B0cyA9PiB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyZXVtIFJQQyBTZXJ2ZXIgZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29kZVxuICAgIH0gPSBvcHRzO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSB8fCBjb2RlID4gLTMyMDA1IHx8IGNvZGUgPCAtMzIwOTkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgfVxuICAgIHJldHVybiBnZXRKc29uUnBjRXJyb3IoY29kZSwgb3B0cyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgSW52YWxpZCBJbnB1dCAoLTMyMDAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBpbnZhbGlkSW5wdXQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIE5vdCBGb3VuZCAoLTMyMDAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICByZXNvdXJjZU5vdEZvdW5kOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgVW5hdmFpbGFibGUgKC0zMjAwMikgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgcmVzb3VyY2VVbmF2YWlsYWJsZTogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5yZXNvdXJjZVVuYXZhaWxhYmxlLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFRyYW5zYWN0aW9uIFJlamVjdGVkICgtMzIwMDMpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMudHJhbnNhY3Rpb25SZWplY3RlZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBNZXRob2QgTm90IFN1cHBvcnRlZCAoLTMyMDA0KSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBtZXRob2ROb3RTdXBwb3J0ZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90U3VwcG9ydGVkLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIExpbWl0IEV4Y2VlZGVkICgtMzIwMDUpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGxpbWl0RXhjZWVkZWQ6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKVxufTtcbmNvbnN0IHByb3ZpZGVyRXJyb3JzID0ge1xuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVzZXIgUmVqZWN0ZWQgUmVxdWVzdCAoNDAwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdXNlclJlamVjdGVkUmVxdWVzdDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5hdXRob3JpemVkICg0MTAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1bmF1dGhvcml6ZWQ6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5zdXBwb3J0ZWQgTWV0aG9kICg0MjAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1bnN1cHBvcnRlZE1ldGhvZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIE5vdCBDb25uZWN0ZWQgKDQ5MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIGRpc2Nvbm5lY3RlZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBjaGFpbkRpc2Nvbm5lY3RlZDogYXJnID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgY3VzdG9tOiBvcHRzID0+IHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YVxuICAgIH0gPSBvcHRzO1xuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBzYWZlQXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncykge1xuICB0cnkge1xuICAgIFJlZmxlY3QuYXBwbHkoaGFuZGxlciwgY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVycnVwdCB0aGUgc3RhY2tcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIpIHtcbiAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cbmNsYXNzIFNhZmVFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBlbWl0KHR5cGUpIHtcbiAgICBsZXQgZG9FcnJvciA9IHR5cGUgPT09IFwiZXJyb3JcIjtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb0Vycm9yID0gZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKCFkb0Vycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgbGV0IGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBbZXJdID0gYXJncztcbiAgICAgIH1cbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVycm9yLiR7ZXIgPyBgICgke2VyLm1lc3NhZ2V9KWAgOiBcIlwifWApO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzYWZlQXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2FmZUFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmNsYXNzIFNlcmlhbGl6YWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YVxuICAgIH0gPSBfcmVmO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29kZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWVzc2FnZSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICBsZXQgdW53cmFwUmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICByZXR1cm4gKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgIGlmIChlcnJvciB8fCByZXNwb25zZS5lcnJvcikge1xuICAgICAgcmVqZWN0KGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKTtcbiAgICB9IGVsc2UgaWYgKCF1bndyYXBSZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yTWlkZGxld2FyZShsb2cpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGpzb24tcnBjLWVuZ2luZSB3aWxsIHRlcm1pbmF0ZSB0aGUgcmVxdWVzdCB3aGVuIGl0IG5vdGljZXMgdGhpcyBlcnJvclxuICAgICAgaWYgKHR5cGVvZiByZXEubWV0aG9kICE9PSBcInN0cmluZ1wiIHx8ICFyZXEubWV0aG9kKSB7XG4gICAgICAgIHJlcy5lcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiaW52YWxpZCBtZXRob2RcIlxuICAgICAgICB9KTtcbiAgICAgICAgZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9ID0gcmVzO1xuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuZXJyb3IoYE9wZW5Mb2dpbiAtIFJQQyBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoYE9wZW5Mb2dpbiAtIFJQQyBFcnJvciB0aHJvd246ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICByZXMuZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpIHtcbiAgY29uc3QgaWRNYXAgPSB7fTtcbiAgZnVuY3Rpb24gcmVhZE5vb3AoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XG4gIGZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShyZXMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gaWRNYXBbcmVzLmlkXTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyZWFtTWlkZGxld2FyZSAtIFVua25vd24gcmVzcG9uc2UgaWQgXCIke3Jlcy5pZH1cImApO1xuICAgIH1cbiAgICBkZWxldGUgaWRNYXBbcmVzLmlkXTtcbiAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlc1xuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5yZXMsIHJlcyk7XG4gICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLFxuICAgIC8vIHByZXZlbnQgaW50ZXJuYWwgc3RyZWFtLWhhbmRsZXIgZnJvbSBjYXRjaGluZyBlcnJvcnNcbiAgICBzZXRUaW1lb3V0KGNvbnRleHQuZW5kKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcykge1xuICAgIGV2ZW50cy5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHJlcyk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UocmVzLCBfZW5jb2RpbmcsIGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaXNOb3RpZmljYXRpb24gPSAhcmVzLmlkO1xuICAgICAgaWYgKGlzTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHByb2Nlc3NOb3RpZmljYXRpb24ocmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NSZXNwb25zZShyZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIGVyciA9IF9lcnI7XG4gICAgfVxuICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtXG4gICAgY2IoZXJyKTtcbiAgfVxuICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHJlYWQ6IHJlYWROb29wLFxuICAgIHdyaXRlOiBwcm9jZXNzTWVzc2FnZVxuICB9KTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbVxuICAgIHN0cmVhbS5wdXNoKHJlcSk7XG4gICAgLy8gcmVnaXN0ZXIgcmVxdWVzdCBvbiBpZCBtYXBcbiAgICBpZE1hcFtyZXEuaWRdID0ge1xuICAgICAgcmVxLFxuICAgICAgcmVzLFxuICAgICAgbmV4dCxcbiAgICAgIGVuZFxuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgZXZlbnRzLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RyZWFtXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoaGFuZGxlcnMpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3JlcS5tZXRob2RdO1xuICAgIC8vIGlmIG5vIGhhbmRsZXIsIHJldHVyblxuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgZm4sIGNhbGwgYXMgbWlkZGxld2FyZVxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcihyZXEsIHJlcywgbmV4dCwgZW5kKTtcbiAgICB9XG4gICAgLy8gaWYgaGFuZGxlciBpcyBzb21lIG90aGVyIHZhbHVlLCB1c2UgYXMgcmVzdWx0XG4gICAgcmVzLnJlc3VsdCA9IGhhbmRsZXI7XG4gICAgcmV0dXJuIGVuZCgpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF9lbmQpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbElkID0gcmVxLmlkO1xuICAgIGNvbnN0IG5ld0lkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gICAgcmVxLmlkID0gbmV3SWQ7XG4gICAgcmVzLmlkID0gbmV3SWQ7XG4gICAgbmV4dChkb25lID0+IHtcbiAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7XG4gICAgICByZXMuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyTWlkZGxld2FyZShsb2dnZXIpIHtcbiAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCwgXykgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlJFUVwiLCByZXEsIFwiUkVTXCIsIHJlcyk7XG4gICAgbmV4dCgpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jTWlkZGxld2FyZSkge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAvLyBuZXh0UHJvbWlzZSBpcyB0aGUga2V5IHRvIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGl0IGlzIHJlc29sdmVkIGJ5IHRoZSByZXR1cm4gaGFuZGxlciBwYXNzZWQgdG8gdGhlXG4gICAgLy8gXCJuZXh0XCIgZnVuY3Rpb25cbiAgICBsZXQgcmVzb2x2ZU5leHRQcm9taXNlO1xuICAgIGNvbnN0IG5leHRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlTmV4dFByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBudWxsO1xuICAgIGxldCBuZXh0V2FzQ2FsbGVkID0gZmFsc2U7XG5cbiAgICAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjb25zdW1lcidzIGFzeW5jIG1pZGRsZXdhcmUuXG4gICAgY29uc3QgYXN5bmNOZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgbmV4dFdhc0NhbGxlZCA9IHRydWU7XG5cbiAgICAgIC8vIFdlIHBhc3MgYSByZXR1cm4gaGFuZGxlciB0byBuZXh0KCkuIFdoZW4gaXQgaXMgY2FsbGVkIGJ5IHRoZSBlbmdpbmUsXG4gICAgICAvLyB0aGUgY29uc3VtZXIncyBhc3luYyBtaWRkbGV3YXJlIHdpbGwgcmVzdW1lIGV4ZWN1dGluZy5cblxuICAgICAgbmV4dChydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrID0+IHtcbiAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBjb21lcyBmcm9tIEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayA9IHJ1blJldHVybkhhbmRsZXJzQ2FsbGJhY2s7XG4gICAgICAgIHJlc29sdmVOZXh0UHJvbWlzZSgpO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBhc3luY01pZGRsZXdhcmUocmVxLCByZXMsIGFzeW5jTmV4dCk7XG4gICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICBhd2FpdCBuZXh0UHJvbWlzZTsgLy8gd2UgbXVzdCB3YWl0IHVudGlsIHRoZSByZXR1cm4gaGFuZGxlciBpcyBjYWxsZWRcbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKG51bGwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAocmV0dXJuSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBIEpTT04tUlBDIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHByb2Nlc3Nvci5cbiAqIEdpdmUgaXQgYSBzdGFjayBvZiBtaWRkbGV3YXJlLCBwYXNzIGl0IHJlcXVlc3RzLCBhbmQgZ2V0IGJhY2sgcmVzcG9uc2VzLlxuICovXG5jbGFzcyBKUlBDRW5naW5lIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21pZGRsZXdhcmVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9taWRkbGV3YXJlID0gW107XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsbHkgZXhlY3V0ZXMgdGhlIGdpdmVuIHN0YWNrIG9mIG1pZGRsZXdhcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2FzIGNvbXBsZXRlZCwgYW5kIGFuIGFycmF5IG9mXG4gICAqIG1pZGRsZXdhcmUtZGVmaW5lZCByZXR1cm4gaGFuZGxlcnMuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmVTdGFjaykge1xuICAgIGNvbnN0IHJldHVybkhhbmRsZXJzID0gW107XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLy8gR28gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIHJldHVybkhhbmRsZXJzXG4gICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG1pZGRsZXdhcmVTdGFjaykge1xuICAgICAgW2Vycm9yLCBpc0NvbXBsZXRlXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKTtcbiAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVycy5yZXZlcnNlKCldO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbnkgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIG1pZGRsZXdhcmUgZXhlY3V0aW9uLFxuICAgKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxuICAgKi9cbiAgc3RhdGljIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGVuZCA9IGVyciA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZXJyIHx8IHJlcy5lcnJvcjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhlcnJvcikuaW5jbHVkZXMoXCJzdGFja1wiKSA9PT0gZmFsc2UpIGVycm9yLnN0YWNrID0gXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiO1xuICAgICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgICBzaG91bGRJbmNsdWRlU3RhY2s6IHRydWUsXG4gICAgICAgICAgICBmYWxsYmFja0Vycm9yOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgY29kZTogKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSB8fCAtMzI2MDMsXG4gICAgICAgICAgICAgIHN0YWNrOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnN0YWNrKSB8fCBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAgICAgICAgIGRhdGE6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuZGF0YSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKSB8fCAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBzaG91bGQgZW5kXG4gICAgICAgIHJlc29sdmUoW2Vycm9yLCB0cnVlXSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgbmV4dCA9IHJldHVybkhhbmRsZXIgPT4ge1xuICAgICAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICAgICAgZW5kKHJlcy5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJldHVybkhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0dXJuSGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGVuZChuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkpSUENFbmdpbmU6ICduZXh0JyByZXR1cm4gaGFuZGxlcnMgbXVzdCBiZSBmdW5jdGlvbnNcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5IYW5kbGVycy5wdXNoKHJldHVybkhhbmRsZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZhbHNlIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHNob3VsZCBub3QgZW5kXG4gICAgICAgICAgcmVzb2x2ZShbbnVsbCwgZmFsc2VdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGx5IGV4ZWN1dGVzIGFycmF5IG9mIHJldHVybiBoYW5kbGVycy4gVGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGFyZVxuICAgKiBhc3N1bWVkIHRvIGJlIGluIHRoZWlyIHNjb3BlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIF9ydW5SZXR1cm5IYW5kbGVycyhoYW5kbGVycykge1xuICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBoYW5kbGVyKGVyciA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IsIG9yIGlmXG4gICAqIHRoZSBcImlzQ29tcGxldGVcIiBmbGFnIGlzIGZhbHN5LlxuICAgKi9cbiAgc3RhdGljIF9jaGVja0ZvckNvbXBsZXRpb24oX3JlcSwgcmVzLCBpc0NvbXBsZXRlKSB7XG4gICAgaWYgKCEoXCJyZXN1bHRcIiBpbiByZXMpICYmICEoXCJlcnJvclwiIGluIHJlcykpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBoYXMgbm8gZXJyb3Igb3IgcmVzdWx0IGZvciByZXF1ZXN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJOb3RoaW5nIGVuZGVkIHJlcXVlc3RcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gdGhlIGVuZ2luZSdzIG1pZGRsZXdhcmUgc3RhY2suXG4gICAqXG4gICAqIEBwYXJhbSBtaWRkbGV3YXJlIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gYWRkLlxuICAgKi9cbiAgcHVzaChtaWRkbGV3YXJlKSB7XG4gICAgdGhpcy5fbWlkZGxld2FyZS5wdXNoKG1pZGRsZXdhcmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEpTT04tUlBDIHJlcXVlc3QsIGFuZCByZXR1cm4gYSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIHRoZSByZXNwb25zZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbiBhcnJheSBvZiBKU09OLVJQQyByZXF1ZXN0cywgYW5kIHJldHVybiBhbiBhcnJheSBvZiByZXNwb25zZXMuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3RzIHRvIGhhbmRsZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQW4gZXJyb3ItZmlyc3QgY2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGFycmF5IG9mXG4gICAqIHJlc3BvbnNlcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEpTT04tUlBDIHJlcXVlc3QsIGFuZCByZXR1cm4gYSByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0byBoYW5kbGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlLCBvciByZWplY3RzIHdpdGggYW5cbiAgICogZXJyb3IuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYXJyYXkgb2YgSlNPTi1SUEMgcmVxdWVzdHMsIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgcmVzcG9uc2VzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0cyB0byBoYW5kbGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGFycmF5IG9mIHJlc3BvbnNlcywgb3IgcmVqZWN0c1xuICAgKiB3aXRoIGFuIGVycm9yLlxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBoYW5kbGUocmVxLCBjYikge1xuICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhbGxiYWNrXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSwgY2IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJhdGNoKHJlcSk7XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZShyZXEsIGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VIYW5kbGUocmVxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwdXNoZWQgdG8gb3RoZXJcbiAgICogZW5naW5lcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXNNaWRkbGV3YXJlKCkge1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW21pZGRsZXdhcmVFcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnNdID0gYXdhaXQgSlJQQ0VuZ2luZS5fcnVuQWxsTWlkZGxld2FyZShyZXEsIHJlcywgdGhpcy5fbWlkZGxld2FyZSk7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgIHJldHVybiBlbmQobWlkZGxld2FyZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dChhc3luYyBoYW5kbGVyQ2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIF9oYW5kbGUsIGJ1dCBmb3IgYmF0Y2ggcmVxdWVzdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBMaWtlIF9oYW5kbGUsIGJ1dCBmb3IgYmF0Y2ggcmVxdWVzdHMuXG4gICAqL1xuXG4gIGFzeW5jIF9oYW5kbGVCYXRjaChyZXFzLCBjYikge1xuICAgIC8vIFRoZSBvcmRlciBoZXJlIGlzIGltcG9ydGFudFxuICAgIHRyeSB7XG4gICAgICAvLyAyLiBXYWl0IGZvciBhbGwgcmVxdWVzdHMgdG8gZmluaXNoLCBvciB0aHJvdyBvbiBzb21lIGtpbmQgb2YgZmF0YWxcbiAgICAgIC8vIGVycm9yXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIC8vIDEuIEJlZ2luIGV4ZWN1dGluZyBlYWNoIHJlcXVlc3QgaW4gdGhlIG9yZGVyIHJlY2VpdmVkXG4gICAgICByZXFzLm1hcCh0aGlzLl9wcm9taXNlSGFuZGxlLmJpbmQodGhpcykpKTtcblxuICAgICAgLy8gMy4gUmV0dXJuIGJhdGNoIHJlc3BvbnNlXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3BvbnNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2VzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHByb21pc2Utd3JhcHBlZCBfaGFuZGxlLlxuICAgKi9cbiAgX3Byb21pc2VIYW5kbGUocmVxKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZShyZXEsIChfZXJyLCByZXMpID0+IHtcbiAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYSByZXNwb25zZSwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhdmUgYW55IGVycm9yXG4gICAgICAgIC8vIHRoYXQgaXMgY2F1Z2h0IGFuZCBwcm9wYWdhdGVkLlxuICAgICAgICBpZiAoX2VyciAmJiByZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlamVjdChfZXJyKTtcbiAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0IG9iamVjdCBpcyB2YWxpZCwgcHJvY2Vzc2VzIGl0LCBhbmQgcGFzc2VzIGFueVxuICAgKiBlcnJvciBhbmQgdGhlIHJlc3BvbnNlIG9iamVjdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIERvZXMgbm90IHJlamVjdC5cbiAgICovXG4gIGFzeW5jIF9oYW5kbGUoY2FsbGVyUmVxLCBjYikge1xuICAgIGlmICghY2FsbGVyUmVxIHx8IEFycmF5LmlzQXJyYXkoY2FsbGVyUmVxKSB8fCB0eXBlb2YgY2FsbGVyUmVxICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJyZXF1ZXN0IG11c3QgYmUgcGxhaW4gb2JqZWN0XCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsZXJSZXEubWV0aG9kICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBTZXJpYWxpemFibGVFcnJvcih7XG4gICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgbWVzc2FnZTogXCJtZXRob2QgbXVzdCBiZSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2IoZXJyb3IsIHtcbiAgICAgICAgaWQ6IGNhbGxlclJlcS5pZCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkKHt9LCBjYWxsZXJSZXEpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGlkOiByZXEuaWQsXG4gICAgICBqc29ucnBjOiByZXEuanNvbnJwY1xuICAgIH07XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgLy8gQSByZXF1ZXN0IGhhbmRsZXIgZXJyb3IsIGEgcmUtdGhyb3duIG1pZGRsZXdhcmUgZXJyb3IsIG9yIHNvbWV0aGluZ1xuICAgICAgLy8gdW5leHBlY3RlZC5cbiAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIC8vIEVuc3VyZSBubyByZXN1bHQgaXMgcHJlc2VudCBvbiBhbiBlcnJvcmVkIHJlc3BvbnNlXG4gICAgICBkZWxldGUgcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzLmVycm9yKSB7XG4gICAgICAgIHZhciBfZXJyb3IyLCBfZXJyb3IzLCBfZXJyb3I0LCBfZXJyb3I1LCBfZXJyb3I2LCBfZXJyb3I3LCBfZXJyb3I4O1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGVycm9yKS5pbmNsdWRlcyhcInN0YWNrXCIpID09PSBmYWxzZSkgZXJyb3Iuc3RhY2sgPSBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCI7XG4gICAgICAgIHJlcy5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7XG4gICAgICAgICAgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrRXJyb3I6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICgoX2Vycm9yMiA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IyLm1lc3NhZ2UpIHx8ICgoX2Vycm9yMyA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3IzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3IzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgY29kZTogKChfZXJyb3I0ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjQuY29kZSkgfHwgLTMyNjAzLFxuICAgICAgICAgICAgc3RhY2s6ICgoX2Vycm9yNSA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I1LnN0YWNrKSB8fCBcIlN0YWNrIHRyYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAgICAgICBkYXRhOiAoKF9lcnJvcjYgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNi5kYXRhKSB8fCAoKF9lcnJvcjcgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNy5tZXNzYWdlKSB8fCAoKF9lcnJvcjggPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yOCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yOC50b1N0cmluZygpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYihlcnJvciwgcmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIHJlcXVlc3QgYW5kIHJlc3BvbnNlLCBydW5zIGFsbCBtaWRkbGV3YXJlIGFuZCB0aGVpciByZXR1cm5cbiAgICogaGFuZGxlcnMsIGlmIGFueSwgYW5kIGVuc3VyZXMgdGhhdCBpbnRlcm5hbCByZXF1ZXN0IHByb2Nlc3Npbmcgc2VtYW50aWNzXG4gICAqIGFyZSBzYXRpc2ZpZWQuXG4gICAqL1xuICBhc3luYyBfcHJvY2Vzc1JlcXVlc3QocmVxLCByZXMpIHtcbiAgICBjb25zdCBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuXG4gICAgLy8gVGhyb3cgaWYgXCJlbmRcIiB3YXMgbm90IGNhbGxlZCwgb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0XG4gICAgLy8gbm9yIGFuIGVycm9yLlxuICAgIEpSUENFbmdpbmUuX2NoZWNrRm9yQ29tcGxldGlvbihyZXEsIHJlcywgaXNDb21wbGV0ZSk7XG5cbiAgICAvLyBUaGUgcmV0dXJuIGhhbmRsZXJzIHNob3VsZCBydW4gZXZlbiBpZiBhbiBlcnJvciB3YXMgZW5jb3VudGVyZWQgZHVyaW5nXG4gICAgLy8gbWlkZGxld2FyZSBwcm9jZXNzaW5nLlxuICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcblxuICAgIC8vIE5vdyB3ZSByZS10aHJvdyB0aGUgbWlkZGxld2FyZSBwcm9jZXNzaW5nIGVycm9yLCBpZiBhbnksIHRvIGNhdGNoIGl0XG4gICAgLy8gZnVydGhlciB1cCB0aGUgY2FsbCBjaGFpbi5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VNaWRkbGV3YXJlKG1pZGRsZXdhcmVTdGFjaykge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICBtaWRkbGV3YXJlU3RhY2suZm9yRWFjaChtaWRkbGV3YXJlID0+IGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpKTtcbiAgcmV0dXJuIGVuZ2luZS5hc01pZGRsZXdhcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuZ2luZVN0cmVhbShvcHRzKSB7XG4gIGlmICghb3B0cyB8fCAhb3B0cy5lbmdpbmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVuZ2luZSBwYXJhbWV0ZXIhXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbmdpbmVcbiAgfSA9IG9wdHM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHN0cmVhbTtcbiAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlKHJlcSwgX2VuY29kaW5nLCBjYikge1xuICAgIGVuZ2luZS5oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICBzdHJlYW0ucHVzaChyZXMpO1xuICAgIH0pO1xuICAgIGNiKCk7XG4gIH1cbiAgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkLFxuICAgIHdyaXRlXG4gIH0pO1xuXG4gIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICBpZiAoZW5naW5lLm9uKSB7XG4gICAgZW5naW5lLm9uKFwibm90aWZpY2F0aW9uXCIsIG1lc3NhZ2UgPT4ge1xuICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpIHtcbiAgY29uc3QgcHJvdmlkZXIgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpO1xuICAvLyBoYW5kbGUgYm90aCBycGMgc2VuZCBtZXRob2RzXG4gIHByb3ZpZGVyLnNlbmRBc3luYyA9IGFzeW5jIHJlcSA9PiB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZW5naW5lLmhhbmRsZShyZXEpO1xuICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgIHZhciBfcmVzJGVycm9yLCBfcmVzJGVycm9yMiwgX3JlcyRlcnJvcjMsIF9yZXMkZXJyb3I0LCBfcmVzJGVycm9yNSwgX3JlcyRlcnJvcjYsIF9yZXMkZXJyb3I3O1xuICAgICAgaWYgKHR5cGVvZiByZXMuZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMocmVzLmVycm9yKS5pbmNsdWRlcyhcInN0YWNrXCIpID09PSBmYWxzZSkgcmVzLmVycm9yLnN0YWNrID0gXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiO1xuICAgICAgY29uc3QgZXJyID0gc2VyaWFsaXplRXJyb3IocmVzLmVycm9yLCB7XG4gICAgICAgIGZhbGxiYWNrRXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiAoKF9yZXMkZXJyb3IgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3IubWVzc2FnZSkgfHwgKChfcmVzJGVycm9yMiA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3IyLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGNvZGU6ICgoX3JlcyRlcnJvcjMgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3IzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yMy5jb2RlKSB8fCAtMzI2MDMsXG4gICAgICAgICAgc3RhY2s6ICgoX3JlcyRlcnJvcjQgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNC5zdGFjaykgfHwgXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiLFxuICAgICAgICAgIGRhdGE6ICgoX3JlcyRlcnJvcjUgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNS5kYXRhKSB8fCAoKF9yZXMkZXJyb3I2ID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjYubWVzc2FnZSkgfHwgKChfcmVzJGVycm9yNyA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3I3LnRvU3RyaW5nKCkpXG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZEluY2x1ZGVTdGFjazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH07XG4gIHByb3ZpZGVyLnNlbmQgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgY2FsbGJhY2sgdG8gXCJzZW5kXCIgbWV0aG9kLicpO1xuICAgIH1cbiAgICBlbmdpbmUuaGFuZGxlKHJlcSwgY2FsbGJhY2spO1xuICB9O1xuICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgaWYgKGVuZ2luZS5vbikge1xuICAgIGVuZ2luZS5vbihcIm5vdGlmaWNhdGlvblwiLCBtZXNzYWdlID0+IHtcbiAgICAgIHByb3ZpZGVyLmVtaXQoXCJkYXRhXCIsIG51bGwsIG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIHByb3ZpZGVyLnJlcXVlc3QgPSBhc3luYyBhcmdzID0+IHtcbiAgICBjb25zdCByZXEgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFyZ3MpLCB7fSwge1xuICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHByb3ZpZGVyLnNlbmRBc3luYyhyZXEpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICBlbmdpbmUucHVzaChtaWRkbGV3YXJlKTtcbiAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJBc01pZGRsZXdhcmUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgIC8vIHNlbmQgcmVxdWVzdCB0byBwcm92aWRlclxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlclJlcyA9IGF3YWl0IHByb3ZpZGVyLnNlbmRBc3luYyhyZXEpO1xuICAgICAgcmVzLnJlc3VsdCA9IHByb3ZpZGVyUmVzO1xuICAgICAgcmV0dXJuIGVuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZW5kKGVycm9yKTtcbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIFN1YnN0cmVhbSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgcGFyZW50LFxuICAgICAgbmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX25hbWVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGljaXRseSBzZXRzIHJlYWQgb3BlcmF0aW9ucyB0byBhIG5vLW9wLlxuICAgKi9cbiAgX3JlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBkYXRhIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoaXMgd3JpdGFibGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0gY2h1bmsgLSBBcmJpdHJhcnkgb2JqZWN0IHRvIHdyaXRlXG4gICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIHRvIHVzZSB3aGVuIHdyaXRpbmcgcGF5bG9hZFxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsZWQgd2hlbiB3cml0aW5nIGlzIGNvbXBsZXRlIG9yIGFuIGVycm9yIG9jY3Vyc1xuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcGFyZW50LnB1c2goe1xuICAgICAgbmFtZTogdGhpcy5fbmFtZSxcbiAgICAgIGRhdGE6IGNodW5rXG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5jb25zdCBJR05PUkVfU1VCU1RSRUFNID0gU3ltYm9sKFwiSUdOT1JFX1NVQlNUUkVBTVwiKTtcbmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdHMpLCB7fSwge1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3Vic3RyZWFtc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0cmVhbVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcbiAgfVxuICBjcmVhdGVTdHJlYW0obmFtZSkge1xuICAgIC8vIHZhbGlkYXRlIG5hbWVcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW1cbiAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtO1xuXG4gICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBhbnlTdHJlYW1FbmQodGhpcywgX2Vycm9yID0+IHN1YnN0cmVhbS5kZXN0cm95KF9lcnJvciB8fCB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gc3Vic3RyZWFtO1xuICB9XG5cbiAgLy8gaWdub3JlIHN0cmVhbXMgKGRvbnQgZGlzcGxheSBvcnBoYW5lZCBkYXRhIHdhcm5pbmcpXG4gIGlnbm9yZVN0cmVhbShuYW1lKSB7XG4gICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuICAgIC8vIHNldFxuICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNO1xuICB9XG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gY2h1bms7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBtYWxmb3JtZWQgY2h1bmsgd2l0aG91dCBuYW1lIFwiJHtjaHVua31cImApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gdGhpcy5fc3Vic3RyZWFtc1tuYW1lXTtcbiAgICBpZiAoIXN1YnN0cmVhbSkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtIFwiJHtuYW1lfVwiYCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBwdXNoIGRhdGEgaW50byBzdWJzdHJlYW1cbiAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7XG4gICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLy8gdXRpbFxuZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7XG4gIGNvbnN0IGNiID0gb25jZShfY2IpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IGZhbHNlXG4gIH0sIGNiKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LCBjYik7XG59XG5mdW5jdGlvbiBzZXR1cE11bHRpcGxleChzdHJlYW0pIHtcbiAgY29uc3QgbXV4ID0gbmV3IE9iamVjdE11bHRpcGxleCgpO1xuICBtdXguZ2V0U3RyZWFtID0gZnVuY3Rpb24gc3RyZWFtSGVscGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0cmVhbShuYW1lKTtcbiAgfTtcbiAgcHVtcChzdHJlYW0sIG11eCwgc3RyZWFtLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHdpbmRvdy5jb25zb2xlLmVycm9yKGVycik7XG4gIH0pO1xuICByZXR1cm4gbXV4O1xufVxuXG5jbGFzcyBQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSB7XG4gIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgbGV0IG9yaWdpbkNvbnN0cmFpbnQgPSB0aGlzLl90YXJnZXRPcmlnaW47XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBkYXRhT2JqID0gZGF0YTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YU9iai5kYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGRhdGFPYmpEYXRhID0gZGF0YU9iai5kYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhT2JqRGF0YS5wYXJhbXMpICYmIGRhdGFPYmpEYXRhLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZGF0YU9iakRhdGFQYXJhbSA9IGRhdGFPYmpEYXRhLnBhcmFtc1swXTtcbiAgICAgICAgICBpZiAoZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luKSB7XG4gICAgICAgICAgICBvcmlnaW5Db25zdHJhaW50ID0gZGF0YU9iakRhdGFQYXJhbS5fb3JpZ2luO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFkZCBhIGNvbnN0cmFpbnQgZm9yIHRoZSByZXNwb25zZVxuICAgICAgICAgIGRhdGFPYmpEYXRhUGFyYW0uX29yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgZGF0YVxuICAgIH0sIG9yaWdpbkNvbnN0cmFpbnQpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSwgRXRoZXJldW1Qcm92aWRlckVycm9yLCBJR05PUkVfU1VCU1RSRUFNLCBKUlBDRW5naW5lLCBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSwgSnNvblJwY0Vycm9yLCBPYmplY3RNdWx0aXBsZXgsIFBvc3RNZXNzYWdlU3RyZWFtLCBTYWZlRXZlbnRFbWl0dGVyLCBTZXJpYWxpemFibGVFcnJvciwgU3Vic3RyZWFtLCBjcmVhdGVBc3luY01pZGRsZXdhcmUsIGNyZWF0ZUVuZ2luZVN0cmVhbSwgY3JlYXRlRXJyb3JNaWRkbGV3YXJlLCBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSwgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSwgY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlLCBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlLCBkYXRhSGFzQ2F1c2UsIGVycm9yQ29kZXMsIGVycm9yVmFsdWVzLCBnZXRNZXNzYWdlRnJvbUNvZGUsIGdldFJwY1Byb21pc2VDYWxsYmFjaywgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsIGlzVmFsaWRDb2RlLCBpc1ZhbGlkU3RyaW5nLCBtZXJnZU1pZGRsZXdhcmUsIHByb3ZpZGVyQXNNaWRkbGV3YXJlLCBwcm92aWRlckVycm9ycywgcHJvdmlkZXJGcm9tRW5naW5lLCBwcm92aWRlckZyb21NaWRkbGV3YXJlLCBycGNFcnJvcnMsIHNlcmlhbGl6ZUNhdXNlLCBzZXJpYWxpemVFcnJvciwgc2V0dXBNdWx0aXBsZXggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-session-manager/dist/openloginSessionManager.esm.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-session-manager/dist/openloginSessionManager.esm.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenloginSessionManager: () => (/* binding */ OpenloginSessionManager)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toruslabs_base_session_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/base-session-manager */ \"(ssr)/./node_modules/@toruslabs/base-session-manager/dist/baseSessionManager.esm.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n\n\n\n\n\nconst DEFAULT_SESSION_TIMEOUT = 86400;\nclass OpenloginSessionManager extends _toruslabs_base_session_manager__WEBPACK_IMPORTED_MODULE_1__.BaseSessionManager {\n  constructor() {\n    let {\n      sessionServerBaseUrl,\n      sessionNamespace,\n      sessionTime,\n      sessionId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionServerBaseUrl\", \"https://session.web3auth.io\");\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionNamespace\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionTime\", DEFAULT_SESSION_TIMEOUT);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionId\", \"\");\n    if (sessionServerBaseUrl) {\n      this.sessionServerBaseUrl = sessionServerBaseUrl;\n    }\n    if (sessionNamespace) this.sessionNamespace = sessionNamespace;\n    if (sessionTime) this.sessionTime = sessionTime;\n    if (sessionId) this.sessionId = sessionId.padStart(64, \"0\");\n  }\n  static generateRandomSessionKey() {\n    return (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.generatePrivate)().toString(\"hex\").padStart(64, \"0\");\n  }\n  async createSession(data) {\n    super.checkSessionParams();\n    const privKey = Buffer.from(this.sessionId, \"hex\");\n    const pubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(privKey).toString(\"hex\");\n    const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(this.sessionId, data);\n    const signature = (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(privKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const body = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: this.sessionTime\n    };\n    await super.request({\n      method: \"POST\",\n      url: `${this.sessionServerBaseUrl}/store/set`,\n      data: body\n    });\n    return this.sessionId;\n  }\n  async authorizeSession() {\n    super.checkSessionParams();\n    const pubkey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(Buffer.from(this.sessionId, \"hex\")).toString(\"hex\");\n    const url = new URL(`${this.sessionServerBaseUrl}/store/get`);\n    url.searchParams.append(\"key\", pubkey);\n    if (this.sessionNamespace) url.searchParams.append(\"namespace\", this.sessionNamespace);\n    const result = await super.request({\n      url: url.toString()\n    });\n    if (!result.message) {\n      throw new Error(\"Session Expired or Invalid public key\");\n    }\n    const response = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.decryptData)(this.sessionId, result.message);\n    if (response.error) {\n      throw new Error(\"There was an error decrypting data.\");\n    }\n    return response;\n  }\n  async updateSession(data) {\n    super.checkSessionParams();\n    const privKey = Buffer.from(this.sessionId, \"hex\");\n    const pubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(privKey).toString(\"hex\");\n    const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(this.sessionId, data);\n    const signature = (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(privKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const body = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace\n    };\n    await super.request({\n      method: \"PUT\",\n      url: `${this.sessionServerBaseUrl}/store/update`,\n      data: body\n    });\n  }\n  async invalidateSession() {\n    super.checkSessionParams();\n    const privKey = Buffer.from(this.sessionId, \"hex\");\n    const pubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(privKey).toString(\"hex\");\n    const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(this.sessionId, {});\n    const signature = (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(privKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\");\n    const data = {\n      key: pubKey,\n      data: encData,\n      signature,\n      namespace: this.sessionNamespace,\n      timeout: 1\n    };\n    await super.request({\n      method: \"POST\",\n      url: `${this.sessionServerBaseUrl}/store/set`,\n      data\n    });\n    this.sessionId = \"\";\n    return true;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL2Rpc3Qvb3BlbmxvZ2luU2Vzc2lvbk1hbmFnZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvRTtBQUNDO0FBQ0U7QUFDVzs7QUFFbEY7QUFDQSxzQ0FBc0MsK0VBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0VBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVM7QUFDNUIsMEJBQTBCLHdFQUFXO0FBQ3JDLDZCQUE2Qix5REFBSSxVQUFVLHNFQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFTO0FBQzVCLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdFQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQVM7QUFDNUIsMEJBQTBCLHdFQUFXO0FBQ3JDLDZCQUE2Qix5REFBSSxVQUFVLHNFQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBUztBQUM1QiwwQkFBMEIsd0VBQVcsbUJBQW1CO0FBQ3hELDZCQUE2Qix5REFBSSxVQUFVLHNFQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL2Rpc3Qvb3BlbmxvZ2luU2Vzc2lvbk1hbmFnZXIuZXNtLmpzPzExM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IEJhc2VTZXNzaW9uTWFuYWdlciB9IGZyb20gJ0B0b3J1c2xhYnMvYmFzZS1zZXNzaW9uLW1hbmFnZXInO1xuaW1wb3J0IHsgZ2VuZXJhdGVQcml2YXRlLCBnZXRQdWJsaWMsIHNpZ24gfSBmcm9tICdAdG9ydXNsYWJzL2VjY3J5cHRvJztcbmltcG9ydCB7IGVuY3J5cHREYXRhLCBrZWNjYWsyNTYsIGRlY3J5cHREYXRhIH0gZnJvbSAnQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzJztcblxuY29uc3QgREVGQVVMVF9TRVNTSU9OX1RJTUVPVVQgPSA4NjQwMDtcbmNsYXNzIE9wZW5sb2dpblNlc3Npb25NYW5hZ2VyIGV4dGVuZHMgQmFzZVNlc3Npb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHtcbiAgICAgIHNlc3Npb25TZXJ2ZXJCYXNlVXJsLFxuICAgICAgc2Vzc2lvbk5hbWVzcGFjZSxcbiAgICAgIHNlc3Npb25UaW1lLFxuICAgICAgc2Vzc2lvbklkXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXNzaW9uU2VydmVyQmFzZVVybFwiLCBcImh0dHBzOi8vc2Vzc2lvbi53ZWIzYXV0aC5pb1wiKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXNzaW9uTmFtZXNwYWNlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2Vzc2lvblRpbWVcIiwgREVGQVVMVF9TRVNTSU9OX1RJTUVPVVQpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlc3Npb25JZFwiLCBcIlwiKTtcbiAgICBpZiAoc2Vzc2lvblNlcnZlckJhc2VVcmwpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblNlcnZlckJhc2VVcmwgPSBzZXNzaW9uU2VydmVyQmFzZVVybDtcbiAgICB9XG4gICAgaWYgKHNlc3Npb25OYW1lc3BhY2UpIHRoaXMuc2Vzc2lvbk5hbWVzcGFjZSA9IHNlc3Npb25OYW1lc3BhY2U7XG4gICAgaWYgKHNlc3Npb25UaW1lKSB0aGlzLnNlc3Npb25UaW1lID0gc2Vzc2lvblRpbWU7XG4gICAgaWYgKHNlc3Npb25JZCkgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgfVxuICBzdGF0aWMgZ2VuZXJhdGVSYW5kb21TZXNzaW9uS2V5KCkge1xuICAgIHJldHVybiBnZW5lcmF0ZVByaXZhdGUoKS50b1N0cmluZyhcImhleFwiKS5wYWRTdGFydCg2NCwgXCIwXCIpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVNlc3Npb24oZGF0YSkge1xuICAgIHN1cGVyLmNoZWNrU2Vzc2lvblBhcmFtcygpO1xuICAgIGNvbnN0IHByaXZLZXkgPSBCdWZmZXIuZnJvbSh0aGlzLnNlc3Npb25JZCwgXCJoZXhcIik7XG4gICAgY29uc3QgcHViS2V5ID0gZ2V0UHVibGljKHByaXZLZXkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IGVuY0RhdGEgPSBhd2FpdCBlbmNyeXB0RGF0YSh0aGlzLnNlc3Npb25JZCwgZGF0YSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKGF3YWl0IHNpZ24ocHJpdktleSwga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKGVuY0RhdGEsIFwidXRmOFwiKSkpKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAga2V5OiBwdWJLZXksXG4gICAgICBkYXRhOiBlbmNEYXRhLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgbmFtZXNwYWNlOiB0aGlzLnNlc3Npb25OYW1lc3BhY2UsXG4gICAgICB0aW1lb3V0OiB0aGlzLnNlc3Npb25UaW1lXG4gICAgfTtcbiAgICBhd2FpdCBzdXBlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICB1cmw6IGAke3RoaXMuc2Vzc2lvblNlcnZlckJhc2VVcmx9L3N0b3JlL3NldGAsXG4gICAgICBkYXRhOiBib2R5XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbklkO1xuICB9XG4gIGFzeW5jIGF1dGhvcml6ZVNlc3Npb24oKSB7XG4gICAgc3VwZXIuY2hlY2tTZXNzaW9uUGFyYW1zKCk7XG4gICAgY29uc3QgcHVia2V5ID0gZ2V0UHVibGljKEJ1ZmZlci5mcm9tKHRoaXMuc2Vzc2lvbklkLCBcImhleFwiKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnNlc3Npb25TZXJ2ZXJCYXNlVXJsfS9zdG9yZS9nZXRgKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImtleVwiLCBwdWJrZXkpO1xuICAgIGlmICh0aGlzLnNlc3Npb25OYW1lc3BhY2UpIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibmFtZXNwYWNlXCIsIHRoaXMuc2Vzc2lvbk5hbWVzcGFjZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIucmVxdWVzdCh7XG4gICAgICB1cmw6IHVybC50b1N0cmluZygpXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQubWVzc2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBFeHBpcmVkIG9yIEludmFsaWQgcHVibGljIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkZWNyeXB0RGF0YSh0aGlzLnNlc3Npb25JZCwgcmVzdWx0Lm1lc3NhZ2UpO1xuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIGRlY3J5cHRpbmcgZGF0YS5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZXNzaW9uKGRhdGEpIHtcbiAgICBzdXBlci5jaGVja1Nlc3Npb25QYXJhbXMoKTtcbiAgICBjb25zdCBwcml2S2V5ID0gQnVmZmVyLmZyb20odGhpcy5zZXNzaW9uSWQsIFwiaGV4XCIpO1xuICAgIGNvbnN0IHB1YktleSA9IGdldFB1YmxpYyhwcml2S2V5KS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCBlbmNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEodGhpcy5zZXNzaW9uSWQsIGRhdGEpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IChhd2FpdCBzaWduKHByaXZLZXksIGtlY2NhazI1NihCdWZmZXIuZnJvbShlbmNEYXRhLCBcInV0ZjhcIikpKSkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIGtleTogcHViS2V5LFxuICAgICAgZGF0YTogZW5jRGF0YSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIG5hbWVzcGFjZTogdGhpcy5zZXNzaW9uTmFtZXNwYWNlXG4gICAgfTtcbiAgICBhd2FpdCBzdXBlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIHVybDogYCR7dGhpcy5zZXNzaW9uU2VydmVyQmFzZVVybH0vc3RvcmUvdXBkYXRlYCxcbiAgICAgIGRhdGE6IGJvZHlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZhbGlkYXRlU2Vzc2lvbigpIHtcbiAgICBzdXBlci5jaGVja1Nlc3Npb25QYXJhbXMoKTtcbiAgICBjb25zdCBwcml2S2V5ID0gQnVmZmVyLmZyb20odGhpcy5zZXNzaW9uSWQsIFwiaGV4XCIpO1xuICAgIGNvbnN0IHB1YktleSA9IGdldFB1YmxpYyhwcml2S2V5KS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCBlbmNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEodGhpcy5zZXNzaW9uSWQsIHt9KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoYXdhaXQgc2lnbihwcml2S2V5LCBrZWNjYWsyNTYoQnVmZmVyLmZyb20oZW5jRGF0YSwgXCJ1dGY4XCIpKSkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBrZXk6IHB1YktleSxcbiAgICAgIGRhdGE6IGVuY0RhdGEsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICBuYW1lc3BhY2U6IHRoaXMuc2Vzc2lvbk5hbWVzcGFjZSxcbiAgICAgIHRpbWVvdXQ6IDFcbiAgICB9O1xuICAgIGF3YWl0IHN1cGVyLnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHVybDogYCR7dGhpcy5zZXNzaW9uU2VydmVyQmFzZVVybH0vc3RvcmUvc2V0YCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgICB0aGlzLnNlc3Npb25JZCA9IFwiXCI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgT3BlbmxvZ2luU2Vzc2lvbk1hbmFnZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-session-manager/dist/openloginSessionManager.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n  }\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\n\n//# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2VjY3J5cHRvL2Rpc3QvZWNjcnlwdG8uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ007O0FBRXRDLGVBQWUsd0NBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQywwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLDREQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLDhEQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlJO0FBQ2pJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1zZXNzaW9uLW1hbmFnZXIvbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9lY2NyeXB0by5lc20uanM/OWZiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbm9kZUNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgZWMgYXMgZWMkMSB9IGZyb20gJ2VsbGlwdGljJztcblxuY29uc3QgZWMgPSBuZXcgZWMkMShcInNlY3AyNTZrMVwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBicm93c2VyQ3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8gfHwge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3Qgc3VidGxlID0gYnJvd3NlckNyeXB0by5zdWJ0bGUgfHwgYnJvd3NlckNyeXB0by53ZWJraXRTdWJ0bGU7XG5jb25zdCBFQ19HUk9VUF9PUkRFUiA9IEJ1ZmZlci5mcm9tKFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiLCBcImhleFwiKTtcbmNvbnN0IFpFUk8zMiA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICB9XG59XG5mdW5jdGlvbiBpc1NjYWxhcih4KSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoeCkgJiYgeC5sZW5ndGggPT09IDMyO1xufVxuZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICBpZiAoIWlzU2NhbGFyKHByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5LmNvbXBhcmUoWkVSTzMyKSA+IDAgJiZcbiAgLy8gPiAwXG4gIHByaXZhdGVLZXkuY29tcGFyZShFQ19HUk9VUF9PUkRFUikgPCAwOyAvLyA8IEdcbn1cblxuLy8gQ29tcGFyZSB0d28gYnVmZmVycyBpbiBjb25zdGFudCB0aW1lIHRvIHByZXZlbnQgdGltaW5nIGF0dGFja3MuXG5mdW5jdGlvbiBlcXVhbENvbnN0VGltZShiMSwgYjIpIHtcbiAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzIHw9IGIxW2ldIF4gYjJbaV07IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9XG5cbiAgcmV0dXJuIHJlcyA9PT0gMDtcbn1cblxuLyogVGhpcyBtdXN0IGNoZWNrIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyIG9yXG5ub3QsIHNpbmNlIHRoZSBmdW5jdGlvbnMgYXJlIGRpZmZlcmVudCBhbmQgZG9lc1xubm90IGNvbnZlcnQgdXNpbmcgYnJvd3NlcmlmeSAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoc2l6ZSkge1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgaWYgKHR5cGVvZiBicm93c2VyQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShub2RlQ3J5cHRvLnJhbmRvbUJ5dGVzKHNpemUpKTtcbiAgfVxuICBicm93c2VyQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTUxMihtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaGFzaCA9IG5vZGVDcnlwdG8uY3JlYXRlSGFzaChcInNoYTUxMlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gaGFzaC51cGRhdGUobXNnKS5kaWdlc3QoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXRBZXMob3ApIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIChpdiwga2V5LCBkYXRhKSB7XG4gICAgaWYgKHN1YnRsZSkge1xuICAgICAgY29uc3QgaW1wb3J0QWxnb3JpdGhtID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbb3BdKTtcbiAgICAgIGNvbnN0IGVuY0FsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgIGl2XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VidGxlW29wXShlbmNBbGdvcml0aG0sIGNyeXB0b0tleSwgZGF0YSk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzdWx0KSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJlbmNyeXB0XCIpIHtcbiAgICAgIGNvbnN0IGNpcGhlciA9IG5vZGVDcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgY29uc3Qgc2Vjb25kQ2h1bmsgPSBjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZGVjcnlwdFwiKSB7XG4gICAgICBjb25zdCBkZWNpcGhlciA9IG5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtY2JjXCIsIGtleSwgaXYpO1xuICAgICAgY29uc3QgZmlyc3RDaHVuayA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgIGNvbnN0IHNlY29uZENodW5rID0gZGVjaXBoZXIuZmluYWwoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdENodW5rLCBzZWNvbmRDaHVua10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbjogJHtvcH1gKTtcbiAgfTtcbn1cbmNvbnN0IGFlc0NiY0VuY3J5cHQgPSBnZXRBZXMoXCJlbmNyeXB0XCIpO1xuY29uc3QgYWVzQ2JjRGVjcnlwdCA9IGdldEFlcyhcImRlY3J5cHRcIik7XG5hc3luYyBmdW5jdGlvbiBobWFjU2hhMjU2U2lnbihrZXksIG1zZykge1xuICBpZiAoc3VidGxlKSB7XG4gICAgY29uc3QgaW1wb3J0QWxnb3JpdGhtID0ge1xuICAgICAgbmFtZTogXCJITUFDXCIsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIG5ldyBVaW50OEFycmF5KGtleSksIGltcG9ydEFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xuICAgIGNvbnN0IHNpZyA9IGF3YWl0IHN1YnRsZS5zaWduKFwiSE1BQ1wiLCBjcnlwdG9LZXksIG1zZyk7XG4gICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoc2lnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBobWFjID0gbm9kZUNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIEJ1ZmZlci5mcm9tKGtleSkpO1xuICBobWFjLnVwZGF0ZShtc2cpO1xuICBjb25zdCByZXN1bHQgPSBobWFjLmRpZ2VzdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlZlcmlmeShrZXksIG1zZywgc2lnKSB7XG4gIGNvbnN0IGV4cGVjdGVkU2lnID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpO1xuICByZXR1cm4gZXF1YWxDb25zdFRpbWUoZXhwZWN0ZWRTaWcsIHNpZyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBuZXcgdmFsaWQgcHJpdmF0ZSBrZXkuIFdpbGwgdXNlIHRoZSB3aW5kb3cuY3J5cHRvIG9yIHdpbmRvdy5tc0NyeXB0byBhcyBzb3VyY2VcbiAqIGRlcGVuZGluZyBvbiB5b3VyIGJyb3dzZXIuXG4gKi9cbmNvbnN0IGdlbmVyYXRlUHJpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkpIHtcbiAgICBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5O1xufTtcbmNvbnN0IGdldFB1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHN5bmMgQVBJIHNvIHdlIHRocm93IGFuIGVycm9yIGltbWVkaWF0ZWx5LlxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gWFhYKEthZ2FtaSk6IGBlbGxpcHRpYy51dGlscy5lbmNvZGVgIHJldHVybnMgYXJyYXkgZm9yIGV2ZXJ5XG4gIC8vIGVuY29kaW5nIGV4Y2VwdCBgaGV4YC5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhcImFycmF5XCIpKTtcbn07XG5cbi8qKlxuICogR2V0IGNvbXByZXNzZWQgdmVyc2lvbiBvZiBwdWJsaWMga2V5LlxuICovXG5jb25zdCBnZXRQdWJsaWNDb21wcmVzc2VkID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3dhbmRlcmVyL3NlY3AyNTZrMS1ub2RlL2lzc3Vlcy80NlxuICBjb25zdCBjb21wcmVzc2VkID0gdHJ1ZTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCBcImFycmF5XCIpKTtcbn07XG5cbi8vIE5PVEUoS2FnYW1pKTogV2UgZG9uJ3QgdXNlIHByb21pc2Ugc2hpbSBpbiBCcm93c2VyIGltcGxlbWVudGF0aW9uXG4vLyBiZWNhdXNlIGl0J3Mgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG5ldyBicm93c2VycyAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PXByb21pc2VzPikgYW5kIHdlIGNhbiB1c2Ugb25seSBuZXcgYnJvd3NlcnNcbi8vIGJlY2F1c2Ugb2YgdGhlIFdlYkNyeXB0b0FQSSAoc2VlXG4vLyA8aHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWNyeXB0b2dyYXBoeT4pLlxuY29uc3Qgc2lnbiA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5LCBtc2cpIHtcbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5zaWduKG1zZywgcHJpdmF0ZUtleSwge1xuICAgIGNhbm9uaWNhbDogdHJ1ZVxuICB9KS50b0RFUigpKTtcbn07XG5jb25zdCB2ZXJpZnkgPSBhc3luYyBmdW5jdGlvbiAocHVibGljS2V5LCBtc2csIHNpZykge1xuICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Lmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleVswXSA9PT0gMiB8fCBwdWJsaWNLZXlbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgYXNzZXJ0KG1zZy5sZW5ndGggPiAwLCBcIk1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gMzIsIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiKTtcbiAgaWYgKGVjLnZlcmlmeShtc2csIHNpZywgcHVibGljS2V5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkJhZCBzaWduYXR1cmVcIik7XG59O1xuY29uc3QgZGVyaXZlID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvQXJyYXkoKSk7XG59O1xuY29uc3QgZGVyaXZlVW5wYWRkZWQgPSBkZXJpdmU7XG5jb25zdCBkZXJpdmVQYWRkZWQgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleUEsIHB1YmxpY0tleUIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUIpLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBhc3NlcnQocHJpdmF0ZUtleUEubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQocHVibGljS2V5Qi5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleUIubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gMiB8fCBwdWJsaWNLZXlCWzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleUEgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5QSk7XG4gIGNvbnN0IGtleUIgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleUIpO1xuICBjb25zdCBQeCA9IGtleUEuZGVyaXZlKGtleUIuZ2V0UHVibGljKCkpOyAvLyBCTiBpbnN0YW5jZVxuICByZXR1cm4gQnVmZmVyLmZyb20oUHgudG9TdHJpbmcoMTYsIDY0KSwgXCJoZXhcIik7XG59O1xuY29uc3QgZW5jcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwdWJsaWNLZXlUbywgbXNnLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBsZXQgZXBoZW1Qcml2YXRlS2V5ID0gb3B0cy5lcGhlbVByaXZhdGVLZXkgfHwgcmFuZG9tQnl0ZXMoMzIpO1xuICAvLyBUaGVyZSBpcyBhIHZlcnkgdW5saWtlbHkgcG9zc2liaWxpdHkgdGhhdCBpdCBpcyBub3QgYSB2YWxpZCBrZXlcbiAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShlcGhlbVByaXZhdGVLZXkpKSB7XG4gICAgZXBoZW1Qcml2YXRlS2V5ID0gb3B0cy5lcGhlbVByaXZhdGVLZXkgfHwgcmFuZG9tQnl0ZXMoMzIpO1xuICB9XG4gIGNvbnN0IGVwaGVtUHVibGljS2V5ID0gZ2V0UHVibGljKGVwaGVtUHJpdmF0ZUtleSk7XG4gIGNvbnN0IFB4ID0gYXdhaXQgZGVyaXZlVW5wYWRkZWQoZXBoZW1Qcml2YXRlS2V5LCBwdWJsaWNLZXlUbyk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIoUHgpO1xuICBjb25zdCBpdiA9IG9wdHMuaXYgfHwgcmFuZG9tQnl0ZXMoMTYpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAzMik7XG4gIGNvbnN0IG1hY0tleSA9IGhhc2guc2xpY2UoMzIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgYWVzQ2JjRW5jcnlwdChpdiwgQnVmZmVyLmZyb20oZW5jcnlwdGlvbktleSksIG1zZyk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBkYXRhO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtpdiwgZXBoZW1QdWJsaWNLZXksIGNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1NoYTI1NlNpZ24oQnVmZmVyLmZyb20obWFjS2V5KSwgZGF0YVRvTWFjKTtcbiAgcmV0dXJuIHtcbiAgICBpdixcbiAgICBlcGhlbVB1YmxpY0tleSxcbiAgICBjaXBoZXJ0ZXh0LFxuICAgIG1hY1xuICB9O1xufTtcbmNvbnN0IGRlY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgb3B0cywgX3BhZGRpbmcpIHtcbiAgY29uc3QgcGFkZGluZyA9IF9wYWRkaW5nICE9PSBudWxsICYmIF9wYWRkaW5nICE9PSB2b2lkIDAgPyBfcGFkZGluZyA6IGZhbHNlO1xuICBjb25zdCBkZXJpdmVMb2NhbCA9IHBhZGRpbmcgPyBkZXJpdmVQYWRkZWQgOiBkZXJpdmVVbnBhZGRlZDtcbiAgY29uc3QgUHggPSBhd2FpdCBkZXJpdmVMb2NhbChwcml2YXRlS2V5LCBvcHRzLmVwaGVtUHVibGljS2V5KTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihQeCk7XG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgY29uc3QgbWFjS2V5ID0gaGFzaC5zbGljZSgzMik7XG4gIGNvbnN0IGRhdGFUb01hYyA9IEJ1ZmZlci5jb25jYXQoW29wdHMuaXYsIG9wdHMuZXBoZW1QdWJsaWNLZXksIG9wdHMuY2lwaGVydGV4dF0pO1xuICBjb25zdCBtYWNHb29kID0gYXdhaXQgaG1hY1NoYTI1NlZlcmlmeShCdWZmZXIuZnJvbShtYWNLZXkpLCBkYXRhVG9NYWMsIG9wdHMubWFjKTtcbiAgaWYgKCFtYWNHb29kICYmIHBhZGRpbmcgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRlY3J5cHQocHJpdmF0ZUtleSwgb3B0cywgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoIW1hY0dvb2QgJiYgcGFkZGluZyA9PT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBNQUMgYWZ0ZXIgdHJ5aW5nIHBhZGRlZFwiKTtcbiAgfVxuICBjb25zdCBtc2cgPSBhd2FpdCBhZXNDYmNEZWNyeXB0KG9wdHMuaXYsIEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25LZXkpLCBvcHRzLmNpcGhlcnRleHQpO1xuICByZXR1cm4gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkobXNnKSk7XG59O1xuXG5leHBvcnQgeyBkZWNyeXB0LCBkZXJpdmUsIGRlcml2ZVBhZGRlZCwgZGVyaXZlVW5wYWRkZWQsIGVuY3J5cHQsIGdlbmVyYXRlUHJpdmF0ZSwgZ2V0UHVibGljLCBnZXRQdWJsaWNDb21wcmVzc2VkLCBzaWduLCB2ZXJpZnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjY3J5cHRvLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n}\n\n// #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n  return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\nfunction debugLogResponse(response) {\n  log.info(`Response: ${response.status} ${response.statusText}`);\n  log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n  const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n  if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise) => {\n  let timeoutFunc = null;\n  try {\n    const timeout = new Promise((_resolve, reject) => {\n      timeoutFunc = setTimeout(() => {\n        reject(new Error(`Timed out in ${ms}ms`));\n      }, ms);\n    });\n    const result = await Promise.race([promise, timeout]);\n    // promise.race will return the first resolved promise\n    // then we clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    return result;\n  } catch (err) {\n    // clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    // rethrow the original error\n    throw err;\n  }\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"POST\"\n  });\n\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (customOptions.logTracingHeader) {\n      logTracingHeader(response);\n    }\n    if (response.ok) {\n      const responseContentType = response.headers.get(\"content-type\");\n      if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n        return response.json();\n      }\n      return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PATCH\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PUT\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2h0dHAtaGVscGVycy9kaXN0L2h0dHBIZWxwZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDaEM7QUFDVzs7QUFFNUMsWUFBWSx5REFBa0I7QUFDOUIsYUFBYSw0Q0FBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQSxtQkFBbUI7O0FBRW5CLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUIsRUFBRSxvQkFBb0I7QUFDL0QsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUMsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFeVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLXNlc3Npb24tbWFuYWdlci9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanM/MjNmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC5tZXJnZSc7XG5pbXBvcnQgbG9nTGV2ZWwsIHsgbGV2ZWxzIH0gZnJvbSAnbG9nbGV2ZWwnO1xuXG5jb25zdCBsb2cgPSBsb2dMZXZlbC5nZXRMb2dnZXIoXCJodHRwLWhlbHBlcnNcIik7XG5sb2cuc2V0TGV2ZWwobGV2ZWxzLklORk8pO1xubGV0IGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xubGV0IGVtYmVkSG9zdCA9IFwiXCI7XG5cbi8vICNyZWdpb24gQVBJIEtleXNcbmNvbnN0IGdhdGV3YXlBdXRoSGVhZGVyID0gXCJ4LWFwaS1rZXlcIjtcbmNvbnN0IGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIgPSBcIngtZW1iZWQtaG9zdFwiO1xubGV0IHNlbnRyeSA9IG51bGw7XG5jb25zdCB0cmFjaW5nT3JpZ2lucyA9IFtdO1xuY29uc3QgdHJhY2luZ1BhdGhzID0gW107XG5mdW5jdGlvbiBlbmFibGVTZW50cnlUcmFjaW5nKF9zZW50cnksIF90cmFjaW5nT3JpZ2lucywgX3RyYWNpbmdQYXRocykge1xuICBzZW50cnkgPSBfc2VudHJ5O1xuICB0cmFjaW5nT3JpZ2lucy5wdXNoKC4uLl90cmFjaW5nT3JpZ2lucyk7XG4gIHRyYWNpbmdQYXRocy5wdXNoKC4uLl90cmFjaW5nUGF0aHMpO1xufVxuZnVuY3Rpb24gc2V0RW1iZWRIb3N0KGVtYmVkSG9zdF8pIHtcbiAgZW1iZWRIb3N0ID0gZW1iZWRIb3N0Xztcbn1cbmZ1bmN0aW9uIGNsZWFyRW1iZWRIb3N0KCkge1xuICBlbWJlZEhvc3QgPSBcIlwiO1xufVxuZnVuY3Rpb24gZ2V0RW1iZWRIb3N0KCkge1xuICByZXR1cm4gZW1iZWRIb3N0O1xufVxuZnVuY3Rpb24gc2V0QVBJS2V5KGFwaUtleV8pIHtcbiAgYXBpS2V5ID0gYXBpS2V5Xztcbn1cbmZ1bmN0aW9uIGNsZWFyQVBJS2V5KCkge1xuICBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIjtcbn1cbmZ1bmN0aW9uIGdldEFQSUtleSgpIHtcbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRUcmFjZSh1cmwsIGluaXQpIHtcbiAgbGV0IF91cmwgPSBudWxsO1xuICB0cnkge1xuICAgIF91cmwgPSBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICBpZiAoc2VudHJ5ICYmIF91cmwgJiYgKHRyYWNpbmdPcmlnaW5zLmluY2x1ZGVzKF91cmwub3JpZ2luKSB8fCB0cmFjaW5nUGF0aHMuaW5jbHVkZXMoX3VybC5wYXRobmFtZSkpKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzZW50cnkuc3RhcnRUcmFuc2FjdGlvbih7XG4gICAgICBuYW1lOiB1cmxcbiAgICB9KTtcbiAgICBjb25zdCBzcGFuID0gdHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICBvcDogXCJodHRwXCJcbiAgICB9KTsgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3BhblxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICAgIHNwYW4uZmluaXNoKCk7IC8vIFJlbWVtYmVyIHRoYXQgb25seSBmaW5pc2hlZCBzcGFucyB3aWxsIGJlIHNlbnQgd2l0aCB0aGUgdHJhbnNhY3Rpb25cblxuICAgIHRyYW5zYWN0aW9uLmZpbmlzaCgpOyAvLyBGaW5pc2hpbmcgdGhlIHRyYW5zYWN0aW9uIHdpbGwgc2VuZCBpdCB0byBTZW50cnlcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICByZXR1cm4gZmV0Y2godXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGdldEFwaUtleUhlYWRlcnMoKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFwaUtleSkgaGVhZGVyc1tnYXRld2F5QXV0aEhlYWRlcl0gPSBhcGlLZXk7XG4gIGlmIChlbWJlZEhvc3QpIGhlYWRlcnNbZ2F0ZXdheUVtYmVkSG9zdEhlYWRlcl0gPSBlbWJlZEhvc3Q7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSkge1xuICBsb2cuaW5mbyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gIGxvZy5pbmZvKGBVcmw6ICR7cmVzcG9uc2UudXJsfWApO1xufVxuZnVuY3Rpb24gbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSkge1xuICBjb25zdCB0cmFjaW5nSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LXdlYjMtY29ycmVsYXRpb24taWRcIik7XG4gIGlmICh0cmFjaW5nSGVhZGVyKSBsb2cuaW5mbyhgUmVxdWVzdCB0cmFjaW5nIHdpdGggdHJhY2VJRCA9ICR7dHJhY2luZ0hlYWRlcn1gKTtcbn1cbmNvbnN0IHByb21pc2VUaW1lb3V0ID0gYXN5bmMgKG1zLCBwcm9taXNlKSA9PiB7XG4gIGxldCB0aW1lb3V0RnVuYyA9IG51bGw7XG4gIHRyeSB7XG4gICAgY29uc3QgdGltZW91dCA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aW1lb3V0RnVuYyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lZCBvdXQgaW4gJHttc31tc2ApKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRdKTtcbiAgICAvLyBwcm9taXNlLnJhY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2VcbiAgICAvLyB0aGVuIHdlIGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHRpbWVvdXRGdW5jICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0RnVuYyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGNsZWFyIHRoZSB0aW1lb3V0XG4gICAgaWYgKHRpbWVvdXRGdW5jICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0RnVuYyk7XG4gICAgfVxuICAgIC8vIHJldGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuY29uc3QgZ2V0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHt9XG4gIH07XG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiR0VUXCJcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBwb3N0ID0gZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiXG4gIH0pO1xuXG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZVRpbWVvdXQoY3VzdG9tT3B0aW9ucy50aW1lb3V0IHx8IDYwMDAwLCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgaWYgKGN1c3RvbU9wdGlvbnMubG9nVHJhY2luZ0hlYWRlcikge1xuICAgICAgbG9nVHJhY2luZ0hlYWRlcihyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB0aHJvdyByZXNwb25zZTtcbiAgfSkpO1xufTtcbmNvbnN0IHBhdGNoID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUEFUQ0hcIlxuICB9KTtcbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBwdXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQVVRcIlxuICB9KTtcbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCByZW1vdmUgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICB9KTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IGdlbmVyYXRlSnNvblJQQ09iamVjdCA9IChtZXRob2QsIHBhcmFtZXRlcnMpID0+ICh7XG4gIGpzb25ycGM6IFwiMi4wXCIsXG4gIG1ldGhvZCxcbiAgaWQ6IDEwLFxuICBwYXJhbXM6IHBhcmFtZXRlcnNcbn0pO1xuY29uc3QgcHJvbWlzZVJhY2UgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA2MDAwMDtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbZ2V0KHVybCwgb3B0aW9ucyksIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwidGltZWQgb3V0XCIpKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSldKTtcbn07XG5cbmV4cG9ydCB7IGNsZWFyQVBJS2V5LCBjbGVhckVtYmVkSG9zdCwgZW5hYmxlU2VudHJ5VHJhY2luZywgZ2F0ZXdheUF1dGhIZWFkZXIsIGdhdGV3YXlFbWJlZEhvc3RIZWFkZXIsIGdlbmVyYXRlSnNvblJQQ09iamVjdCwgZ2V0LCBnZXRBUElLZXksIGdldEVtYmVkSG9zdCwgcGF0Y2gsIHBvc3QsIHByb21pc2VSYWNlLCBwcm9taXNlVGltZW91dCwgcHV0LCByZW1vdmUsIHNldEFQSUtleSwgc2V0RW1iZWRIb3N0LCBzZXRMb2dMZXZlbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/./node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n\n\n\n\n\n\n\n\nfunction keccak256(a) {\n  return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_4__.ec(\"secp256k1\");\n\nclass MetadataStorageLayer {\n  // ms\n\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"metadataHost\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"serverTimeOffset\", void 0);\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n  static setAPIKey(apiKey) {\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setEmbedHost)(embedHost);\n  }\n  generateMetadataParams(message, privateKeyHex) {\n    var _sig$recoveryParam$to, _sig$recoveryParam;\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(setData), \"utf8\")));\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64)\n    };\n  }\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16, 64),\n    pub_key_Y: pubKey.getY().toString(16, 64)\n  }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMvZGlzdC9tZXRhZGF0YUhlbHBlcnMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNHO0FBQ0k7QUFDMUI7QUFDUjtBQUNrQztBQUNOOztBQUVsRTtBQUNBLHFCQUFxQix1RUFBVztBQUNoQztBQUNBLGVBQWUsd0NBQUk7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRUFBUztBQUNiO0FBQ0E7QUFDQSxJQUFJLHFFQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNERBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJFQUFhLENBQUMsMkVBQWEsR0FBRyxXQUFXO0FBQ2pGO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyw2REFBSSxJQUFJLGtCQUFrQjtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkVBQWEsQ0FBQywyRUFBYSxHQUFHLGFBQWE7QUFDbkY7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLDZEQUFJLElBQUksa0JBQWtCO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQU8sQ0FBQyw4REFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDREQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0REFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNERBQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4TiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tc2Vzc2lvbi1tYW5hZ2VyL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMvZGlzdC9tZXRhZGF0YUhlbHBlcnMuZXNtLmpzPzFiOGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgcG9zdCB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnanNvbi1zdGFibGUtc3RyaW5naWZ5JztcbmltcG9ydCB7IGVjIGFzIGVjJDEgfSBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYgYXMga2VjY2FrMjU2JDEgfSBmcm9tICdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJztcbmltcG9ydCB7IGVuY3J5cHQsIGdldFB1YmxpYywgZGVjcnlwdCB9IGZyb20gJ0B0b3J1c2xhYnMvZWNjcnlwdG8nO1xuXG5mdW5jdGlvbiBrZWNjYWsyNTYoYSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrMjU2JDEoYSkpO1xufVxuY29uc3QgZWMgPSBuZXcgZWMkMShcInNlY3AyNTZrMVwiKTtcblxuY2xhc3MgTWV0YWRhdGFTdG9yYWdlTGF5ZXIge1xuICAvLyBtc1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXRhZGF0YUhvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiaHR0cHM6Ly9tZXRhZGF0YS50b3IudXNcIjtcbiAgICBsZXQgc2VydmVyVGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YUhvc3RcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJ2ZXJUaW1lT2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5tZXRhZGF0YUhvc3QgPSBtZXRhZGF0YUhvc3Q7XG4gICAgdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gc2VydmVyVGltZU9mZnNldDtcbiAgfVxuICBzdGF0aWMgc2V0QVBJS2V5KGFwaUtleSkge1xuICAgIHNldEFQSUtleShhcGlLZXkpO1xuICB9XG4gIHN0YXRpYyBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0KSB7XG4gICAgc2V0RW1iZWRIb3N0KGVtYmVkSG9zdCk7XG4gIH1cbiAgZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyhtZXNzYWdlLCBwcml2YXRlS2V5SGV4KSB7XG4gICAgdmFyIF9zaWckcmVjb3ZlcnlQYXJhbSR0bywgX3NpZyRyZWNvdmVyeVBhcmFtO1xuICAgIGNvbnN0IGtleSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlIZXgsIFwiaGV4XCIpO1xuICAgIGNvbnN0IHNldERhdGEgPSB7XG4gICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKHRoaXMuc2VydmVyVGltZU9mZnNldCArIERhdGUubm93KCkgLyAxMDAwKS50b1N0cmluZygxNilcbiAgICB9O1xuICAgIGNvbnN0IHNpZyA9IGtleS5zaWduKGtlY2NhazI1NihCdWZmZXIuZnJvbShzdHJpbmdpZnkoc2V0RGF0YSksIFwidXRmOFwiKSkpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWJfa2V5X1g6IGtleS5nZXRQdWJsaWMoKS5nZXRYKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHB1Yl9rZXlfWToga2V5LmdldFB1YmxpYygpLmdldFkoKS50b1N0cmluZygxNiwgNjQpLFxuICAgICAgc2V0X2RhdGE6IHNldERhdGEsXG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5yLnRvU3RyaW5nKDE2LCA2NCkgKyBzaWcucy50b1N0cmluZygxNiwgNjQpICsgKChfc2lnJHJlY292ZXJ5UGFyYW0kdG8gPSAoX3NpZyRyZWNvdmVyeVBhcmFtID0gc2lnLnJlY292ZXJ5UGFyYW0pID09PSBudWxsIHx8IF9zaWckcmVjb3ZlcnlQYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NpZyRyZWNvdmVyeVBhcmFtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikuc2xpY2UoLTIpKSAhPT0gbnVsbCAmJiBfc2lnJHJlY292ZXJ5UGFyYW0kdG8gIT09IHZvaWQgMCA/IF9zaWckcmVjb3ZlcnlQYXJhbSR0byA6IFwiMDBcIiksIFwiaGV4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZVB1YktleVBhcmFtcyhwcml2YXRlS2V5SGV4KSB7XG4gICAgY29uc3Qga2V5ID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUhleCwgXCJoZXhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yl9rZXlfWDoga2V5LmdldFB1YmxpYygpLmdldFgoKS50b1N0cmluZygxNiwgNjQpLFxuICAgICAgcHViX2tleV9ZOiBrZXkuZ2V0UHVibGljKCkuZ2V0WSgpLnRvU3RyaW5nKDE2LCA2NClcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNldE1ldGFkYXRhKGRhdGEsIG5hbWVzcGFjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5hbWVzcGFjZSAhPT0gbnVsbCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICBuYW1lc3BhY2VcbiAgICB9KSA6IGRhdGE7XG4gICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5tZXRhZGF0YUhvc3R9L3NldGAsIHBhcmFtcywgb3B0aW9ucywge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhUmVzcG9uc2UubWVzc2FnZTtcbiAgfVxuICBhc3luYyBnZXRNZXRhZGF0YShwdWJLZXksIG5hbWVzcGFjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5hbWVzcGFjZSAhPT0gbnVsbCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHViS2V5KSwge30sIHtcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pIDogcHViS2V5O1xuICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMubWV0YWRhdGFIb3N0fS9nZXRgLCBwYXJhbXMsIG9wdGlvbnMsIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhZGF0YVJlc3BvbnNlLm1lc3NhZ2U7XG4gIH1cbn1cblxuY29uc3QgV0VCQVVUSE5fVE9SVVNfU0hBUkUgPSBcIndlYmF1dGhuX3RvcnVzX3NoYXJlXCI7XG5jb25zdCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUgPSBcIndlYmF1dGhuX2RldmljZV9zaGFyZVwiO1xuZnVuY3Rpb24gZW5jUGFyYW1zSGV4VG9CdWYoZW5jUGFyYW1zSGV4KSB7XG4gIHJldHVybiB7XG4gICAgaXY6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5pdiwgXCJoZXhcIiksXG4gICAgZXBoZW1QdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5lcGhlbVB1YmxpY0tleSwgXCJoZXhcIiksXG4gICAgY2lwaGVydGV4dDogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4LmNpcGhlcnRleHQsIFwiaGV4XCIpLFxuICAgIG1hYzogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4Lm1hYywgXCJoZXhcIilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1BhcmFtcykge1xuICByZXR1cm4ge1xuICAgIGl2OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuaXYpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIGVwaGVtUHVibGljS2V5OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuZXBoZW1QdWJsaWNLZXkpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5jaXBoZXJ0ZXh0KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBtYWM6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5tYWMpLnRvU3RyaW5nKFwiaGV4XCIpXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0RGF0YShwcml2S2V5SGV4LCBkKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWREZWMgPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgY29uc3Qgc2VyaWFsaXplZEJ1ZiA9IEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREZWMsIFwidXRmLThcIik7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGF3YWl0IGVuY3J5cHQoZ2V0UHVibGljKEJ1ZmZlci5mcm9tKHByaXZLZXlIZXgsIFwiaGV4XCIpKSwgc2VyaWFsaXplZEJ1Zik7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1BhcmFtcyk7XG4gIGNvbnN0IHNEYXRhID0gSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW1zSGV4KTtcbiAgcmV0dXJuIHNEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdERhdGEocHJpdktleUhleCwgZCkge1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBKU09OLnBhcnNlKGQpO1xuICBjb25zdCBlbmNQYXJhbXMgPSBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpO1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUocHJpdktleUhleCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRCdWYgPSBhd2FpdCBkZWNyeXB0KEJ1ZmZlci5mcm9tKGtleVBhaXIuZ2V0UHJpdmF0ZSgpLnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgXCJoZXhcIiksIGVuY1BhcmFtcyk7XG4gIGNvbnN0IHNlcmlhbGl6ZWREZWMgPSBzZXJpYWxpemVkQnVmLnRvU3RyaW5nKFwidXRmLThcIik7XG4gIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWREZWMpO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFuZERlY3J5cHREYXRhKG0sIHByaXZLZXlIZXgsIG5hbWVzcGFjZSkge1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUocHJpdktleUhleCwgXCJoZXhcIik7XG4gIGNvbnN0IHB1YktleSA9IGtleVBhaXIuZ2V0UHVibGljKCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbS5nZXRNZXRhZGF0YSh7XG4gICAgcHViX2tleV9YOiBwdWJLZXkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgcHViX2tleV9ZOiBwdWJLZXkuZ2V0WSgpLnRvU3RyaW5nKDE2LCA2NClcbiAgfSwgbmFtZXNwYWNlKTtcbiAgaWYgKCFzZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBkZWNyeXB0RGF0YShwcml2S2V5SGV4LCBzZXJpYWxpemVkRGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleUhleCwgZCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IHNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEocHJpdktleUhleCwgZCk7XG4gIGNvbnN0IG1ldGFkYXRhUGFyYW1zID0gbS5nZW5lcmF0ZU1ldGFkYXRhUGFyYW1zKHNEYXRhLCBwcml2S2V5SGV4KTtcbiAgYXdhaXQgbS5zZXRNZXRhZGF0YShtZXRhZGF0YVBhcmFtcywgbmFtZXNwYWNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldFRvcnVzU2hhcmUobSwgd2ViQXV0aG5QdWJLZXksIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSwgc3Vic3BhY2VEYXRhKSB7XG4gIGNvbnN0IHJlZktleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRoblJlZkhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSByZWZLZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3QgcHViS2V5ID0gZWMua2V5RnJvbVB1YmxpYyh7XG4gICAgeDogd2ViQXV0aG5QdWJLZXkucHViX2tleV9YLFxuICAgIHk6IHdlYkF1dGhuUHViS2V5LnB1Yl9rZXlfWVxuICB9KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGxldCBkID0ge307XG4gIGlmIChkYXRhKSBkID0gZGF0YTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YSA9IEpTT04uc3RyaW5naWZ5KHN1YnNwYWNlRGF0YSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkU3Vic3BhY2VEYXRhLCBcInV0Zi04XCIpO1xuICBjb25zdCBlbmNTdWJzcGFjZURhdGEgPSBhd2FpdCBlbmNyeXB0KEJ1ZmZlci5mcm9tKHB1YktleS5nZXRQdWJsaWMoXCJoZXhcIiksIFwiaGV4XCIpLCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmKTtcbiAgY29uc3QgZW5jU3Vic3BhY2VEYXRhSGV4ID0gZW5jUGFyYW1zQnVmVG9IZXgoZW5jU3Vic3BhY2VEYXRhKTtcbiAgZFtzdWJzcGFjZV0gPSBlbmNTdWJzcGFjZURhdGFIZXg7XG4gIGF3YWl0IGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBkLCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXREZXZpY2VTaGFyZShtLCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UsIHN1YnNwYWNlRGF0YSkge1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5SZWZIZXgpO1xuICBjb25zdCBwcml2S2V5ID0ga2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgbGV0IGQgPSB7fTtcbiAgaWYgKGRhdGEpIGQgPSBkYXRhO1xuICBkW3N1YnNwYWNlXSA9IHN1YnNwYWNlRGF0YTtcbiAgYXdhaXQgZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIGQsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUb3J1c1NoYXJlKG0sIHdlYkF1dGhuS2V5SGV4LCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IGRhdGFbc3Vic3BhY2VdO1xuICBpZiAoIWVuY1BhcmFtc0hleCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCk7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRobktleUhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSBrZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiA9IGF3YWl0IGRlY3J5cHQoQnVmZmVyLmZyb20ocHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIFwiaGV4XCIpLCBlbmNQYXJhbXMpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhID0gc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xuICBjb25zdCBzdWJzcGFjZURhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEpO1xuICByZXR1cm4gc3Vic3BhY2VEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlU2hhcmUobSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgaWYgKGRhdGEpIHJldHVybiBkYXRhW3N1YnNwYWNlXTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGRlY3J5cHREYXRhLCBNZXRhZGF0YVN0b3JhZ2VMYXllciBhcyBkZWZhdWx0LCBlYywgZW5jUGFyYW1zQnVmVG9IZXgsIGVuY1BhcmFtc0hleFRvQnVmLCBlbmNyeXB0QW5kU2V0RGF0YSwgZW5jcnlwdERhdGEsIGdldEFuZERlY3J5cHREYXRhLCBnZXREZXZpY2VTaGFyZSwgZ2V0VG9ydXNTaGFyZSwga2VjY2FrMjU2LCBzZXREZXZpY2VTaGFyZSwgc2V0VG9ydXNTaGFyZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-session-manager/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD_ENV: () => (/* binding */ BUILD_ENV),\n/* harmony export */   BrowserStorage: () => (/* binding */ BrowserStorage),\n/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES),\n/* harmony export */   LANGUAGE_MAP: () => (/* binding */ LANGUAGE_MAP),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   MFA_FACTOR: () => (/* binding */ MFA_FACTOR),\n/* harmony export */   MFA_LEVELS: () => (/* binding */ MFA_LEVELS),\n/* harmony export */   MemoryStore: () => (/* binding */ MemoryStore),\n/* harmony export */   OPENLOGIN_ACTIONS: () => (/* binding */ OPENLOGIN_ACTIONS),\n/* harmony export */   OPENLOGIN_NETWORK: () => (/* binding */ OPENLOGIN_NETWORK),\n/* harmony export */   SUPPORTED_KEY_CURVES: () => (/* binding */ SUPPORTED_KEY_CURVES),\n/* harmony export */   THEME_MODES: () => (/* binding */ THEME_MODES),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   UX_MODE: () => (/* binding */ UX_MODE),\n/* harmony export */   applyWhiteLabelTheme: () => (/* binding */ applyWhiteLabelTheme),\n/* harmony export */   base64toJSON: () => (/* binding */ base64toJSON),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   generateWhiteLabelTheme: () => (/* binding */ generateWhiteLabelTheme),\n/* harmony export */   getColorsList: () => (/* binding */ getColorsList),\n/* harmony export */   jsonToBase64: () => (/* binding */ jsonToBase64),\n/* harmony export */   safeatob: () => (/* binding */ safeatob),\n/* harmony export */   safebtoa: () => (/* binding */ safebtoa),\n/* harmony export */   storageAvailable: () => (/* binding */ storageAvailable),\n/* harmony export */   storeKey: () => (/* binding */ storeKey)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/constants */ \"(ssr)/./node_modules/@toruslabs/openlogin-utils/node_modules/@toruslabs/constants/dist/constants.esm.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! color */ \"(ssr)/./node_modules/color/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(color__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_1___default());\nfunction safebtoa(str) {\n  return base64url.encode(str);\n}\nfunction safeatob(str) {\n  // Going backwards: from bytestream, to percent-encoding, to original string.\n  return base64url.decode(str);\n}\nfunction base64toJSON(b64str) {\n  return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n  return base64url.encode(JSON.stringify(json));\n}\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (err) {\n    const error = err;\n    return error && (\n    // everything except Firefox\n    error.code === 22 ||\n    // Firefox\n    error.code === 1014 ||\n    // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededError\" ||\n    // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") &&\n    // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\n\nclass MemoryStore {\n  constructor() {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"store\", new Map());\n  }\n  getItem(key) {\n    return this.store.get(key) || null;\n  }\n  setItem(key, value) {\n    this.store.set(key, value);\n  }\n  removeItem(key) {\n    this.store.delete(key);\n  }\n}\nclass BrowserStorage {\n  constructor(storeKey, storage) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"storage\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_storeKey\", void 0);\n    this.storage = storage;\n    this._storeKey = storeKey;\n    try {\n      if (!storage.getItem(storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {\n      // Storage is not available\n    }\n  }\n  static getInstance(key) {\n    let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n    if (!this.instanceMap.has(key)) {\n      let storage;\n      if (storageKey === \"local\" && storageAvailable(\"localStorage\")) {\n        storage = window.localStorage;\n      } else if (storageKey === \"session\" && storageAvailable(\"sessionStorage\")) {\n        storage = window.sessionStorage;\n      } else {\n        storage = new MemoryStore();\n      }\n      this.instanceMap.set(key, new this(key, storage));\n    }\n    return this.instanceMap.get(key);\n  }\n  toJSON() {\n    return this.storage.getItem(this._storeKey);\n  }\n  resetStore() {\n    const currStore = this.getStore();\n    this.storage.removeItem(this._storeKey);\n    return currStore;\n  }\n  getStore() {\n    return JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n  }\n  get(key) {\n    const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    return store[key];\n  }\n  set(key, value) {\n    const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    store[key] = value;\n    this.storage.setItem(this._storeKey, JSON.stringify(store));\n  }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(BrowserStorage, \"instanceMap\", new Map());\n\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_NETWORK = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK), _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK);\nconst SUPPORTED_KEY_CURVES = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  FARCASTER: \"farcaster\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  SMS_PASSWORDLESS: \"sms_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\",\n  NONE: \"none\"\n};\nconst OPENLOGIN_ACTIONS = {\n  LOGIN: \"login\",\n  ENABLE_MFA: \"enable_mfa\",\n  MANAGE_MFA: \"manage_mfa\",\n  MODIFY_SOCIAL_FACTOR: \"modify_social_factor\"\n};\nconst BUILD_ENV = {\n  PRODUCTION: \"production\",\n  DEVELOPMENT: \"development\",\n  STAGING: \"staging\",\n  TESTING: \"testing\"\n};\n\n/**\n * {@label loginProviderType}\n */\n\n// autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729\n\nconst LANGUAGES = {\n  en: \"en\",\n  ja: \"ja\",\n  ko: \"ko\",\n  de: \"de\",\n  zh: \"zh\",\n  es: \"es\",\n  fr: \"fr\",\n  pt: \"pt\",\n  nl: \"nl\",\n  tr: \"tr\"\n};\nconst LANGUAGE_MAP = {\n  en: \"english\",\n  ja: \"japanese\",\n  ko: \"korean\",\n  de: \"german\",\n  zh: \"mandarin\",\n  es: \"spanish\",\n  fr: \"french\",\n  pt: \"portuguese\",\n  nl: \"dutch\",\n  tr: \"turkish\"\n};\nconst THEME_MODES = {\n  light: \"light\",\n  dark: \"dark\",\n  auto: \"auto\"\n};\nconst MFA_FACTOR = {\n  DEVICE: \"deviceShareFactor\",\n  BACKUP_SHARE: \"backUpShareFactor\",\n  SOCIAL_BACKUP: \"socialBackupFactor\",\n  PASSWORD: \"passwordFactor\",\n  PASSKEYS: \"passkeysFactor\",\n  AUTHENTICATOR: \"authenticatorFactor\"\n};\n\nfunction getColorsList() {\n  let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n  let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n  let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"black\";\n  let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;\n  let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"#0346ff\";\n  const colorsList = [];\n  let step;\n  for (step = 0; step < colorsAmount; step += 1) {\n    colorsList.push(color__WEBPACK_IMPORTED_MODULE_4___default()(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix(color__WEBPACK_IMPORTED_MODULE_4___default()(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());\n  }\n  return colorsList;\n}\nfunction generateWhiteLabelTheme(primary) {\n  const darkSet = getColorsList(3, 50, \"black\", 0, 20, primary);\n  const lightSet = getColorsList(6, 85, \"white\", 0, 20, primary);\n  return [...darkSet.reverse(), primary, ...lightSet];\n}\nfunction applyWhiteLabelTheme(rootElement, theme) {\n  if (theme.primary) {\n    const themeSet = generateWhiteLabelTheme(theme.primary);\n    rootElement.style.setProperty(\"--app-primary-900\", themeSet[0]);\n    rootElement.style.setProperty(\"--app-primary-800\", themeSet[1]);\n    rootElement.style.setProperty(\"--app-primary-700\", themeSet[2]);\n    rootElement.style.setProperty(\"--app-primary-600\", themeSet[3]);\n    rootElement.style.setProperty(\"--app-primary-500\", themeSet[4]);\n    rootElement.style.setProperty(\"--app-primary-400\", themeSet[5]);\n    rootElement.style.setProperty(\"--app-primary-300\", themeSet[6]);\n    rootElement.style.setProperty(\"--app-primary-200\", themeSet[7]);\n    rootElement.style.setProperty(\"--app-primary-100\", themeSet[8]);\n    rootElement.style.setProperty(\"--app-primary-50\", themeSet[9]);\n  }\n  if (theme.onPrimary) {\n    rootElement.style.setProperty(\"--app-on-primary\", theme.onPrimary);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMvQjtBQUM0QjtBQUNtQjtBQUNBO0FBQzFEOztBQUUxQixrQkFBa0Isa0RBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyRUFBYSxDQUFDLDJFQUFhLEdBQUcsRUFBRSx3RUFBc0IsR0FBRyxzRUFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEMsb0JBQW9CLDRDQUFLLHFIQUFxSCw0Q0FBSztBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwViIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanM/OGY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IGJhc2U2NHVybExpYiBmcm9tICdiYXNlNjR1cmwnO1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCB7IFRPUlVTX1NBUFBISVJFX05FVFdPUkssIFRPUlVTX0xFR0FDWV9ORVRXT1JLIH0gZnJvbSAnQHRvcnVzbGFicy9jb25zdGFudHMnO1xuZXhwb3J0IHsgVE9SVVNfTEVHQUNZX05FVFdPUkssIFRPUlVTX1NBUFBISVJFX05FVFdPUksgfSBmcm9tICdAdG9ydXNsYWJzL2NvbnN0YW50cyc7XG5pbXBvcnQgQ29sb3IgZnJvbSAnY29sb3InO1xuXG5jb25zdCBiYXNlNjR1cmwgPSBiYXNlNjR1cmxMaWI7XG5mdW5jdGlvbiBzYWZlYnRvYShzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIHNhZmVhdG9iKHN0cikge1xuICAvLyBHb2luZyBiYWNrd2FyZHM6IGZyb20gYnl0ZXN0cmVhbSwgdG8gcGVyY2VudC1lbmNvZGluZywgdG8gb3JpZ2luYWwgc3RyaW5nLlxuICByZXR1cm4gYmFzZTY0dXJsLmRlY29kZShzdHIpO1xufVxuZnVuY3Rpb24gYmFzZTY0dG9KU09OKGI2NHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGI2NHN0cikpO1xufVxuZnVuY3Rpb24ganNvblRvQmFzZTY0KGpzb24pIHtcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoanNvbikpO1xufVxuZnVuY3Rpb24gc3RvcmFnZUF2YWlsYWJsZSh0eXBlKSB7XG4gIGxldCBzdG9yYWdlRXhpc3RzID0gZmFsc2U7XG4gIGxldCBzdG9yYWdlTGVuZ3RoID0gMDtcbiAgbGV0IHN0b3JhZ2U7XG4gIHRyeSB7XG4gICAgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICBzdG9yYWdlRXhpc3RzID0gdHJ1ZTtcbiAgICBzdG9yYWdlTGVuZ3RoID0gc3RvcmFnZS5sZW5ndGg7XG4gICAgY29uc3QgeCA9IFwiX19zdG9yYWdlX3Rlc3RfX1wiO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgIHJldHVybiBlcnJvciAmJiAoXG4gICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgIGVycm9yLmNvZGUgPT09IDIyIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGVycm9yLmNvZGUgPT09IDEwMTQgfHxcbiAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZXJyb3IubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlcnJvci5uYW1lID09PSBcIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIpICYmXG4gICAgLy8gYWNrbm93bGVkZ2UgUXVvdGFFeGNlZWRlZEVycm9yIG9ubHkgaWYgdGhlcmUncyBzb21ldGhpbmcgYWxyZWFkeSBzdG9yZWRcbiAgICBzdG9yYWdlRXhpc3RzICYmIHN0b3JhZ2VMZW5ndGggIT09IDA7XG4gIH1cbn1cblxuY2xhc3MgTWVtb3J5U3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZVwiLCBuZXcgTWFwKCkpO1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0b3JlLnNldChrZXksIHZhbHVlKTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHRoaXMuc3RvcmUuZGVsZXRlKGtleSk7XG4gIH1cbn1cbmNsYXNzIEJyb3dzZXJTdG9yYWdlIHtcbiAgY29uc3RydWN0b3Ioc3RvcmVLZXksIHN0b3JhZ2UpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JlS2V5XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICB0aGlzLl9zdG9yZUtleSA9IHN0b3JlS2V5O1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXN0b3JhZ2UuZ2V0SXRlbShzdG9yZUtleSkpIHtcbiAgICAgICAgdGhpcy5yZXNldFN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2Uoa2V5KSB7XG4gICAgbGV0IHN0b3JhZ2VLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibG9jYWxcIjtcbiAgICBpZiAoIXRoaXMuaW5zdGFuY2VNYXAuaGFzKGtleSkpIHtcbiAgICAgIGxldCBzdG9yYWdlO1xuICAgICAgaWYgKHN0b3JhZ2VLZXkgPT09IFwibG9jYWxcIiAmJiBzdG9yYWdlQXZhaWxhYmxlKFwibG9jYWxTdG9yYWdlXCIpKSB7XG4gICAgICAgIHN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgfSBlbHNlIGlmIChzdG9yYWdlS2V5ID09PSBcInNlc3Npb25cIiAmJiBzdG9yYWdlQXZhaWxhYmxlKFwic2Vzc2lvblN0b3JhZ2VcIikpIHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JhZ2UgPSBuZXcgTWVtb3J5U3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdGFuY2VNYXAuc2V0KGtleSwgbmV3IHRoaXMoa2V5LCBzdG9yYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlTWFwLmdldChrZXkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpO1xuICB9XG4gIHJlc2V0U3RvcmUoKSB7XG4gICAgY29uc3QgY3VyclN0b3JlID0gdGhpcy5nZXRTdG9yZSgpO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuX3N0b3JlS2V5KTtcbiAgICByZXR1cm4gY3VyclN0b3JlO1xuICB9XG4gIGdldFN0b3JlKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JlS2V5KSB8fCBcInt9XCIpO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICBjb25zdCBzdG9yZSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpIHx8IFwie31cIik7XG4gICAgcmV0dXJuIHN0b3JlW2tleV07XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzdG9yZSA9IEpTT04ucGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmVLZXkpIHx8IFwie31cIik7XG4gICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuX3N0b3JlS2V5LCBKU09OLnN0cmluZ2lmeShzdG9yZSkpO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoQnJvd3NlclN0b3JhZ2UsIFwiaW5zdGFuY2VNYXBcIiwgbmV3IE1hcCgpKTtcblxuY29uc3Qgc3RvcmVLZXkgPSBcIm9wZW5sb2dpbl9zdG9yZVwiO1xuY29uc3QgVVhfTU9ERSA9IHtcbiAgUE9QVVA6IFwicG9wdXBcIixcbiAgUkVESVJFQ1Q6IFwicmVkaXJlY3RcIlxufTtcbmNvbnN0IE9QRU5MT0dJTl9ORVRXT1JLID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBUT1JVU19TQVBQSElSRV9ORVRXT1JLKSwgVE9SVVNfTEVHQUNZX05FVFdPUkspO1xuY29uc3QgU1VQUE9SVEVEX0tFWV9DVVJWRVMgPSB7XG4gIFNFQ1AyNTZLMTogXCJzZWNwMjU2azFcIixcbiAgRUQyNTUxOTogXCJlZDI1NTE5XCJcbn07XG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEZBUkNBU1RFUjogXCJmYXJjYXN0ZXJcIixcbiAgRU1BSUxfUEFTU1dPUkRMRVNTOiBcImVtYWlsX3Bhc3N3b3JkbGVzc1wiLFxuICBTTVNfUEFTU1dPUkRMRVNTOiBcInNtc19wYXNzd29yZGxlc3NcIixcbiAgV0VCQVVUSE46IFwid2ViYXV0aG5cIixcbiAgSldUOiBcImp3dFwiXG59O1xuY29uc3QgTUZBX0xFVkVMUyA9IHtcbiAgREVGQVVMVDogXCJkZWZhdWx0XCIsXG4gIE9QVElPTkFMOiBcIm9wdGlvbmFsXCIsXG4gIE1BTkRBVE9SWTogXCJtYW5kYXRvcnlcIixcbiAgTk9ORTogXCJub25lXCJcbn07XG5jb25zdCBPUEVOTE9HSU5fQUNUSU9OUyA9IHtcbiAgTE9HSU46IFwibG9naW5cIixcbiAgRU5BQkxFX01GQTogXCJlbmFibGVfbWZhXCIsXG4gIE1BTkFHRV9NRkE6IFwibWFuYWdlX21mYVwiLFxuICBNT0RJRllfU09DSUFMX0ZBQ1RPUjogXCJtb2RpZnlfc29jaWFsX2ZhY3RvclwiXG59O1xuY29uc3QgQlVJTERfRU5WID0ge1xuICBQUk9EVUNUSU9OOiBcInByb2R1Y3Rpb25cIixcbiAgREVWRUxPUE1FTlQ6IFwiZGV2ZWxvcG1lbnRcIixcbiAgU1RBR0lORzogXCJzdGFnaW5nXCIsXG4gIFRFU1RJTkc6IFwidGVzdGluZ1wiXG59O1xuXG4vKipcbiAqIHtAbGFiZWwgbG9naW5Qcm92aWRlclR5cGV9XG4gKi9cblxuLy8gYXV0b2NvbXBsZXRlIHdvcmthcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yOTcyOVxuXG5jb25zdCBMQU5HVUFHRVMgPSB7XG4gIGVuOiBcImVuXCIsXG4gIGphOiBcImphXCIsXG4gIGtvOiBcImtvXCIsXG4gIGRlOiBcImRlXCIsXG4gIHpoOiBcInpoXCIsXG4gIGVzOiBcImVzXCIsXG4gIGZyOiBcImZyXCIsXG4gIHB0OiBcInB0XCIsXG4gIG5sOiBcIm5sXCIsXG4gIHRyOiBcInRyXCJcbn07XG5jb25zdCBMQU5HVUFHRV9NQVAgPSB7XG4gIGVuOiBcImVuZ2xpc2hcIixcbiAgamE6IFwiamFwYW5lc2VcIixcbiAga286IFwia29yZWFuXCIsXG4gIGRlOiBcImdlcm1hblwiLFxuICB6aDogXCJtYW5kYXJpblwiLFxuICBlczogXCJzcGFuaXNoXCIsXG4gIGZyOiBcImZyZW5jaFwiLFxuICBwdDogXCJwb3J0dWd1ZXNlXCIsXG4gIG5sOiBcImR1dGNoXCIsXG4gIHRyOiBcInR1cmtpc2hcIlxufTtcbmNvbnN0IFRIRU1FX01PREVTID0ge1xuICBsaWdodDogXCJsaWdodFwiLFxuICBkYXJrOiBcImRhcmtcIixcbiAgYXV0bzogXCJhdXRvXCJcbn07XG5jb25zdCBNRkFfRkFDVE9SID0ge1xuICBERVZJQ0U6IFwiZGV2aWNlU2hhcmVGYWN0b3JcIixcbiAgQkFDS1VQX1NIQVJFOiBcImJhY2tVcFNoYXJlRmFjdG9yXCIsXG4gIFNPQ0lBTF9CQUNLVVA6IFwic29jaWFsQmFja3VwRmFjdG9yXCIsXG4gIFBBU1NXT1JEOiBcInBhc3N3b3JkRmFjdG9yXCIsXG4gIFBBU1NLRVlTOiBcInBhc3NrZXlzRmFjdG9yXCIsXG4gIEFVVEhFTlRJQ0FUT1I6IFwiYXV0aGVudGljYXRvckZhY3RvclwiXG59O1xuXG5mdW5jdGlvbiBnZXRDb2xvcnNMaXN0KCkge1xuICBsZXQgY29sb3JzQW1vdW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAzO1xuICBsZXQgY29sb3JzU2hpZnRBbW91bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDUwO1xuICBsZXQgbWl4Q29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiYmxhY2tcIjtcbiAgbGV0IHJvdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgbGV0IHNhdHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDIwO1xuICBsZXQgbWFpbkNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIiMwMzQ2ZmZcIjtcbiAgY29uc3QgY29sb3JzTGlzdCA9IFtdO1xuICBsZXQgc3RlcDtcbiAgZm9yIChzdGVwID0gMDsgc3RlcCA8IGNvbG9yc0Ftb3VudDsgc3RlcCArPSAxKSB7XG4gICAgY29sb3JzTGlzdC5wdXNoKENvbG9yKG1haW5Db2xvcikucm90YXRlKChzdGVwICsgMSkgLyBjb2xvcnNBbW91bnQgKiAtcm90YXRlKS5zYXR1cmF0ZSgoc3RlcCArIDEpIC8gY29sb3JzQW1vdW50ICogKHNhdHVyYXRpb24gLyAxMDApKS5taXgoQ29sb3IobWl4Q29sb3IpLCBjb2xvcnNTaGlmdEFtb3VudCAvIDEwMCAqIChzdGVwICsgMSkgLyBjb2xvcnNBbW91bnQpLmhleCgpKTtcbiAgfVxuICByZXR1cm4gY29sb3JzTGlzdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lKHByaW1hcnkpIHtcbiAgY29uc3QgZGFya1NldCA9IGdldENvbG9yc0xpc3QoMywgNTAsIFwiYmxhY2tcIiwgMCwgMjAsIHByaW1hcnkpO1xuICBjb25zdCBsaWdodFNldCA9IGdldENvbG9yc0xpc3QoNiwgODUsIFwid2hpdGVcIiwgMCwgMjAsIHByaW1hcnkpO1xuICByZXR1cm4gWy4uLmRhcmtTZXQucmV2ZXJzZSgpLCBwcmltYXJ5LCAuLi5saWdodFNldF07XG59XG5mdW5jdGlvbiBhcHBseVdoaXRlTGFiZWxUaGVtZShyb290RWxlbWVudCwgdGhlbWUpIHtcbiAgaWYgKHRoZW1lLnByaW1hcnkpIHtcbiAgICBjb25zdCB0aGVtZVNldCA9IGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lKHRoZW1lLnByaW1hcnkpO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS05MDBcIiwgdGhlbWVTZXRbMF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS04MDBcIiwgdGhlbWVTZXRbMV0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS03MDBcIiwgdGhlbWVTZXRbMl0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS02MDBcIiwgdGhlbWVTZXRbM10pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS01MDBcIiwgdGhlbWVTZXRbNF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS00MDBcIiwgdGhlbWVTZXRbNV0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0zMDBcIiwgdGhlbWVTZXRbNl0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0yMDBcIiwgdGhlbWVTZXRbN10pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS0xMDBcIiwgdGhlbWVTZXRbOF0pO1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtcHJpbWFyeS01MFwiLCB0aGVtZVNldFs5XSk7XG4gIH1cbiAgaWYgKHRoZW1lLm9uUHJpbWFyeSkge1xuICAgIHJvb3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1hcHAtb24tcHJpbWFyeVwiLCB0aGVtZS5vblByaW1hcnkpO1xuICB9XG59XG5cbmV4cG9ydCB7IEJVSUxEX0VOViwgQnJvd3NlclN0b3JhZ2UsIExBTkdVQUdFUywgTEFOR1VBR0VfTUFQLCBMT0dJTl9QUk9WSURFUiwgTUZBX0ZBQ1RPUiwgTUZBX0xFVkVMUywgTWVtb3J5U3RvcmUsIE9QRU5MT0dJTl9BQ1RJT05TLCBPUEVOTE9HSU5fTkVUV09SSywgU1VQUE9SVEVEX0tFWV9DVVJWRVMsIFRIRU1FX01PREVTLCBVWF9NT0RFLCBhcHBseVdoaXRlTGFiZWxUaGVtZSwgYmFzZTY0dG9KU09OLCBiYXNlNjR1cmwsIGdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lLCBnZXRDb2xvcnNMaXN0LCBqc29uVG9CYXNlNjQsIHNhZmVhdG9iLCBzYWZlYnRvYSwgc3RvcmFnZUF2YWlsYWJsZSwgc3RvcmVLZXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-utils/node_modules/@toruslabs/constants/dist/constants.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/node_modules/@toruslabs/constants/dist/constants.esm.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER: () => (/* binding */ SESSION_SERVER),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   abi: () => (/* binding */ abi)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  AQUA: \"aqua\",\n  CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n  SAPPHIRE_DEVNET: \"sapphire_devnet\",\n  SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [\n  // TORUS_LEGACY_NETWORK.AQUA,\n  // TORUS_LEGACY_NETWORK.CELESTE,\n  // TORUS_LEGACY_NETWORK.CYAN,\n];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n  [TORUS_LEGACY_NETWORK.AQUA]: {\n    migrationCompleted: true,\n    networkIdentifier: \"aqua\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CELESTE]: {\n    migrationCompleted: true,\n    networkIdentifier: \"celeste\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CYAN]: {\n    migrationCompleted: true,\n    networkIdentifier: \"cyan\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.MAINNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"mainnet\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.TESTNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"teal\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n  }\n};\nconst NETWORK_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\n\nconst abi = [{\n  inputs: [{\n    internalType: \"string\",\n    name: \"_verifier\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"hashedVerifierId\",\n    type: \"bytes32\"\n  }],\n  name: \"getNodeSet\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"currentEpoch\",\n    type: \"uint256\"\n  }, {\n    internalType: \"string[]\",\n    name: \"torusNodeEndpoints\",\n    type: \"string[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusNodePubX\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusNodePubY\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusIndexes\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvY29uc3RhbnRzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVvTiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvY29uc3RhbnRzLmVzbS5qcz85NzhhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFRPUlVTX0xFR0FDWV9ORVRXT1JLID0ge1xuICBNQUlOTkVUOiBcIm1haW5uZXRcIixcbiAgVEVTVE5FVDogXCJ0ZXN0bmV0XCIsXG4gIENZQU46IFwiY3lhblwiLFxuICBBUVVBOiBcImFxdWFcIixcbiAgQ0VMRVNURTogXCJjZWxlc3RlXCJcbn07XG5jb25zdCBUT1JVU19TQVBQSElSRV9ORVRXT1JLID0ge1xuICBTQVBQSElSRV9ERVZORVQ6IFwic2FwcGhpcmVfZGV2bmV0XCIsXG4gIFNBUFBISVJFX01BSU5ORVQ6IFwic2FwcGhpcmVfbWFpbm5ldFwiXG59O1xuY29uc3QgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUyA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcIjB4ZjIwMzM2ZTE2QjUxODI2MzdmMDk4MjFjMjdCRGUyOWIwQUZjZmU4MFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiMHhkMDg0NjA0ZTVGQTM4N0ZiQzJEYThiQWFiMDdmREQ2YURFRDQ2MTRBXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCIweDlmMDcyYmExOWIzMzcwZTUxMmFhMWI0YmZjZGFmOTcyODMxNjgwMDVcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcIjB4MjlEZWE4MmEwNTA5MTUzYjkxMDQwZWUxM2NEQmJhMGYwM2VmYjYyNVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiMHg2QmZmYjRlODk0NTMwNjlFNzQ4N2YwZmE1YzlmNGEyRDc3MWNjZTZjXCJcbn07XG5jb25zdCBNVUxUSV9DTFVTVEVSX05FVFdPUktTID0gW1xuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOLFxuXTtcbmNvbnN0IExFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJhcXVhXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiY2VsZXN0ZVwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImN5YW5cIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJtYWlubmV0XCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwidGVhbFwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVFxuICB9XG59O1xuY29uc3QgTkVUV09SS19NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJtYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJnb2VybGlcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwicG9seWdvbi1tYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCJwb2x5Z29uLW1haW5uZXRcIlxufTtcbmNvbnN0IFNJR05FUl9NQVAgPSB7XG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgTUVUQURBVEFfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgRk5EX1NFUlZFUiA9IFwiaHR0cHM6Ly9mbmQud2ViM2F1dGguaW9cIjtcbmNvbnN0IFNFU1NJT05fU0VSVkVSID0gXCJodHRwczovL3Nlc3Npb24ud2ViM2F1dGguaW9cIjtcbmNvbnN0IEtFWV9UWVBFID0ge1xuICBTRUNQMjU2SzE6IFwic2VjcDI1NmsxXCIsXG4gIEVEMjU1MTk6IFwiZWQyNTUxOVwiXG59O1xuXG5jb25zdCBhYmkgPSBbe1xuICBpbnB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgIG5hbWU6IFwiX3ZlcmlmaWVyXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICBuYW1lOiBcImhhc2hlZFZlcmlmaWVySWRcIixcbiAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICB9XSxcbiAgbmFtZTogXCJnZXROb2RlU2V0XCIsXG4gIG91dHB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICBuYW1lOiBcImN1cnJlbnRFcG9jaFwiLFxuICAgIHR5cGU6IFwidWludDI1NlwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nW11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZUVuZHBvaW50c1wiLFxuICAgIHR5cGU6IFwic3RyaW5nW11cIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNOb2RlUHViWFwiLFxuICAgIHR5cGU6IFwidWludDI1NltdXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2W11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZVB1YllcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NltdXCIsXG4gICAgbmFtZTogXCJ0b3J1c0luZGV4ZXNcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH1dLFxuICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICB0eXBlOiBcImZ1bmN0aW9uXCJcbn1dO1xuXG5leHBvcnQgeyBGTkRfU0VSVkVSLCBLRVlfVFlQRSwgTEVHQUNZX05FVFdPUktTX1JPVVRFX01BUCwgTUVUQURBVEFfTUFQLCBNVUxUSV9DTFVTVEVSX05FVFdPUktTLCBORVRXT1JLX01BUCwgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUywgU0VTU0lPTl9TRVJWRVIsIFNJR05FUl9NQVAsIFRPUlVTX0xFR0FDWV9ORVRXT1JLLCBUT1JVU19TQVBQSElSRV9ORVRXT1JLLCBhYmkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-utils/node_modules/@toruslabs/constants/dist/constants.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/dist/openlogin.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/dist/openlogin.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InitializationError: () => (/* binding */ InitializationError),\n/* harmony export */   LoginError: () => (/* binding */ LoginError),\n/* harmony export */   OpenloginError: () => (/* binding */ OpenloginError),\n/* harmony export */   constructURL: () => (/* binding */ constructURL),\n/* harmony export */   \"default\": () => (/* binding */ OpenLogin),\n/* harmony export */   getHashQueryParams: () => (/* binding */ getHashQueryParams),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   getTimeout: () => (/* binding */ getTimeout),\n/* harmony export */   isMobileOrTablet: () => (/* binding */ isMobileOrTablet),\n/* harmony export */   loglevel: () => (/* binding */ loglevel),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   whitelistUrl: () => (/* binding */ whitelistUrl)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ts_custom_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ts-custom-error */ \"(ssr)/./node_modules/ts-custom-error/dist/custom-error.mjs\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _toruslabs_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/constants */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/constants/dist/constants.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_session_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @toruslabs/openlogin-session-manager */ \"(ssr)/./node_modules/@toruslabs/openlogin-session-manager/dist/openloginSessionManager.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var _toruslabs_secure_pub_sub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @toruslabs/secure-pub-sub */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/secure-pub-sub/dist/securePubSub.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! bowser */ \"(ssr)/./node_modules/bowser/src/bowser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass OpenloginError extends ts_custom_error__WEBPACK_IMPORTED_MODULE_1__.CustomError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(message);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"message\", void 0);\n    this.code = code;\n    this.message = message || \"\";\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", {\n      value: \"OpenloginError\"\n    });\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message\n    };\n  }\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\nclass InitializationError extends OpenloginError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(code, message);\n\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", {\n      value: \"InitializationError\"\n    });\n  }\n  static fromCode(code) {\n    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new InitializationError(code, `${InitializationError.messages[code]}, ${extraMessage}`);\n  }\n  static invalidParams() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return InitializationError.fromCode(5001, extraMessage);\n  }\n  static notInitialized() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return InitializationError.fromCode(5002, extraMessage);\n  }\n}\n\n/**\n * login errors\n */\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(InitializationError, \"messages\", {\n  5000: \"Custom\",\n  5001: \"Invalid constructor params\",\n  5002: \"SDK not initialized. please call init first\"\n});\nclass LoginError extends OpenloginError {\n  constructor(code, message) {\n    // takes care of stack and proto\n    super(code, message);\n\n    // Set name explicitly as minification can mangle class names\n    Object.defineProperty(this, \"name\", {\n      value: \"LoginError\"\n    });\n  }\n  static fromCode(code) {\n    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    return new LoginError(code, `${LoginError.messages[code]}, ${extraMessage}`);\n  }\n  static invalidLoginParams() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5111, extraMessage);\n  }\n  static userNotLoggedIn() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5112, extraMessage);\n  }\n  static popupClosed() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5113, extraMessage);\n  }\n  static loginFailed() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5114, extraMessage);\n  }\n  static popupBlocked() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5115, extraMessage);\n  }\n  static mfaAlreadyEnabled() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5116, extraMessage);\n  }\n  static mfaNotEnabled() {\n    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return LoginError.fromCode(5117, extraMessage);\n  }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(LoginError, \"messages\", {\n  5000: \"Custom\",\n  5111: \"Invalid login params\",\n  5112: \"User not logged in.\",\n  5113: \"login popup has been closed by the user\",\n  5114: \"Login failed\",\n  5115: \"Popup was blocked. Please call this function as soon as user clicks button or use redirect mode\",\n  5116: \"MFA already enabled\",\n  5117: \"MFA not yet enabled. Please call `enableMFA` first\"\n});\n\nconst loglevel = (0,loglevel__WEBPACK_IMPORTED_MODULE_2__.getLogger)(\"openlogin\");\nloglevel.setLevel(\"error\");\n\n// don't use destructuring for process.env cause it messes up webpack env plugin\nconst version = \"8.2.1\";\nasync function whitelistUrl(clientId, appKey, origin) {\n  const appKeyBuf = Buffer.from(appKey.padStart(64, \"0\"), \"hex\");\n  if (_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.base64url.encode((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_9__.getPublic)(appKeyBuf)) !== clientId) throw new Error(\"appKey mismatch\");\n  const sig = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_9__.sign)(appKeyBuf, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_10__.keccak256)(Buffer.from(origin, \"utf8\")));\n  return _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.base64url.encode(sig);\n}\nfunction getHashQueryParams() {\n  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const result = {};\n  const queryUrlParams = new URLSearchParams(window.location.search.slice(1));\n  queryUrlParams.forEach((value, key) => {\n    if (key !== \"b64Params\") {\n      result[key] = value;\n    }\n  });\n  const queryResult = queryUrlParams.get(\"b64Params\");\n  if (queryResult) {\n    try {\n      const queryParams = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(queryResult));\n      Object.keys(queryParams).forEach(key => {\n        result[key] = queryParams[key];\n      });\n    } catch (error) {\n      loglevel.error(error);\n    }\n  }\n  const hashUrlParams = new URLSearchParams(window.location.hash.substring(1));\n  hashUrlParams.forEach((value, key) => {\n    if (key !== \"b64Params\") {\n      result[key] = value;\n    }\n  });\n  const hashResult = hashUrlParams.get(\"b64Params\");\n  if (hashResult) {\n    try {\n      const hashParams = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(hashResult));\n      Object.keys(hashParams).forEach(key => {\n        result[key] = hashParams[key];\n      });\n    } catch (error) {\n      loglevel.error(error);\n    }\n  }\n  if (replaceUrl) {\n    const cleanUrl = new URL(window.location.origin + window.location.pathname);\n    // https://dapp.com/#b64Params=asacsdnvdfv&state=sldjvndfkjvn&dappValue=sdjvndf\n    if (queryUrlParams.size > 0) {\n      queryUrlParams.delete(\"error\");\n      queryUrlParams.delete(\"state\");\n      queryUrlParams.delete(\"b64Params\");\n      queryUrlParams.delete(\"sessionNamespace\");\n      cleanUrl.search = queryUrlParams.toString();\n    }\n    if (hashUrlParams.size > 0) {\n      hashUrlParams.delete(\"error\");\n      hashUrlParams.delete(\"state\");\n      hashUrlParams.delete(\"b64Params\");\n      hashUrlParams.delete(\"sessionNamespace\");\n      cleanUrl.hash = hashUrlParams.toString();\n    }\n    window.history.replaceState(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, window.history.state), {}, {\n      as: cleanUrl.href,\n      url: cleanUrl.href\n    }), \"\", cleanUrl.href);\n  }\n  return result;\n}\nfunction constructURL(params) {\n  const {\n    baseURL,\n    query,\n    hash\n  } = params;\n  const url = new URL(baseURL);\n  if (query) {\n    Object.keys(query).forEach(key => {\n      url.searchParams.append(key, query[key]);\n    });\n  }\n  if (hash) {\n    const h = new URL(constructURL({\n      baseURL,\n      query: hash\n    })).searchParams.toString();\n    url.hash = h;\n  }\n  return url.toString();\n}\nfunction getPopupFeatures() {\n  if (typeof window === \"undefined\") return \"\";\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n  return features;\n}\nfunction isMobileOrTablet() {\n  if (typeof window === \"undefined\") return false;\n  const browser = bowser__WEBPACK_IMPORTED_MODULE_11__[\"default\"].getParser(window.navigator.userAgent);\n  const platform = browser.getPlatform();\n  return platform.type === bowser__WEBPACK_IMPORTED_MODULE_11__[\"default\"].PLATFORMS_MAP.tablet || platform.type === bowser__WEBPACK_IMPORTED_MODULE_11__[\"default\"].PLATFORMS_MAP.mobile;\n}\nfunction getTimeout(loginProvider) {\n  if ((loginProvider === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.LOGIN_PROVIDER.FACEBOOK || loginProvider === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.LOGIN_PROVIDER.LINE) && isMobileOrTablet()) {\n    return 1000 * 60 * 5; // 5 minutes to finish the login\n  }\n  return 1000 * 10; // 10 seconds\n}\n\nclass PopupHandler extends events__WEBPACK_IMPORTED_MODULE_8__.EventEmitter {\n  constructor(_ref) {\n    let {\n      url,\n      target,\n      features,\n      timeout = 30000\n    } = _ref;\n    super();\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"url\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"target\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"features\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"window\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"windowTimer\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"iClosedWindow\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"timeout\", void 0);\n    this.url = url;\n    this.target = target || \"_blank\";\n    this.features = features || getPopupFeatures();\n    this.window = undefined;\n    this.windowTimer = undefined;\n    this.iClosedWindow = false;\n    this.timeout = timeout;\n    this._setupTimer();\n  }\n  _setupTimer() {\n    this.windowTimer = Number(setInterval(() => {\n      if (this.window && this.window.closed) {\n        clearInterval(this.windowTimer);\n        setTimeout(() => {\n          if (!this.iClosedWindow) {\n            this.emit(\"close\");\n          }\n          this.iClosedWindow = false;\n          this.window = undefined;\n        }, this.timeout);\n      }\n      if (this.window === undefined) clearInterval(this.windowTimer);\n    }, 500));\n  }\n  open() {\n    var _this$window;\n    this.window = window.open(this.url, this.target, this.features);\n    if (!this.window) throw LoginError.popupBlocked();\n    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();\n  }\n  close() {\n    this.iClosedWindow = true;\n    if (this.window) this.window.close();\n  }\n  redirect(locationReplaceOnRedirect) {\n    if (locationReplaceOnRedirect) {\n      window.location.replace(this.url);\n    } else {\n      window.location.href = this.url;\n    }\n  }\n  async listenOnChannel(loginId) {\n    const securePubSub = new _toruslabs_secure_pub_sub__WEBPACK_IMPORTED_MODULE_7__.SecurePubSub();\n    const data = await securePubSub.subscribe(loginId);\n    this.close();\n    securePubSub.cleanup();\n    const parsedData = JSON.parse(data);\n    if (parsedData.error) {\n      return {\n        error: parsedData.error,\n        state: parsedData.state\n      };\n    }\n    return parsedData.data;\n  }\n}\n\nclass OpenLogin {\n  constructor(options) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"state\", {});\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"options\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"sessionManager\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"currentStorage\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_storageBaseKey\", \"openlogin_store\");\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"dappState\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"addVersionInUrls\", true);\n    if (!options.clientId) throw InitializationError.invalidParams(\"clientId is required\");\n    if (!options.network) options.network = _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_NETWORK.SAPPHIRE_MAINNET;\n    if (!options.buildEnv) options.buildEnv = _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.PRODUCTION;\n    if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.DEVELOPMENT || options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.TESTING || options.sdkUrl) this.addVersionInUrls = false;\n    if (!options.sdkUrl && !options.useMpc) {\n      if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.DEVELOPMENT) {\n        options.sdkUrl = \"http://localhost:3000\";\n        options.dashboardUrl = \"http://localhost:5173/wallet/account\";\n      } else if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.STAGING) {\n        options.sdkUrl = \"https://staging-auth.web3auth.io\";\n        options.dashboardUrl = \"https://staging-account.web3auth.io/wallet/account\";\n      } else if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.TESTING) {\n        options.sdkUrl = \"https://develop-auth.web3auth.io\";\n        options.dashboardUrl = \"https://develop-account.web3auth.io/wallet/account\";\n      } else {\n        options.sdkUrl = \"https://auth.web3auth.io\";\n        options.dashboardUrl = \"https://account.web3auth.io/wallet/account\";\n      }\n    }\n    if (options.useMpc && !options.sdkUrl) {\n      if (Object.values(_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.TORUS_LEGACY_NETWORK).includes(options.network)) throw InitializationError.invalidParams(\"MPC is not supported on legacy networks, please use sapphire_devnet or sapphire_mainnet.\");\n      if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.DEVELOPMENT) {\n        options.sdkUrl = \"http://localhost:3000\";\n      } else if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.STAGING) {\n        options.sdkUrl = \"https://staging-mpc-auth.web3auth.io\";\n      } else if (options.buildEnv === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.TESTING) {\n        options.sdkUrl = \"https://develop-mpc-auth.web3auth.io\";\n      } else {\n        options.sdkUrl = \"https://mpc-auth.web3auth.io\";\n      }\n    }\n    if (!options.redirectUrl && typeof window !== \"undefined\") {\n      options.redirectUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;\n    }\n    if (!options.uxMode) options.uxMode = _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT;\n    if (typeof options.replaceUrlOnRedirect !== \"boolean\") options.replaceUrlOnRedirect = true;\n    if (!options.originData) options.originData = {};\n    if (!options.whiteLabel) options.whiteLabel = {};\n    if (!options.loginConfig) options.loginConfig = {};\n    if (!options.mfaSettings) options.mfaSettings = {};\n    if (!options.storageServerUrl) options.storageServerUrl = _toruslabs_constants__WEBPACK_IMPORTED_MODULE_4__.SESSION_SERVER;\n    if (!options.storageKey) options.storageKey = \"local\";\n    if (!options.webauthnTransports) options.webauthnTransports = [\"internal\"];\n    if (!options.sessionTime) options.sessionTime = 86400;\n    this.options = options;\n  }\n  get privKey() {\n    if (this.options.useMpc) return this.state.factorKey || \"\";\n    return this.state.privKey ? this.state.privKey.padStart(64, \"0\") : \"\";\n  }\n  get coreKitKey() {\n    return this.state.coreKitKey ? this.state.coreKitKey.padStart(64, \"0\") : \"\";\n  }\n  get ed25519PrivKey() {\n    return this.state.ed25519PrivKey ? this.state.ed25519PrivKey.padStart(128, \"0\") : \"\";\n  }\n  get coreKitEd25519Key() {\n    return this.state.coreKitEd25519PrivKey ? this.state.coreKitEd25519PrivKey.padStart(128, \"0\") : \"\";\n  }\n  get sessionId() {\n    return this.state.sessionId || \"\";\n  }\n  get sessionNamespace() {\n    return this.options.sessionNamespace || \"\";\n  }\n  get appState() {\n    return this.state.userInfo.appState || this.dappState || \"\";\n  }\n  get baseUrl() {\n    // testing and develop don't have versioning\n    if (!this.addVersionInUrls) return `${this.options.sdkUrl}`;\n    return `${this.options.sdkUrl}/v${version.split(\".\")[0]}`;\n  }\n  async init() {\n    // get sessionNamespace from the redirect result.\n    const params = getHashQueryParams(this.options.replaceUrlOnRedirect);\n    if (params.sessionNamespace) this.options.sessionNamespace = params.sessionNamespace;\n    const storageKey = this.options.sessionNamespace ? `${this._storageBaseKey}_${this.options.sessionNamespace}` : this._storageBaseKey;\n    this.currentStorage = _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BrowserStorage.getInstance(storageKey, this.options.storageKey);\n    const sessionId = this.currentStorage.get(\"sessionId\");\n    this.sessionManager = new _toruslabs_openlogin_session_manager__WEBPACK_IMPORTED_MODULE_5__.OpenloginSessionManager({\n      sessionServerBaseUrl: this.options.storageServerUrl,\n      sessionNamespace: this.options.sessionNamespace,\n      sessionTime: this.options.sessionTime,\n      sessionId\n    });\n    if (this.options.network === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_NETWORK.TESTNET || this.options.network === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_NETWORK.SAPPHIRE_DEVNET) {\n      // using console log because it shouldn't be affected by loglevel config\n      // eslint-disable-next-line no-console\n      console.log(`%c WARNING! You are on ${this.options.network}. Please set network: 'mainnet' or 'sapphire_mainnet' in production`, \"color: #FF0000\");\n    }\n    if (this.options.buildEnv !== _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.BUILD_ENV.PRODUCTION) {\n      // using console log because it shouldn't be affected by loglevel config\n      // eslint-disable-next-line no-console\n      console.log(`%c WARNING! You are using build env ${this.options.buildEnv}. Please set buildEnv: 'production' in production`, \"color: #FF0000\");\n    }\n    if (params.error) {\n      this.dappState = params.state;\n      throw LoginError.loginFailed(params.error);\n    }\n    if (params.sessionId) {\n      this.currentStorage.set(\"sessionId\", params.sessionId);\n      this.sessionManager.sessionId = params.sessionId;\n    }\n    if (this.sessionManager.sessionId) {\n      const data = await this._authorizeSession();\n      // Fill state with correct info from session\n      // If session is invalid all the data is unset here.\n      this.updateState(data);\n      if (Object.keys(data).length === 0) {\n        // If session is invalid, unset the sessionId from localStorage.\n        this.currentStorage.set(\"sessionId\", \"\");\n      }\n    }\n  }\n  async login(params) {\n    if (!params.loginProvider) throw LoginError.invalidLoginParams(`loginProvider is required`);\n\n    // in case of redirect mode, redirect url will be dapp specified\n    // in case of popup mode, redirect url will be sdk specified\n    const defaultParams = {\n      redirectUrl: this.options.redirectUrl\n    };\n    const loginParams = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({\n      loginProvider: params.loginProvider\n    }, defaultParams), params);\n    const dataObject = {\n      actionType: _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_ACTIONS.LOGIN,\n      options: this.options,\n      params: loginParams\n    };\n    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(params.loginProvider));\n    if (this.options.uxMode === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT) return null;\n    if (result.error) {\n      this.dappState = result.state;\n      throw LoginError.loginFailed(result.error);\n    }\n    this.sessionManager.sessionId = result.sessionId;\n    this.options.sessionNamespace = result.sessionNamespace;\n    this.currentStorage.set(\"sessionId\", result.sessionId);\n    await this.rehydrateSession();\n    return {\n      privKey: this.privKey\n    };\n  }\n  async logout() {\n    if (!this.sessionManager.sessionId) throw LoginError.userNotLoggedIn();\n    await this.sessionManager.invalidateSession();\n    this.updateState({\n      privKey: \"\",\n      coreKitKey: \"\",\n      coreKitEd25519PrivKey: \"\",\n      ed25519PrivKey: \"\",\n      walletKey: \"\",\n      oAuthPrivateKey: \"\",\n      tKey: \"\",\n      metadataNonce: \"\",\n      keyMode: undefined,\n      userInfo: {\n        name: \"\",\n        profileImage: \"\",\n        dappShare: \"\",\n        idToken: \"\",\n        oAuthIdToken: \"\",\n        oAuthAccessToken: \"\",\n        appState: \"\",\n        email: \"\",\n        verifier: \"\",\n        verifierId: \"\",\n        aggregateVerifier: \"\",\n        typeOfLogin: \"\",\n        isMfaEnabled: false\n      },\n      authToken: \"\",\n      sessionId: \"\",\n      factorKey: \"\",\n      signatures: [],\n      tssShareIndex: -1,\n      tssPubKey: \"\",\n      tssShare: \"\",\n      tssNonce: -1\n    });\n    this.currentStorage.set(\"sessionId\", \"\");\n  }\n  async enableMFA(params) {\n    var _this$state$userInfo;\n    if (!this.sessionId) throw LoginError.userNotLoggedIn();\n    if (this.state.userInfo.isMfaEnabled) throw LoginError.mfaAlreadyEnabled();\n    // in case of redirect mode, redirect url will be dapp specified\n    // in case of popup mode, redirect url will be sdk specified\n    const defaultParams = {\n      redirectUrl: this.options.redirectUrl\n    };\n    const dataObject = {\n      actionType: _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_ACTIONS.ENABLE_MFA,\n      options: this.options,\n      params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, defaultParams), params), {}, {\n        loginProvider: this.state.userInfo.typeOfLogin,\n        extraLoginOptions: {\n          login_hint: this.state.userInfo.verifierId\n        },\n        mfaLevel: \"mandatory\"\n      }),\n      sessionId: this.sessionId\n    };\n    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject, getTimeout(dataObject.params.loginProvider));\n    if (this.options.uxMode === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT) return null;\n    if (result.error) {\n      this.dappState = result.state;\n      throw LoginError.loginFailed(result.error);\n    }\n    this.sessionManager.sessionId = result.sessionId;\n    this.options.sessionNamespace = result.sessionNamespace;\n    this.currentStorage.set(\"sessionId\", result.sessionId);\n    await this.rehydrateSession();\n    return Boolean((_this$state$userInfo = this.state.userInfo) === null || _this$state$userInfo === void 0 ? void 0 : _this$state$userInfo.isMfaEnabled);\n  }\n  async manageMFA(params) {\n    if (!this.sessionId) throw LoginError.userNotLoggedIn();\n    if (!this.state.userInfo.isMfaEnabled) throw LoginError.mfaNotEnabled();\n\n    // in case of redirect mode, redirect url will be dapp specified\n    // in case of popup mode, redirect url will be sdk specified\n    const defaultParams = {\n      redirectUrl: this.options.dashboardUrl,\n      dappUrl: `${window.location.origin}${window.location.pathname}`\n    };\n    const loginId = _toruslabs_openlogin_session_manager__WEBPACK_IMPORTED_MODULE_5__.OpenloginSessionManager.generateRandomSessionKey();\n    const dataObject = {\n      actionType: _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_ACTIONS.MANAGE_MFA,\n      options: this.options,\n      params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, defaultParams), params), {}, {\n        loginProvider: this.state.userInfo.typeOfLogin,\n        extraLoginOptions: {\n          login_hint: this.state.userInfo.verifierId\n        },\n        appState: (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.jsonToBase64)({\n          loginId\n        })\n      }),\n      sessionId: this.sessionId\n    };\n    this.createLoginSession(loginId, dataObject, dataObject.options.sessionTime, true);\n    const configParams = {\n      loginId,\n      sessionNamespace: this.options.sessionNamespace,\n      storageServerUrl: this.options.storageServerUrl\n    };\n    const loginUrl = constructURL({\n      baseURL: `${this.baseUrl}/start`,\n      hash: {\n        b64Params: (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.jsonToBase64)(configParams)\n      }\n    });\n    window.open(loginUrl, \"_blank\");\n  }\n  async changeSocialFactor(params) {\n    if (!this.sessionId) throw LoginError.userNotLoggedIn();\n\n    // in case of redirect mode, redirect url will be dapp specified\n    // in case of popup mode, redirect url will be sdk specified\n    const defaultParams = {\n      redirectUrl: this.options.redirectUrl\n    };\n    const dataObject = {\n      actionType: _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.OPENLOGIN_ACTIONS.MODIFY_SOCIAL_FACTOR,\n      options: this.options,\n      params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, defaultParams), params),\n      sessionId: this.sessionId\n    };\n    const result = await this.openloginHandler(`${this.baseUrl}/start`, dataObject);\n    if (this.options.uxMode === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT) return undefined;\n    if (result.error) return false;\n    return true;\n  }\n  getUserInfo() {\n    if (!this.sessionManager.sessionId) {\n      throw LoginError.userNotLoggedIn();\n    }\n    return this.state.userInfo;\n  }\n  async createLoginSession(loginId, data) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 600;\n    let skipAwait = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!this.sessionManager) throw InitializationError.notInitialized();\n    const loginSessionMgr = new _toruslabs_openlogin_session_manager__WEBPACK_IMPORTED_MODULE_5__.OpenloginSessionManager({\n      sessionServerBaseUrl: data.options.storageServerUrl,\n      sessionNamespace: data.options.sessionNamespace,\n      sessionTime: timeout,\n      // each login key must be used with 10 mins (might be used at the end of popup redirect)\n      sessionId: loginId\n    });\n    const promise = loginSessionMgr.createSession(JSON.parse(JSON.stringify(data)));\n    if (data.options.uxMode === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT && !skipAwait) {\n      await promise;\n    }\n  }\n  async _authorizeSession() {\n    try {\n      if (!this.sessionManager.sessionId) return {};\n      const result = await this.sessionManager.authorizeSession();\n      return result;\n    } catch (err) {\n      loglevel.error(\"authorization failed\", err);\n      return {};\n    }\n  }\n  updateState(data) {\n    this.state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, this.state), data);\n  }\n  async rehydrateSession() {\n    const result = await this._authorizeSession();\n    this.updateState(result);\n  }\n  async openloginHandler(url, dataObject) {\n    let popupTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000 * 10;\n    const loginId = _toruslabs_openlogin_session_manager__WEBPACK_IMPORTED_MODULE_5__.OpenloginSessionManager.generateRandomSessionKey();\n    await this.createLoginSession(loginId, dataObject);\n    const configParams = {\n      loginId,\n      sessionNamespace: this.options.sessionNamespace,\n      storageServerUrl: this.options.storageServerUrl\n    };\n    if (this.options.uxMode === _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.UX_MODE.REDIRECT) {\n      const loginUrl = constructURL({\n        baseURL: url,\n        hash: {\n          b64Params: (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.jsonToBase64)(configParams)\n        }\n      });\n      window.location.href = loginUrl;\n      return undefined;\n    }\n    const loginUrl = constructURL({\n      baseURL: url,\n      hash: {\n        b64Params: (0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.jsonToBase64)(configParams)\n      }\n    });\n    const currentWindow = new PopupHandler({\n      url: loginUrl,\n      timeout: popupTimeout\n    });\n    return new Promise((resolve, reject) => {\n      currentWindow.on(\"close\", () => {\n        reject(LoginError.popupClosed());\n      });\n      currentWindow.listenOnChannel(loginId).then(resolve).catch(reject);\n      try {\n        currentWindow.open();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vZGlzdC9vcGVubG9naW4uZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDdEI7QUFDVDtBQUM0QjtBQUNYO0FBQ3lCO0FBQ2dIO0FBQ3RJO0FBQ25CO0FBQ2dCO0FBQ0U7QUFDNUI7O0FBRTVCLDZCQUE2Qix3REFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1DQUFtQyxJQUFJLGFBQWE7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsSUFBSSxhQUFhO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUJBQWlCLG1EQUFTO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpRUFBUyxRQUFRLDhEQUFTO0FBQ2hDLG9CQUFvQix5REFBSSxZQUFZLHVFQUFTO0FBQzdDLFNBQVMsaUVBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvRUFBUTtBQUM3QztBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBUTtBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJFQUFhLENBQUMsMkVBQWEsR0FBRywyQkFBMkI7QUFDekY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxnRkFBZ0YsZUFBZSxTQUFTLGVBQWUsT0FBTyxJQUFJLFFBQVEsS0FBSztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBTTtBQUN4QjtBQUNBLDJCQUEyQiwrQ0FBTSwyQ0FBMkMsK0NBQU07QUFDbEY7QUFDQTtBQUNBLHlCQUF5QixzRUFBYywrQkFBK0Isc0VBQWM7QUFDcEYsMEJBQTBCO0FBQzFCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLDJCQUEyQixnREFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtRUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw0RUFBZSxrQkFBa0I7QUFDckMsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkIsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkI7QUFDQSw0Q0FBNEMseUVBQWlCO0FBQzdELDhDQUE4QyxpRUFBUztBQUN2RCw2QkFBNkIsaUVBQVMscUNBQXFDLGlFQUFTO0FBQ3BGO0FBQ0EsK0JBQStCLGlFQUFTO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLDhCQUE4QixpRUFBUztBQUMvQztBQUNBO0FBQ0EsUUFBUSw4QkFBOEIsaUVBQVM7QUFDL0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRFQUFvQjtBQUM1QywrQkFBK0IsaUVBQVM7QUFDeEM7QUFDQSxRQUFRLDhCQUE4QixpRUFBUztBQUMvQztBQUNBLFFBQVEsOEJBQThCLGlFQUFTO0FBQy9DO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QixJQUFJLHFCQUFxQixFQUFFLHlCQUF5QjtBQUM1RztBQUNBLDBDQUEwQywrREFBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdFQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlELGNBQWMsb0JBQW9CLElBQUksc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscUJBQXFCLEdBQUcsOEJBQThCO0FBQ2hILDBCQUEwQixzRUFBYztBQUN4QztBQUNBLDhCQUE4Qix5RkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLHlFQUFpQixxQ0FBcUMseUVBQWlCO0FBQ3hHO0FBQ0E7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFO0FBQ0Esa0NBQWtDLGlFQUFTO0FBQzNDO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkVBQWEsQ0FBQywyRUFBYTtBQUNuRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQix5RUFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0QsZ0NBQWdDLCtEQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBaUI7QUFDbkM7QUFDQSxjQUFjLDJFQUFhLENBQUMsMkVBQWEsQ0FBQywyRUFBYSxHQUFHLDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGdDQUFnQywrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUIsRUFBRSx5QkFBeUI7QUFDcEU7QUFDQSxvQkFBb0IseUZBQXVCO0FBQzNDO0FBQ0Esa0JBQWtCLHlFQUFpQjtBQUNuQztBQUNBLGNBQWMsMkVBQWEsQ0FBQywyRUFBYSxDQUFDLDJFQUFhLEdBQUcsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0Isd0VBQVk7QUFDOUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0EsbUJBQW1CLHdFQUFZO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5RUFBaUI7QUFDbkM7QUFDQSxjQUFjLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUM1QztBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0QsZ0NBQWdDLCtEQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlGQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLCtEQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUZBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0VBQVk7QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdFQUFZO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFb00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luL2Rpc3Qvb3BlbmxvZ2luLmVzbS5qcz80ZjEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBDdXN0b21FcnJvciB9IGZyb20gJ3RzLWN1c3RvbS1lcnJvcic7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IHsgU0VTU0lPTl9TRVJWRVIgfSBmcm9tICdAdG9ydXNsYWJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBPcGVubG9naW5TZXNzaW9uTWFuYWdlciB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLXNlc3Npb24tbWFuYWdlcic7XG5pbXBvcnQgeyBiYXNlNjR1cmwsIHNhZmVhdG9iLCBMT0dJTl9QUk9WSURFUiwgT1BFTkxPR0lOX05FVFdPUkssIEJVSUxEX0VOViwgVE9SVVNfTEVHQUNZX05FVFdPUkssIFVYX01PREUsIEJyb3dzZXJTdG9yYWdlLCBPUEVOTE9HSU5fQUNUSU9OUywganNvblRvQmFzZTY0IH0gZnJvbSAnQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMnO1xuaW1wb3J0IHsgU2VjdXJlUHViU3ViIH0gZnJvbSAnQHRvcnVzbGFicy9zZWN1cmUtcHViLXN1Yic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgZ2V0UHVibGljLCBzaWduIH0gZnJvbSAnQHRvcnVzbGFicy9lY2NyeXB0byc7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tICdAdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMnO1xuaW1wb3J0IGJvd3NlciBmcm9tICdib3dzZXInO1xuXG5jbGFzcyBPcGVubG9naW5FcnJvciBleHRlbmRzIEN1c3RvbUVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIC8vIHRha2VzIGNhcmUgb2Ygc3RhY2sgYW5kIHByb3RvXG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJcIjtcbiAgICAvLyBTZXQgbmFtZSBleHBsaWNpdGx5IGFzIG1pbmlmaWNhdGlvbiBjYW4gbWFuZ2xlIGNsYXNzIG5hbWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogXCJPcGVubG9naW5FcnJvclwiXG4gICAgfSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfVxufVxuY2xhc3MgSW5pdGlhbGl6YXRpb25FcnJvciBleHRlbmRzIE9wZW5sb2dpbkVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIC8vIHRha2VzIGNhcmUgb2Ygc3RhY2sgYW5kIHByb3RvXG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSk7XG5cbiAgICAvLyBTZXQgbmFtZSBleHBsaWNpdGx5IGFzIG1pbmlmaWNhdGlvbiBjYW4gbWFuZ2xlIGNsYXNzIG5hbWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogXCJJbml0aWFsaXphdGlvbkVycm9yXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbUNvZGUoY29kZSkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgcmV0dXJuIG5ldyBJbml0aWFsaXphdGlvbkVycm9yKGNvZGUsIGAke0luaXRpYWxpemF0aW9uRXJyb3IubWVzc2FnZXNbY29kZV19LCAke2V4dHJhTWVzc2FnZX1gKTtcbiAgfVxuICBzdGF0aWMgaW52YWxpZFBhcmFtcygpIHtcbiAgICBsZXQgZXh0cmFNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgIHJldHVybiBJbml0aWFsaXphdGlvbkVycm9yLmZyb21Db2RlKDUwMDEsIGV4dHJhTWVzc2FnZSk7XG4gIH1cbiAgc3RhdGljIG5vdEluaXRpYWxpemVkKCkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgcmV0dXJuIEluaXRpYWxpemF0aW9uRXJyb3IuZnJvbUNvZGUoNTAwMiwgZXh0cmFNZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIGxvZ2luIGVycm9yc1xuICovXG5fZGVmaW5lUHJvcGVydHkoSW5pdGlhbGl6YXRpb25FcnJvciwgXCJtZXNzYWdlc1wiLCB7XG4gIDUwMDA6IFwiQ3VzdG9tXCIsXG4gIDUwMDE6IFwiSW52YWxpZCBjb25zdHJ1Y3RvciBwYXJhbXNcIixcbiAgNTAwMjogXCJTREsgbm90IGluaXRpYWxpemVkLiBwbGVhc2UgY2FsbCBpbml0IGZpcnN0XCJcbn0pO1xuY2xhc3MgTG9naW5FcnJvciBleHRlbmRzIE9wZW5sb2dpbkVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIC8vIHRha2VzIGNhcmUgb2Ygc3RhY2sgYW5kIHByb3RvXG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSk7XG5cbiAgICAvLyBTZXQgbmFtZSBleHBsaWNpdGx5IGFzIG1pbmlmaWNhdGlvbiBjYW4gbWFuZ2xlIGNsYXNzIG5hbWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogXCJMb2dpbkVycm9yXCJcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbUNvZGUoY29kZSkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgcmV0dXJuIG5ldyBMb2dpbkVycm9yKGNvZGUsIGAke0xvZ2luRXJyb3IubWVzc2FnZXNbY29kZV19LCAke2V4dHJhTWVzc2FnZX1gKTtcbiAgfVxuICBzdGF0aWMgaW52YWxpZExvZ2luUGFyYW1zKCkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgcmV0dXJuIExvZ2luRXJyb3IuZnJvbUNvZGUoNTExMSwgZXh0cmFNZXNzYWdlKTtcbiAgfVxuICBzdGF0aWMgdXNlck5vdExvZ2dlZEluKCkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgcmV0dXJuIExvZ2luRXJyb3IuZnJvbUNvZGUoNTExMiwgZXh0cmFNZXNzYWdlKTtcbiAgfVxuICBzdGF0aWMgcG9wdXBDbG9zZWQoKSB7XG4gICAgbGV0IGV4dHJhTWVzc2FnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJcIjtcbiAgICByZXR1cm4gTG9naW5FcnJvci5mcm9tQ29kZSg1MTEzLCBleHRyYU1lc3NhZ2UpO1xuICB9XG4gIHN0YXRpYyBsb2dpbkZhaWxlZCgpIHtcbiAgICBsZXQgZXh0cmFNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgIHJldHVybiBMb2dpbkVycm9yLmZyb21Db2RlKDUxMTQsIGV4dHJhTWVzc2FnZSk7XG4gIH1cbiAgc3RhdGljIHBvcHVwQmxvY2tlZCgpIHtcbiAgICBsZXQgZXh0cmFNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgIHJldHVybiBMb2dpbkVycm9yLmZyb21Db2RlKDUxMTUsIGV4dHJhTWVzc2FnZSk7XG4gIH1cbiAgc3RhdGljIG1mYUFscmVhZHlFbmFibGVkKCkge1xuICAgIGxldCBleHRyYU1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiXCI7XG4gICAgcmV0dXJuIExvZ2luRXJyb3IuZnJvbUNvZGUoNTExNiwgZXh0cmFNZXNzYWdlKTtcbiAgfVxuICBzdGF0aWMgbWZhTm90RW5hYmxlZCgpIHtcbiAgICBsZXQgZXh0cmFNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlwiO1xuICAgIHJldHVybiBMb2dpbkVycm9yLmZyb21Db2RlKDUxMTcsIGV4dHJhTWVzc2FnZSk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShMb2dpbkVycm9yLCBcIm1lc3NhZ2VzXCIsIHtcbiAgNTAwMDogXCJDdXN0b21cIixcbiAgNTExMTogXCJJbnZhbGlkIGxvZ2luIHBhcmFtc1wiLFxuICA1MTEyOiBcIlVzZXIgbm90IGxvZ2dlZCBpbi5cIixcbiAgNTExMzogXCJsb2dpbiBwb3B1cCBoYXMgYmVlbiBjbG9zZWQgYnkgdGhlIHVzZXJcIixcbiAgNTExNDogXCJMb2dpbiBmYWlsZWRcIixcbiAgNTExNTogXCJQb3B1cCB3YXMgYmxvY2tlZC4gUGxlYXNlIGNhbGwgdGhpcyBmdW5jdGlvbiBhcyBzb29uIGFzIHVzZXIgY2xpY2tzIGJ1dHRvbiBvciB1c2UgcmVkaXJlY3QgbW9kZVwiLFxuICA1MTE2OiBcIk1GQSBhbHJlYWR5IGVuYWJsZWRcIixcbiAgNTExNzogXCJNRkEgbm90IHlldCBlbmFibGVkLiBQbGVhc2UgY2FsbCBgZW5hYmxlTUZBYCBmaXJzdFwiXG59KTtcblxuY29uc3QgbG9nbGV2ZWwgPSBnZXRMb2dnZXIoXCJvcGVubG9naW5cIik7XG5sb2dsZXZlbC5zZXRMZXZlbChcImVycm9yXCIpO1xuXG4vLyBkb24ndCB1c2UgZGVzdHJ1Y3R1cmluZyBmb3IgcHJvY2Vzcy5lbnYgY2F1c2UgaXQgbWVzc2VzIHVwIHdlYnBhY2sgZW52IHBsdWdpblxuY29uc3QgdmVyc2lvbiA9IFwiOC4yLjFcIjtcbmFzeW5jIGZ1bmN0aW9uIHdoaXRlbGlzdFVybChjbGllbnRJZCwgYXBwS2V5LCBvcmlnaW4pIHtcbiAgY29uc3QgYXBwS2V5QnVmID0gQnVmZmVyLmZyb20oYXBwS2V5LnBhZFN0YXJ0KDY0LCBcIjBcIiksIFwiaGV4XCIpO1xuICBpZiAoYmFzZTY0dXJsLmVuY29kZShnZXRQdWJsaWMoYXBwS2V5QnVmKSkgIT09IGNsaWVudElkKSB0aHJvdyBuZXcgRXJyb3IoXCJhcHBLZXkgbWlzbWF0Y2hcIik7XG4gIGNvbnN0IHNpZyA9IGF3YWl0IHNpZ24oYXBwS2V5QnVmLCBrZWNjYWsyNTYoQnVmZmVyLmZyb20ob3JpZ2luLCBcInV0ZjhcIikpKTtcbiAgcmV0dXJuIGJhc2U2NHVybC5lbmNvZGUoc2lnKTtcbn1cbmZ1bmN0aW9uIGdldEhhc2hRdWVyeVBhcmFtcygpIHtcbiAgbGV0IHJlcGxhY2VVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgcXVlcnlVcmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkpO1xuICBxdWVyeVVybFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKGtleSAhPT0gXCJiNjRQYXJhbXNcIikge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBxdWVyeVJlc3VsdCA9IHF1ZXJ5VXJsUGFyYW1zLmdldChcImI2NFBhcmFtc1wiKTtcbiAgaWYgKHF1ZXJ5UmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gSlNPTi5wYXJzZShzYWZlYXRvYihxdWVyeVJlc3VsdCkpO1xuICAgICAgT2JqZWN0LmtleXMocXVlcnlQYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBxdWVyeVBhcmFtc1trZXldO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2xldmVsLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzaFVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgaGFzaFVybFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKGtleSAhPT0gXCJiNjRQYXJhbXNcIikge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBoYXNoUmVzdWx0ID0gaGFzaFVybFBhcmFtcy5nZXQoXCJiNjRQYXJhbXNcIik7XG4gIGlmIChoYXNoUmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGhhc2hQYXJhbXMgPSBKU09OLnBhcnNlKHNhZmVhdG9iKGhhc2hSZXN1bHQpKTtcbiAgICAgIE9iamVjdC5rZXlzKGhhc2hQYXJhbXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBoYXNoUGFyYW1zW2tleV07XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nbGV2ZWwuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBpZiAocmVwbGFjZVVybCkge1xuICAgIGNvbnN0IGNsZWFuVXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAvLyBodHRwczovL2RhcHAuY29tLyNiNjRQYXJhbXM9YXNhY3NkbnZkZnYmc3RhdGU9c2xkanZuZGZranZuJmRhcHBWYWx1ZT1zZGp2bmRmXG4gICAgaWYgKHF1ZXJ5VXJsUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICBxdWVyeVVybFBhcmFtcy5kZWxldGUoXCJlcnJvclwiKTtcbiAgICAgIHF1ZXJ5VXJsUGFyYW1zLmRlbGV0ZShcInN0YXRlXCIpO1xuICAgICAgcXVlcnlVcmxQYXJhbXMuZGVsZXRlKFwiYjY0UGFyYW1zXCIpO1xuICAgICAgcXVlcnlVcmxQYXJhbXMuZGVsZXRlKFwic2Vzc2lvbk5hbWVzcGFjZVwiKTtcbiAgICAgIGNsZWFuVXJsLnNlYXJjaCA9IHF1ZXJ5VXJsUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChoYXNoVXJsUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICBoYXNoVXJsUGFyYW1zLmRlbGV0ZShcImVycm9yXCIpO1xuICAgICAgaGFzaFVybFBhcmFtcy5kZWxldGUoXCJzdGF0ZVwiKTtcbiAgICAgIGhhc2hVcmxQYXJhbXMuZGVsZXRlKFwiYjY0UGFyYW1zXCIpO1xuICAgICAgaGFzaFVybFBhcmFtcy5kZWxldGUoXCJzZXNzaW9uTmFtZXNwYWNlXCIpO1xuICAgICAgY2xlYW5VcmwuaGFzaCA9IGhhc2hVcmxQYXJhbXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgd2luZG93Lmhpc3Rvcnkuc3RhdGUpLCB7fSwge1xuICAgICAgYXM6IGNsZWFuVXJsLmhyZWYsXG4gICAgICB1cmw6IGNsZWFuVXJsLmhyZWZcbiAgICB9KSwgXCJcIiwgY2xlYW5VcmwuaHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFVSTChwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGJhc2VVUkwsXG4gICAgcXVlcnksXG4gICAgaGFzaFxuICB9ID0gcGFyYW1zO1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGJhc2VVUkwpO1xuICBpZiAocXVlcnkpIHtcbiAgICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBxdWVyeVtrZXldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaGFzaCkge1xuICAgIGNvbnN0IGggPSBuZXcgVVJMKGNvbnN0cnVjdFVSTCh7XG4gICAgICBiYXNlVVJMLFxuICAgICAgcXVlcnk6IGhhc2hcbiAgICB9KSkuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgdXJsLmhhc2ggPSBoO1xuICB9XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldFBvcHVwRmVhdHVyZXMoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gXCJcIjtcbiAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgYnJvd3NlcnMgICAgICBGaXJlZm94XG4gIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHcgPSAxMjAwO1xuICBjb25zdCBoID0gNzAwO1xuICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoID8gd2luZG93LmlubmVyV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggOiB3aW5kb3cuc2NyZWVuLndpZHRoO1xuICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBzeXN0ZW1ab29tID0gMTsgLy8gTm8gcmVsaWFibGUgZXN0aW1hdGVcblxuICBjb25zdCBsZWZ0ID0gTWF0aC5hYnMoKHdpZHRoIC0gdykgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5MZWZ0KTtcbiAgY29uc3QgdG9wID0gTWF0aC5hYnMoKGhlaWdodCAtIGgpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuVG9wKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBgdGl0bGViYXI9MCx0b29sYmFyPTAsc3RhdHVzPTAsbG9jYXRpb249MCxtZW51YmFyPTAsaGVpZ2h0PSR7aCAvIHN5c3RlbVpvb219LHdpZHRoPSR7dyAvIHN5c3RlbVpvb219LHRvcD0ke3RvcH0sbGVmdD0ke2xlZnR9YDtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufVxuZnVuY3Rpb24gaXNNb2JpbGVPclRhYmxldCgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBwbGF0Zm9ybSA9IGJyb3dzZXIuZ2V0UGxhdGZvcm0oKTtcbiAgcmV0dXJuIHBsYXRmb3JtLnR5cGUgPT09IGJvd3Nlci5QTEFURk9STVNfTUFQLnRhYmxldCB8fCBwbGF0Zm9ybS50eXBlID09PSBib3dzZXIuUExBVEZPUk1TX01BUC5tb2JpbGU7XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGxvZ2luUHJvdmlkZXIpIHtcbiAgaWYgKChsb2dpblByb3ZpZGVyID09PSBMT0dJTl9QUk9WSURFUi5GQUNFQk9PSyB8fCBsb2dpblByb3ZpZGVyID09PSBMT0dJTl9QUk9WSURFUi5MSU5FKSAmJiBpc01vYmlsZU9yVGFibGV0KCkpIHtcbiAgICByZXR1cm4gMTAwMCAqIDYwICogNTsgLy8gNSBtaW51dGVzIHRvIGZpbmlzaCB0aGUgbG9naW5cbiAgfVxuICByZXR1cm4gMTAwMCAqIDEwOyAvLyAxMCBzZWNvbmRzXG59XG5cbmNsYXNzIFBvcHVwSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICB0aW1lb3V0ID0gMzAwMDBcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGltZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpQ2xvc2VkV2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dFwiLCB2b2lkIDApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IFwiX2JsYW5rXCI7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzIHx8IGdldFBvcHVwRmVhdHVyZXMoKTtcbiAgICB0aGlzLndpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpbmRvd1RpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xuICB9XG4gIF9zZXR1cFRpbWVyKCkge1xuICAgIHRoaXMud2luZG93VGltZXIgPSBOdW1iZXIoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud2luZG93ICYmIHRoaXMud2luZG93LmNsb3NlZCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMud2luZG93VGltZXIpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuaUNsb3NlZFdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMud2luZG93ID0gdW5kZWZpbmVkO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMud2luZG93ID09PSB1bmRlZmluZWQpIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgfSwgNTAwKSk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB2YXIgX3RoaXMkd2luZG93O1xuICAgIHRoaXMud2luZG93ID0gd2luZG93Lm9wZW4odGhpcy51cmwsIHRoaXMudGFyZ2V0LCB0aGlzLmZlYXR1cmVzKTtcbiAgICBpZiAoIXRoaXMud2luZG93KSB0aHJvdyBMb2dpbkVycm9yLnBvcHVwQmxvY2tlZCgpO1xuICAgIGlmICgoX3RoaXMkd2luZG93ID0gdGhpcy53aW5kb3cpICE9PSBudWxsICYmIF90aGlzJHdpbmRvdyAhPT0gdm9pZCAwICYmIF90aGlzJHdpbmRvdy5mb2N1cykgdGhpcy53aW5kb3cuZm9jdXMoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmlDbG9zZWRXaW5kb3cgPSB0cnVlO1xuICAgIGlmICh0aGlzLndpbmRvdykgdGhpcy53aW5kb3cuY2xvc2UoKTtcbiAgfVxuICByZWRpcmVjdChsb2NhdGlvblJlcGxhY2VPblJlZGlyZWN0KSB7XG4gICAgaWYgKGxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMudXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLnVybDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbGlzdGVuT25DaGFubmVsKGxvZ2luSWQpIHtcbiAgICBjb25zdCBzZWN1cmVQdWJTdWIgPSBuZXcgU2VjdXJlUHViU3ViKCk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHNlY3VyZVB1YlN1Yi5zdWJzY3JpYmUobG9naW5JZCk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIHNlY3VyZVB1YlN1Yi5jbGVhbnVwKCk7XG4gICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKHBhcnNlZERhdGEuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwYXJzZWREYXRhLmVycm9yLFxuICAgICAgICBzdGF0ZTogcGFyc2VkRGF0YS5zdGF0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGEuZGF0YTtcbiAgfVxufVxuXG5jbGFzcyBPcGVuTG9naW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXNzaW9uTWFuYWdlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImN1cnJlbnRTdG9yYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0b3JhZ2VCYXNlS2V5XCIsIFwib3BlbmxvZ2luX3N0b3JlXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhcHBTdGF0ZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZFZlcnNpb25JblVybHNcIiwgdHJ1ZSk7XG4gICAgaWYgKCFvcHRpb25zLmNsaWVudElkKSB0aHJvdyBJbml0aWFsaXphdGlvbkVycm9yLmludmFsaWRQYXJhbXMoXCJjbGllbnRJZCBpcyByZXF1aXJlZFwiKTtcbiAgICBpZiAoIW9wdGlvbnMubmV0d29yaykgb3B0aW9ucy5uZXR3b3JrID0gT1BFTkxPR0lOX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVDtcbiAgICBpZiAoIW9wdGlvbnMuYnVpbGRFbnYpIG9wdGlvbnMuYnVpbGRFbnYgPSBCVUlMRF9FTlYuUFJPRFVDVElPTjtcbiAgICBpZiAob3B0aW9ucy5idWlsZEVudiA9PT0gQlVJTERfRU5WLkRFVkVMT1BNRU5UIHx8IG9wdGlvbnMuYnVpbGRFbnYgPT09IEJVSUxEX0VOVi5URVNUSU5HIHx8IG9wdGlvbnMuc2RrVXJsKSB0aGlzLmFkZFZlcnNpb25JblVybHMgPSBmYWxzZTtcbiAgICBpZiAoIW9wdGlvbnMuc2RrVXJsICYmICFvcHRpb25zLnVzZU1wYykge1xuICAgICAgaWYgKG9wdGlvbnMuYnVpbGRFbnYgPT09IEJVSUxEX0VOVi5ERVZFTE9QTUVOVCkge1xuICAgICAgICBvcHRpb25zLnNka1VybCA9IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCI7XG4gICAgICAgIG9wdGlvbnMuZGFzaGJvYXJkVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjUxNzMvd2FsbGV0L2FjY291bnRcIjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5idWlsZEVudiA9PT0gQlVJTERfRU5WLlNUQUdJTkcpIHtcbiAgICAgICAgb3B0aW9ucy5zZGtVcmwgPSBcImh0dHBzOi8vc3RhZ2luZy1hdXRoLndlYjNhdXRoLmlvXCI7XG4gICAgICAgIG9wdGlvbnMuZGFzaGJvYXJkVXJsID0gXCJodHRwczovL3N0YWdpbmctYWNjb3VudC53ZWIzYXV0aC5pby93YWxsZXQvYWNjb3VudFwiO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmJ1aWxkRW52ID09PSBCVUlMRF9FTlYuVEVTVElORykge1xuICAgICAgICBvcHRpb25zLnNka1VybCA9IFwiaHR0cHM6Ly9kZXZlbG9wLWF1dGgud2ViM2F1dGguaW9cIjtcbiAgICAgICAgb3B0aW9ucy5kYXNoYm9hcmRVcmwgPSBcImh0dHBzOi8vZGV2ZWxvcC1hY2NvdW50LndlYjNhdXRoLmlvL3dhbGxldC9hY2NvdW50XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnNka1VybCA9IFwiaHR0cHM6Ly9hdXRoLndlYjNhdXRoLmlvXCI7XG4gICAgICAgIG9wdGlvbnMuZGFzaGJvYXJkVXJsID0gXCJodHRwczovL2FjY291bnQud2ViM2F1dGguaW8vd2FsbGV0L2FjY291bnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXNlTXBjICYmICFvcHRpb25zLnNka1VybCkge1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoVE9SVVNfTEVHQUNZX05FVFdPUkspLmluY2x1ZGVzKG9wdGlvbnMubmV0d29yaykpIHRocm93IEluaXRpYWxpemF0aW9uRXJyb3IuaW52YWxpZFBhcmFtcyhcIk1QQyBpcyBub3Qgc3VwcG9ydGVkIG9uIGxlZ2FjeSBuZXR3b3JrcywgcGxlYXNlIHVzZSBzYXBwaGlyZV9kZXZuZXQgb3Igc2FwcGhpcmVfbWFpbm5ldC5cIik7XG4gICAgICBpZiAob3B0aW9ucy5idWlsZEVudiA9PT0gQlVJTERfRU5WLkRFVkVMT1BNRU5UKSB7XG4gICAgICAgIG9wdGlvbnMuc2RrVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5idWlsZEVudiA9PT0gQlVJTERfRU5WLlNUQUdJTkcpIHtcbiAgICAgICAgb3B0aW9ucy5zZGtVcmwgPSBcImh0dHBzOi8vc3RhZ2luZy1tcGMtYXV0aC53ZWIzYXV0aC5pb1wiO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmJ1aWxkRW52ID09PSBCVUlMRF9FTlYuVEVTVElORykge1xuICAgICAgICBvcHRpb25zLnNka1VybCA9IFwiaHR0cHM6Ly9kZXZlbG9wLW1wYy1hdXRoLndlYjNhdXRoLmlvXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnNka1VybCA9IFwiaHR0cHM6Ly9tcGMtYXV0aC53ZWIzYXV0aC5pb1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMucmVkaXJlY3RVcmwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy5yZWRpcmVjdFVybCA9IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9YDtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnV4TW9kZSkgb3B0aW9ucy51eE1vZGUgPSBVWF9NT0RFLlJFRElSRUNUO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlVXJsT25SZWRpcmVjdCAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMucmVwbGFjZVVybE9uUmVkaXJlY3QgPSB0cnVlO1xuICAgIGlmICghb3B0aW9ucy5vcmlnaW5EYXRhKSBvcHRpb25zLm9yaWdpbkRhdGEgPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMud2hpdGVMYWJlbCkgb3B0aW9ucy53aGl0ZUxhYmVsID0ge307XG4gICAgaWYgKCFvcHRpb25zLmxvZ2luQ29uZmlnKSBvcHRpb25zLmxvZ2luQ29uZmlnID0ge307XG4gICAgaWYgKCFvcHRpb25zLm1mYVNldHRpbmdzKSBvcHRpb25zLm1mYVNldHRpbmdzID0ge307XG4gICAgaWYgKCFvcHRpb25zLnN0b3JhZ2VTZXJ2ZXJVcmwpIG9wdGlvbnMuc3RvcmFnZVNlcnZlclVybCA9IFNFU1NJT05fU0VSVkVSO1xuICAgIGlmICghb3B0aW9ucy5zdG9yYWdlS2V5KSBvcHRpb25zLnN0b3JhZ2VLZXkgPSBcImxvY2FsXCI7XG4gICAgaWYgKCFvcHRpb25zLndlYmF1dGhuVHJhbnNwb3J0cykgb3B0aW9ucy53ZWJhdXRoblRyYW5zcG9ydHMgPSBbXCJpbnRlcm5hbFwiXTtcbiAgICBpZiAoIW9wdGlvbnMuc2Vzc2lvblRpbWUpIG9wdGlvbnMuc2Vzc2lvblRpbWUgPSA4NjQwMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldCBwcml2S2V5KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlTXBjKSByZXR1cm4gdGhpcy5zdGF0ZS5mYWN0b3JLZXkgfHwgXCJcIjtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wcml2S2V5ID8gdGhpcy5zdGF0ZS5wcml2S2V5LnBhZFN0YXJ0KDY0LCBcIjBcIikgOiBcIlwiO1xuICB9XG4gIGdldCBjb3JlS2l0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvcmVLaXRLZXkgPyB0aGlzLnN0YXRlLmNvcmVLaXRLZXkucGFkU3RhcnQoNjQsIFwiMFwiKSA6IFwiXCI7XG4gIH1cbiAgZ2V0IGVkMjU1MTlQcml2S2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVkMjU1MTlQcml2S2V5ID8gdGhpcy5zdGF0ZS5lZDI1NTE5UHJpdktleS5wYWRTdGFydCgxMjgsIFwiMFwiKSA6IFwiXCI7XG4gIH1cbiAgZ2V0IGNvcmVLaXRFZDI1NTE5S2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvcmVLaXRFZDI1NTE5UHJpdktleSA/IHRoaXMuc3RhdGUuY29yZUtpdEVkMjU1MTlQcml2S2V5LnBhZFN0YXJ0KDEyOCwgXCIwXCIpIDogXCJcIjtcbiAgfVxuICBnZXQgc2Vzc2lvbklkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnNlc3Npb25JZCB8fCBcIlwiO1xuICB9XG4gIGdldCBzZXNzaW9uTmFtZXNwYWNlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2Vzc2lvbk5hbWVzcGFjZSB8fCBcIlwiO1xuICB9XG4gIGdldCBhcHBTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS51c2VySW5mby5hcHBTdGF0ZSB8fCB0aGlzLmRhcHBTdGF0ZSB8fCBcIlwiO1xuICB9XG4gIGdldCBiYXNlVXJsKCkge1xuICAgIC8vIHRlc3RpbmcgYW5kIGRldmVsb3AgZG9uJ3QgaGF2ZSB2ZXJzaW9uaW5nXG4gICAgaWYgKCF0aGlzLmFkZFZlcnNpb25JblVybHMpIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuc2RrVXJsfWA7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5zZGtVcmx9L3Yke3ZlcnNpb24uc3BsaXQoXCIuXCIpWzBdfWA7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICAvLyBnZXQgc2Vzc2lvbk5hbWVzcGFjZSBmcm9tIHRoZSByZWRpcmVjdCByZXN1bHQuXG4gICAgY29uc3QgcGFyYW1zID0gZ2V0SGFzaFF1ZXJ5UGFyYW1zKHRoaXMub3B0aW9ucy5yZXBsYWNlVXJsT25SZWRpcmVjdCk7XG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uTmFtZXNwYWNlKSB0aGlzLm9wdGlvbnMuc2Vzc2lvbk5hbWVzcGFjZSA9IHBhcmFtcy5zZXNzaW9uTmFtZXNwYWNlO1xuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSB0aGlzLm9wdGlvbnMuc2Vzc2lvbk5hbWVzcGFjZSA/IGAke3RoaXMuX3N0b3JhZ2VCYXNlS2V5fV8ke3RoaXMub3B0aW9ucy5zZXNzaW9uTmFtZXNwYWNlfWAgOiB0aGlzLl9zdG9yYWdlQmFzZUtleTtcbiAgICB0aGlzLmN1cnJlbnRTdG9yYWdlID0gQnJvd3NlclN0b3JhZ2UuZ2V0SW5zdGFuY2Uoc3RvcmFnZUtleSwgdGhpcy5vcHRpb25zLnN0b3JhZ2VLZXkpO1xuICAgIGNvbnN0IHNlc3Npb25JZCA9IHRoaXMuY3VycmVudFN0b3JhZ2UuZ2V0KFwic2Vzc2lvbklkXCIpO1xuICAgIHRoaXMuc2Vzc2lvbk1hbmFnZXIgPSBuZXcgT3BlbmxvZ2luU2Vzc2lvbk1hbmFnZXIoe1xuICAgICAgc2Vzc2lvblNlcnZlckJhc2VVcmw6IHRoaXMub3B0aW9ucy5zdG9yYWdlU2VydmVyVXJsLFxuICAgICAgc2Vzc2lvbk5hbWVzcGFjZTogdGhpcy5vcHRpb25zLnNlc3Npb25OYW1lc3BhY2UsXG4gICAgICBzZXNzaW9uVGltZTogdGhpcy5vcHRpb25zLnNlc3Npb25UaW1lLFxuICAgICAgc2Vzc2lvbklkXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5uZXR3b3JrID09PSBPUEVOTE9HSU5fTkVUV09SSy5URVNUTkVUIHx8IHRoaXMub3B0aW9ucy5uZXR3b3JrID09PSBPUEVOTE9HSU5fTkVUV09SSy5TQVBQSElSRV9ERVZORVQpIHtcbiAgICAgIC8vIHVzaW5nIGNvbnNvbGUgbG9nIGJlY2F1c2UgaXQgc2hvdWxkbid0IGJlIGFmZmVjdGVkIGJ5IGxvZ2xldmVsIGNvbmZpZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGAlYyBXQVJOSU5HISBZb3UgYXJlIG9uICR7dGhpcy5vcHRpb25zLm5ldHdvcmt9LiBQbGVhc2Ugc2V0IG5ldHdvcms6ICdtYWlubmV0JyBvciAnc2FwcGhpcmVfbWFpbm5ldCcgaW4gcHJvZHVjdGlvbmAsIFwiY29sb3I6ICNGRjAwMDBcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVpbGRFbnYgIT09IEJVSUxEX0VOVi5QUk9EVUNUSU9OKSB7XG4gICAgICAvLyB1c2luZyBjb25zb2xlIGxvZyBiZWNhdXNlIGl0IHNob3VsZG4ndCBiZSBhZmZlY3RlZCBieSBsb2dsZXZlbCBjb25maWdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhgJWMgV0FSTklORyEgWW91IGFyZSB1c2luZyBidWlsZCBlbnYgJHt0aGlzLm9wdGlvbnMuYnVpbGRFbnZ9LiBQbGVhc2Ugc2V0IGJ1aWxkRW52OiAncHJvZHVjdGlvbicgaW4gcHJvZHVjdGlvbmAsIFwiY29sb3I6ICNGRjAwMDBcIik7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcbiAgICAgIHRoaXMuZGFwcFN0YXRlID0gcGFyYW1zLnN0YXRlO1xuICAgICAgdGhyb3cgTG9naW5FcnJvci5sb2dpbkZhaWxlZChwYXJhbXMuZXJyb3IpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnNlc3Npb25JZCkge1xuICAgICAgdGhpcy5jdXJyZW50U3RvcmFnZS5zZXQoXCJzZXNzaW9uSWRcIiwgcGFyYW1zLnNlc3Npb25JZCk7XG4gICAgICB0aGlzLnNlc3Npb25NYW5hZ2VyLnNlc3Npb25JZCA9IHBhcmFtcy5zZXNzaW9uSWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlc3Npb25NYW5hZ2VyLnNlc3Npb25JZCkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX2F1dGhvcml6ZVNlc3Npb24oKTtcbiAgICAgIC8vIEZpbGwgc3RhdGUgd2l0aCBjb3JyZWN0IGluZm8gZnJvbSBzZXNzaW9uXG4gICAgICAvLyBJZiBzZXNzaW9uIGlzIGludmFsaWQgYWxsIHRoZSBkYXRhIGlzIHVuc2V0IGhlcmUuXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKGRhdGEpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBzZXNzaW9uIGlzIGludmFsaWQsIHVuc2V0IHRoZSBzZXNzaW9uSWQgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gICAgICAgIHRoaXMuY3VycmVudFN0b3JhZ2Uuc2V0KFwic2Vzc2lvbklkXCIsIFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBsb2dpbihwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcy5sb2dpblByb3ZpZGVyKSB0aHJvdyBMb2dpbkVycm9yLmludmFsaWRMb2dpblBhcmFtcyhgbG9naW5Qcm92aWRlciBpcyByZXF1aXJlZGApO1xuXG4gICAgLy8gaW4gY2FzZSBvZiByZWRpcmVjdCBtb2RlLCByZWRpcmVjdCB1cmwgd2lsbCBiZSBkYXBwIHNwZWNpZmllZFxuICAgIC8vIGluIGNhc2Ugb2YgcG9wdXAgbW9kZSwgcmVkaXJlY3QgdXJsIHdpbGwgYmUgc2RrIHNwZWNpZmllZFxuICAgIGNvbnN0IGRlZmF1bHRQYXJhbXMgPSB7XG4gICAgICByZWRpcmVjdFVybDogdGhpcy5vcHRpb25zLnJlZGlyZWN0VXJsXG4gICAgfTtcbiAgICBjb25zdCBsb2dpblBhcmFtcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBsb2dpblByb3ZpZGVyOiBwYXJhbXMubG9naW5Qcm92aWRlclxuICAgIH0sIGRlZmF1bHRQYXJhbXMpLCBwYXJhbXMpO1xuICAgIGNvbnN0IGRhdGFPYmplY3QgPSB7XG4gICAgICBhY3Rpb25UeXBlOiBPUEVOTE9HSU5fQUNUSU9OUy5MT0dJTixcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHBhcmFtczogbG9naW5QYXJhbXNcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMub3BlbmxvZ2luSGFuZGxlcihgJHt0aGlzLmJhc2VVcmx9L3N0YXJ0YCwgZGF0YU9iamVjdCwgZ2V0VGltZW91dChwYXJhbXMubG9naW5Qcm92aWRlcikpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudXhNb2RlID09PSBVWF9NT0RFLlJFRElSRUNUKSByZXR1cm4gbnVsbDtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICB0aGlzLmRhcHBTdGF0ZSA9IHJlc3VsdC5zdGF0ZTtcbiAgICAgIHRocm93IExvZ2luRXJyb3IubG9naW5GYWlsZWQocmVzdWx0LmVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uTWFuYWdlci5zZXNzaW9uSWQgPSByZXN1bHQuc2Vzc2lvbklkO1xuICAgIHRoaXMub3B0aW9ucy5zZXNzaW9uTmFtZXNwYWNlID0gcmVzdWx0LnNlc3Npb25OYW1lc3BhY2U7XG4gICAgdGhpcy5jdXJyZW50U3RvcmFnZS5zZXQoXCJzZXNzaW9uSWRcIiwgcmVzdWx0LnNlc3Npb25JZCk7XG4gICAgYXdhaXQgdGhpcy5yZWh5ZHJhdGVTZXNzaW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaXZLZXk6IHRoaXMucHJpdktleVxuICAgIH07XG4gIH1cbiAgYXN5bmMgbG9nb3V0KCkge1xuICAgIGlmICghdGhpcy5zZXNzaW9uTWFuYWdlci5zZXNzaW9uSWQpIHRocm93IExvZ2luRXJyb3IudXNlck5vdExvZ2dlZEluKCk7XG4gICAgYXdhaXQgdGhpcy5zZXNzaW9uTWFuYWdlci5pbnZhbGlkYXRlU2Vzc2lvbigpO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgcHJpdktleTogXCJcIixcbiAgICAgIGNvcmVLaXRLZXk6IFwiXCIsXG4gICAgICBjb3JlS2l0RWQyNTUxOVByaXZLZXk6IFwiXCIsXG4gICAgICBlZDI1NTE5UHJpdktleTogXCJcIixcbiAgICAgIHdhbGxldEtleTogXCJcIixcbiAgICAgIG9BdXRoUHJpdmF0ZUtleTogXCJcIixcbiAgICAgIHRLZXk6IFwiXCIsXG4gICAgICBtZXRhZGF0YU5vbmNlOiBcIlwiLFxuICAgICAga2V5TW9kZTogdW5kZWZpbmVkLFxuICAgICAgdXNlckluZm86IHtcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgcHJvZmlsZUltYWdlOiBcIlwiLFxuICAgICAgICBkYXBwU2hhcmU6IFwiXCIsXG4gICAgICAgIGlkVG9rZW46IFwiXCIsXG4gICAgICAgIG9BdXRoSWRUb2tlbjogXCJcIixcbiAgICAgICAgb0F1dGhBY2Nlc3NUb2tlbjogXCJcIixcbiAgICAgICAgYXBwU3RhdGU6IFwiXCIsXG4gICAgICAgIGVtYWlsOiBcIlwiLFxuICAgICAgICB2ZXJpZmllcjogXCJcIixcbiAgICAgICAgdmVyaWZpZXJJZDogXCJcIixcbiAgICAgICAgYWdncmVnYXRlVmVyaWZpZXI6IFwiXCIsXG4gICAgICAgIHR5cGVPZkxvZ2luOiBcIlwiLFxuICAgICAgICBpc01mYUVuYWJsZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgYXV0aFRva2VuOiBcIlwiLFxuICAgICAgc2Vzc2lvbklkOiBcIlwiLFxuICAgICAgZmFjdG9yS2V5OiBcIlwiLFxuICAgICAgc2lnbmF0dXJlczogW10sXG4gICAgICB0c3NTaGFyZUluZGV4OiAtMSxcbiAgICAgIHRzc1B1YktleTogXCJcIixcbiAgICAgIHRzc1NoYXJlOiBcIlwiLFxuICAgICAgdHNzTm9uY2U6IC0xXG4gICAgfSk7XG4gICAgdGhpcy5jdXJyZW50U3RvcmFnZS5zZXQoXCJzZXNzaW9uSWRcIiwgXCJcIik7XG4gIH1cbiAgYXN5bmMgZW5hYmxlTUZBKHBhcmFtcykge1xuICAgIHZhciBfdGhpcyRzdGF0ZSR1c2VySW5mbztcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbklkKSB0aHJvdyBMb2dpbkVycm9yLnVzZXJOb3RMb2dnZWRJbigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnVzZXJJbmZvLmlzTWZhRW5hYmxlZCkgdGhyb3cgTG9naW5FcnJvci5tZmFBbHJlYWR5RW5hYmxlZCgpO1xuICAgIC8vIGluIGNhc2Ugb2YgcmVkaXJlY3QgbW9kZSwgcmVkaXJlY3QgdXJsIHdpbGwgYmUgZGFwcCBzcGVjaWZpZWRcbiAgICAvLyBpbiBjYXNlIG9mIHBvcHVwIG1vZGUsIHJlZGlyZWN0IHVybCB3aWxsIGJlIHNkayBzcGVjaWZpZWRcbiAgICBjb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgICAgcmVkaXJlY3RVcmw6IHRoaXMub3B0aW9ucy5yZWRpcmVjdFVybFxuICAgIH07XG4gICAgY29uc3QgZGF0YU9iamVjdCA9IHtcbiAgICAgIGFjdGlvblR5cGU6IE9QRU5MT0dJTl9BQ1RJT05TLkVOQUJMRV9NRkEsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBwYXJhbXM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UGFyYW1zKSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgbG9naW5Qcm92aWRlcjogdGhpcy5zdGF0ZS51c2VySW5mby50eXBlT2ZMb2dpbixcbiAgICAgICAgZXh0cmFMb2dpbk9wdGlvbnM6IHtcbiAgICAgICAgICBsb2dpbl9oaW50OiB0aGlzLnN0YXRlLnVzZXJJbmZvLnZlcmlmaWVySWRcbiAgICAgICAgfSxcbiAgICAgICAgbWZhTGV2ZWw6IFwibWFuZGF0b3J5XCJcbiAgICAgIH0pLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZFxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5vcGVubG9naW5IYW5kbGVyKGAke3RoaXMuYmFzZVVybH0vc3RhcnRgLCBkYXRhT2JqZWN0LCBnZXRUaW1lb3V0KGRhdGFPYmplY3QucGFyYW1zLmxvZ2luUHJvdmlkZXIpKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnV4TW9kZSA9PT0gVVhfTU9ERS5SRURJUkVDVCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgdGhpcy5kYXBwU3RhdGUgPSByZXN1bHQuc3RhdGU7XG4gICAgICB0aHJvdyBMb2dpbkVycm9yLmxvZ2luRmFpbGVkKHJlc3VsdC5lcnJvcik7XG4gICAgfVxuICAgIHRoaXMuc2Vzc2lvbk1hbmFnZXIuc2Vzc2lvbklkID0gcmVzdWx0LnNlc3Npb25JZDtcbiAgICB0aGlzLm9wdGlvbnMuc2Vzc2lvbk5hbWVzcGFjZSA9IHJlc3VsdC5zZXNzaW9uTmFtZXNwYWNlO1xuICAgIHRoaXMuY3VycmVudFN0b3JhZ2Uuc2V0KFwic2Vzc2lvbklkXCIsIHJlc3VsdC5zZXNzaW9uSWQpO1xuICAgIGF3YWl0IHRoaXMucmVoeWRyYXRlU2Vzc2lvbigpO1xuICAgIHJldHVybiBCb29sZWFuKChfdGhpcyRzdGF0ZSR1c2VySW5mbyA9IHRoaXMuc3RhdGUudXNlckluZm8pID09PSBudWxsIHx8IF90aGlzJHN0YXRlJHVzZXJJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRzdGF0ZSR1c2VySW5mby5pc01mYUVuYWJsZWQpO1xuICB9XG4gIGFzeW5jIG1hbmFnZU1GQShwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbklkKSB0aHJvdyBMb2dpbkVycm9yLnVzZXJOb3RMb2dnZWRJbigpO1xuICAgIGlmICghdGhpcy5zdGF0ZS51c2VySW5mby5pc01mYUVuYWJsZWQpIHRocm93IExvZ2luRXJyb3IubWZhTm90RW5hYmxlZCgpO1xuXG4gICAgLy8gaW4gY2FzZSBvZiByZWRpcmVjdCBtb2RlLCByZWRpcmVjdCB1cmwgd2lsbCBiZSBkYXBwIHNwZWNpZmllZFxuICAgIC8vIGluIGNhc2Ugb2YgcG9wdXAgbW9kZSwgcmVkaXJlY3QgdXJsIHdpbGwgYmUgc2RrIHNwZWNpZmllZFxuICAgIGNvbnN0IGRlZmF1bHRQYXJhbXMgPSB7XG4gICAgICByZWRpcmVjdFVybDogdGhpcy5vcHRpb25zLmRhc2hib2FyZFVybCxcbiAgICAgIGRhcHBVcmw6IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59JHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9YFxuICAgIH07XG4gICAgY29uc3QgbG9naW5JZCA9IE9wZW5sb2dpblNlc3Npb25NYW5hZ2VyLmdlbmVyYXRlUmFuZG9tU2Vzc2lvbktleSgpO1xuICAgIGNvbnN0IGRhdGFPYmplY3QgPSB7XG4gICAgICBhY3Rpb25UeXBlOiBPUEVOTE9HSU5fQUNUSU9OUy5NQU5BR0VfTUZBLFxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgcGFyYW1zOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFBhcmFtcyksIHBhcmFtcyksIHt9LCB7XG4gICAgICAgIGxvZ2luUHJvdmlkZXI6IHRoaXMuc3RhdGUudXNlckluZm8udHlwZU9mTG9naW4sXG4gICAgICAgIGV4dHJhTG9naW5PcHRpb25zOiB7XG4gICAgICAgICAgbG9naW5faGludDogdGhpcy5zdGF0ZS51c2VySW5mby52ZXJpZmllcklkXG4gICAgICAgIH0sXG4gICAgICAgIGFwcFN0YXRlOiBqc29uVG9CYXNlNjQoe1xuICAgICAgICAgIGxvZ2luSWRcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZFxuICAgIH07XG4gICAgdGhpcy5jcmVhdGVMb2dpblNlc3Npb24obG9naW5JZCwgZGF0YU9iamVjdCwgZGF0YU9iamVjdC5vcHRpb25zLnNlc3Npb25UaW1lLCB0cnVlKTtcbiAgICBjb25zdCBjb25maWdQYXJhbXMgPSB7XG4gICAgICBsb2dpbklkLFxuICAgICAgc2Vzc2lvbk5hbWVzcGFjZTogdGhpcy5vcHRpb25zLnNlc3Npb25OYW1lc3BhY2UsXG4gICAgICBzdG9yYWdlU2VydmVyVXJsOiB0aGlzLm9wdGlvbnMuc3RvcmFnZVNlcnZlclVybFxuICAgIH07XG4gICAgY29uc3QgbG9naW5VcmwgPSBjb25zdHJ1Y3RVUkwoe1xuICAgICAgYmFzZVVSTDogYCR7dGhpcy5iYXNlVXJsfS9zdGFydGAsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIGI2NFBhcmFtczoganNvblRvQmFzZTY0KGNvbmZpZ1BhcmFtcylcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cub3Blbihsb2dpblVybCwgXCJfYmxhbmtcIik7XG4gIH1cbiAgYXN5bmMgY2hhbmdlU29jaWFsRmFjdG9yKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5zZXNzaW9uSWQpIHRocm93IExvZ2luRXJyb3IudXNlck5vdExvZ2dlZEluKCk7XG5cbiAgICAvLyBpbiBjYXNlIG9mIHJlZGlyZWN0IG1vZGUsIHJlZGlyZWN0IHVybCB3aWxsIGJlIGRhcHAgc3BlY2lmaWVkXG4gICAgLy8gaW4gY2FzZSBvZiBwb3B1cCBtb2RlLCByZWRpcmVjdCB1cmwgd2lsbCBiZSBzZGsgc3BlY2lmaWVkXG4gICAgY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICAgIHJlZGlyZWN0VXJsOiB0aGlzLm9wdGlvbnMucmVkaXJlY3RVcmxcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFPYmplY3QgPSB7XG4gICAgICBhY3Rpb25UeXBlOiBPUEVOTE9HSU5fQUNUSU9OUy5NT0RJRllfU09DSUFMX0ZBQ1RPUixcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHBhcmFtczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0UGFyYW1zKSwgcGFyYW1zKSxcbiAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWRcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMub3BlbmxvZ2luSGFuZGxlcihgJHt0aGlzLmJhc2VVcmx9L3N0YXJ0YCwgZGF0YU9iamVjdCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy51eE1vZGUgPT09IFVYX01PREUuUkVESVJFQ1QpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFVzZXJJbmZvKCkge1xuICAgIGlmICghdGhpcy5zZXNzaW9uTWFuYWdlci5zZXNzaW9uSWQpIHtcbiAgICAgIHRocm93IExvZ2luRXJyb3IudXNlck5vdExvZ2dlZEluKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLnVzZXJJbmZvO1xuICB9XG4gIGFzeW5jIGNyZWF0ZUxvZ2luU2Vzc2lvbihsb2dpbklkLCBkYXRhKSB7XG4gICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDYwMDtcbiAgICBsZXQgc2tpcEF3YWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbk1hbmFnZXIpIHRocm93IEluaXRpYWxpemF0aW9uRXJyb3Iubm90SW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBsb2dpblNlc3Npb25NZ3IgPSBuZXcgT3BlbmxvZ2luU2Vzc2lvbk1hbmFnZXIoe1xuICAgICAgc2Vzc2lvblNlcnZlckJhc2VVcmw6IGRhdGEub3B0aW9ucy5zdG9yYWdlU2VydmVyVXJsLFxuICAgICAgc2Vzc2lvbk5hbWVzcGFjZTogZGF0YS5vcHRpb25zLnNlc3Npb25OYW1lc3BhY2UsXG4gICAgICBzZXNzaW9uVGltZTogdGltZW91dCxcbiAgICAgIC8vIGVhY2ggbG9naW4ga2V5IG11c3QgYmUgdXNlZCB3aXRoIDEwIG1pbnMgKG1pZ2h0IGJlIHVzZWQgYXQgdGhlIGVuZCBvZiBwb3B1cCByZWRpcmVjdClcbiAgICAgIHNlc3Npb25JZDogbG9naW5JZFxuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2UgPSBsb2dpblNlc3Npb25NZ3IuY3JlYXRlU2Vzc2lvbihKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG4gICAgaWYgKGRhdGEub3B0aW9ucy51eE1vZGUgPT09IFVYX01PREUuUkVESVJFQ1QgJiYgIXNraXBBd2FpdCkge1xuICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX2F1dGhvcml6ZVNlc3Npb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5zZXNzaW9uTWFuYWdlci5zZXNzaW9uSWQpIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2Vzc2lvbk1hbmFnZXIuYXV0aG9yaXplU2Vzc2lvbigpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2xldmVsLmVycm9yKFwiYXV0aG9yaXphdGlvbiBmYWlsZWRcIiwgZXJyKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU3RhdGUoZGF0YSkge1xuICAgIHRoaXMuc3RhdGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuc3RhdGUpLCBkYXRhKTtcbiAgfVxuICBhc3luYyByZWh5ZHJhdGVTZXNzaW9uKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2F1dGhvcml6ZVNlc3Npb24oKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHJlc3VsdCk7XG4gIH1cbiAgYXN5bmMgb3BlbmxvZ2luSGFuZGxlcih1cmwsIGRhdGFPYmplY3QpIHtcbiAgICBsZXQgcG9wdXBUaW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwICogMTA7XG4gICAgY29uc3QgbG9naW5JZCA9IE9wZW5sb2dpblNlc3Npb25NYW5hZ2VyLmdlbmVyYXRlUmFuZG9tU2Vzc2lvbktleSgpO1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlTG9naW5TZXNzaW9uKGxvZ2luSWQsIGRhdGFPYmplY3QpO1xuICAgIGNvbnN0IGNvbmZpZ1BhcmFtcyA9IHtcbiAgICAgIGxvZ2luSWQsXG4gICAgICBzZXNzaW9uTmFtZXNwYWNlOiB0aGlzLm9wdGlvbnMuc2Vzc2lvbk5hbWVzcGFjZSxcbiAgICAgIHN0b3JhZ2VTZXJ2ZXJVcmw6IHRoaXMub3B0aW9ucy5zdG9yYWdlU2VydmVyVXJsXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnV4TW9kZSA9PT0gVVhfTU9ERS5SRURJUkVDVCkge1xuICAgICAgY29uc3QgbG9naW5VcmwgPSBjb25zdHJ1Y3RVUkwoe1xuICAgICAgICBiYXNlVVJMOiB1cmwsXG4gICAgICAgIGhhc2g6IHtcbiAgICAgICAgICBiNjRQYXJhbXM6IGpzb25Ub0Jhc2U2NChjb25maWdQYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBsb2dpblVybDtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGxvZ2luVXJsID0gY29uc3RydWN0VVJMKHtcbiAgICAgIGJhc2VVUkw6IHVybCxcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgYjY0UGFyYW1zOiBqc29uVG9CYXNlNjQoY29uZmlnUGFyYW1zKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGN1cnJlbnRXaW5kb3cgPSBuZXcgUG9wdXBIYW5kbGVyKHtcbiAgICAgIHVybDogbG9naW5VcmwsXG4gICAgICB0aW1lb3V0OiBwb3B1cFRpbWVvdXRcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY3VycmVudFdpbmRvdy5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgcmVqZWN0KExvZ2luRXJyb3IucG9wdXBDbG9zZWQoKSk7XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRXaW5kb3cubGlzdGVuT25DaGFubmVsKGxvZ2luSWQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGN1cnJlbnRXaW5kb3cub3BlbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBJbml0aWFsaXphdGlvbkVycm9yLCBMb2dpbkVycm9yLCBPcGVubG9naW5FcnJvciwgY29uc3RydWN0VVJMLCBPcGVuTG9naW4gYXMgZGVmYXVsdCwgZ2V0SGFzaFF1ZXJ5UGFyYW1zLCBnZXRQb3B1cEZlYXR1cmVzLCBnZXRUaW1lb3V0LCBpc01vYmlsZU9yVGFibGV0LCBsb2dsZXZlbCwgdmVyc2lvbiwgd2hpdGVsaXN0VXJsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/dist/openlogin.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/constants/dist/constants.esm.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/constants/dist/constants.esm.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER: () => (/* binding */ SESSION_SERVER),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   abi: () => (/* binding */ abi)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  AQUA: \"aqua\",\n  CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n  SAPPHIRE_DEVNET: \"sapphire_devnet\",\n  SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [\n  // TORUS_LEGACY_NETWORK.AQUA,\n  // TORUS_LEGACY_NETWORK.CELESTE,\n  // TORUS_LEGACY_NETWORK.CYAN,\n];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n  [TORUS_LEGACY_NETWORK.AQUA]: {\n    migrationCompleted: true,\n    networkIdentifier: \"aqua\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CELESTE]: {\n    migrationCompleted: true,\n    networkIdentifier: \"celeste\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CYAN]: {\n    migrationCompleted: true,\n    networkIdentifier: \"cyan\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.MAINNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"mainnet\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.TESTNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"teal\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n  }\n};\nconst NETWORK_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\n\nconst abi = [{\n  inputs: [{\n    internalType: \"string\",\n    name: \"_verifier\",\n    type: \"string\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"hashedVerifierId\",\n    type: \"bytes32\"\n  }],\n  name: \"getNodeSet\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"currentEpoch\",\n    type: \"uint256\"\n  }, {\n    internalType: \"string[]\",\n    name: \"torusNodeEndpoints\",\n    type: \"string[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusNodePubX\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusNodePubY\",\n    type: \"uint256[]\"\n  }, {\n    internalType: \"uint256[]\",\n    name: \"torusIndexes\",\n    type: \"uint256[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvY29uc3RhbnRzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVvTiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvY29uc3RhbnRzL2Rpc3QvY29uc3RhbnRzLmVzbS5qcz81ZDE4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFRPUlVTX0xFR0FDWV9ORVRXT1JLID0ge1xuICBNQUlOTkVUOiBcIm1haW5uZXRcIixcbiAgVEVTVE5FVDogXCJ0ZXN0bmV0XCIsXG4gIENZQU46IFwiY3lhblwiLFxuICBBUVVBOiBcImFxdWFcIixcbiAgQ0VMRVNURTogXCJjZWxlc3RlXCJcbn07XG5jb25zdCBUT1JVU19TQVBQSElSRV9ORVRXT1JLID0ge1xuICBTQVBQSElSRV9ERVZORVQ6IFwic2FwcGhpcmVfZGV2bmV0XCIsXG4gIFNBUFBISVJFX01BSU5ORVQ6IFwic2FwcGhpcmVfbWFpbm5ldFwiXG59O1xuY29uc3QgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUyA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcIjB4ZjIwMzM2ZTE2QjUxODI2MzdmMDk4MjFjMjdCRGUyOWIwQUZjZmU4MFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiMHhkMDg0NjA0ZTVGQTM4N0ZiQzJEYThiQWFiMDdmREQ2YURFRDQ2MTRBXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCIweDlmMDcyYmExOWIzMzcwZTUxMmFhMWI0YmZjZGFmOTcyODMxNjgwMDVcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiBcIjB4MjlEZWE4MmEwNTA5MTUzYjkxMDQwZWUxM2NEQmJhMGYwM2VmYjYyNVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiMHg2QmZmYjRlODk0NTMwNjlFNzQ4N2YwZmE1YzlmNGEyRDc3MWNjZTZjXCJcbn07XG5jb25zdCBNVUxUSV9DTFVTVEVSX05FVFdPUktTID0gW1xuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFLFxuICAvLyBUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOLFxuXTtcbmNvbnN0IExFR0FDWV9ORVRXT1JLU19ST1VURV9NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJhcXVhXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiY2VsZXN0ZVwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImN5YW5cIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJtYWlubmV0XCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwidGVhbFwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVFxuICB9XG59O1xuY29uc3QgTkVUV09SS19NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJtYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJnb2VybGlcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwicG9seWdvbi1tYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCJwb2x5Z29uLW1haW5uZXRcIlxufTtcbmNvbnN0IFNJR05FUl9NQVAgPSB7XG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX0RFVk5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9zaWduZXItcG9seWdvbi53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgTUVUQURBVEFfTUFQID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuVEVTVE5FVF06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ0VMRVNURV06IFwiaHR0cHM6Ly9tZXRhZGF0YS53ZWIzYXV0aC5pb1wiXG59O1xuY29uc3QgRk5EX1NFUlZFUiA9IFwiaHR0cHM6Ly9mbmQud2ViM2F1dGguaW9cIjtcbmNvbnN0IFNFU1NJT05fU0VSVkVSID0gXCJodHRwczovL3Nlc3Npb24ud2ViM2F1dGguaW9cIjtcbmNvbnN0IEtFWV9UWVBFID0ge1xuICBTRUNQMjU2SzE6IFwic2VjcDI1NmsxXCIsXG4gIEVEMjU1MTk6IFwiZWQyNTUxOVwiXG59O1xuXG5jb25zdCBhYmkgPSBbe1xuICBpbnB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgIG5hbWU6IFwiX3ZlcmlmaWVyXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICBuYW1lOiBcImhhc2hlZFZlcmlmaWVySWRcIixcbiAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICB9XSxcbiAgbmFtZTogXCJnZXROb2RlU2V0XCIsXG4gIG91dHB1dHM6IFt7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICBuYW1lOiBcImN1cnJlbnRFcG9jaFwiLFxuICAgIHR5cGU6IFwidWludDI1NlwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nW11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZUVuZHBvaW50c1wiLFxuICAgIHR5cGU6IFwic3RyaW5nW11cIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNOb2RlUHViWFwiLFxuICAgIHR5cGU6IFwidWludDI1NltdXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2W11cIixcbiAgICBuYW1lOiBcInRvcnVzTm9kZVB1YllcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NltdXCIsXG4gICAgbmFtZTogXCJ0b3J1c0luZGV4ZXNcIixcbiAgICB0eXBlOiBcInVpbnQyNTZbXVwiXG4gIH1dLFxuICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICB0eXBlOiBcImZ1bmN0aW9uXCJcbn1dO1xuXG5leHBvcnQgeyBGTkRfU0VSVkVSLCBLRVlfVFlQRSwgTEVHQUNZX05FVFdPUktTX1JPVVRFX01BUCwgTUVUQURBVEFfTUFQLCBNVUxUSV9DTFVTVEVSX05FVFdPUktTLCBORVRXT1JLX01BUCwgUFJPWFlfQ09OVFJBQ1RfQUREUkVTUywgU0VTU0lPTl9TRVJWRVIsIFNJR05FUl9NQVAsIFRPUlVTX0xFR0FDWV9ORVRXT1JLLCBUT1JVU19TQVBQSElSRV9ORVRXT1JLLCBhYmkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/constants/dist/constants.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  const arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n  }\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (subtle) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\") {\n      const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\") {\n      const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (subtle) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\n\n//# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvZWNjcnlwdG8vZGlzdC9lY2NyeXB0by5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDTTs7QUFFdEMsZUFBZSx3Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsNERBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsOERBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUk7QUFDakkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWRnZXJsaWZ0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2VjY3J5cHRvL2Rpc3QvZWNjcnlwdG8uZXNtLmpzPzk0NDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IGVjIGFzIGVjJDEgfSBmcm9tICdlbGxpcHRpYyc7XG5cbmNvbnN0IGVjID0gbmV3IGVjJDEoXCJzZWNwMjU2azFcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgYnJvd3NlckNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvIHx8IHt9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHN1YnRsZSA9IGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8IGJyb3dzZXJDcnlwdG8ud2Via2l0U3VidGxlO1xuY29uc3QgRUNfR1JPVVBfT1JERVIgPSBCdWZmZXIuZnJvbShcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiwgXCJoZXhcIik7XG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY2FsYXIoeCkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHgpICYmIHgubGVuZ3RoID09PSAzMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFpc1NjYWxhcihwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleS5jb21wYXJlKFpFUk8zMikgPiAwICYmXG4gIC8vID4gMFxuICBwcml2YXRlS2V5LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMDsgLy8gPCBHXG59XG5cbi8vIENvbXBhcmUgdHdvIGJ1ZmZlcnMgaW4gY29uc3RhbnQgdGltZSB0byBwcmV2ZW50IHRpbWluZyBhdHRhY2tzLlxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjEsIGIyKSB7XG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKykge1xuICAgIHJlcyB8PSBiMVtpXSBeIGIyW2ldOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgfVxuXG4gIHJldHVybiByZXMgPT09IDA7XG59XG5cbi8qIFRoaXMgbXVzdCBjaGVjayBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlciBvclxubm90LCBzaW5jZSB0aGUgZnVuY3Rpb25zIGFyZSBkaWZmZXJlbnQgYW5kIGRvZXNcbm5vdCBjb252ZXJ0IHVzaW5nIGJyb3dzZXJpZnkgKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIGlmICh0eXBlb2YgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obm9kZUNyeXB0by5yYW5kb21CeXRlcyhzaXplKSk7XG4gIH1cbiAgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG59XG5hc3luYyBmdW5jdGlvbiBzaGE1MTIobXNnKSB7XG4gIGlmIChzdWJ0bGUpIHtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhhc2ggPSBub2RlQ3J5cHRvLmNyZWF0ZUhhc2goXCJzaGE1MTJcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGhhc2gudXBkYXRlKG1zZykuZGlnZXN0KCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZnVuY3Rpb24gZ2V0QWVzKG9wKSB7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAoaXYsIGtleSwgZGF0YSkge1xuICAgIGlmIChzdWJ0bGUpIHtcbiAgICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW29wXSk7XG4gICAgICBjb25zdCBlbmNBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN1YnRsZVtvcF0oZW5jQWxnb3JpdGhtLCBjcnlwdG9LZXksIGRhdGEpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09IFwiZW5jcnlwdFwiKSB7XG4gICAgICBjb25zdCBjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gICAgICBjb25zdCBmaXJzdENodW5rID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcbiAgICAgIGNvbnN0IHNlY29uZENodW5rID0gY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImRlY3J5cHRcIikge1xuICAgICAgY29uc3QgZGVjaXBoZXIgPSBub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoXCJhZXMtMjU2LWNiY1wiLCBrZXksIGl2KTtcbiAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRDaHVuayA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZmlyc3RDaHVuaywgc2Vjb25kQ2h1bmtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7b3B9YCk7XG4gIH07XG59XG5jb25zdCBhZXNDYmNFbmNyeXB0ID0gZ2V0QWVzKFwiZW5jcnlwdFwiKTtcbmNvbnN0IGFlc0NiY0RlY3J5cHQgPSBnZXRBZXMoXCJkZWNyeXB0XCIpO1xuYXN5bmMgZnVuY3Rpb24gaG1hY1NoYTI1NlNpZ24oa2V5LCBtc2cpIHtcbiAgaWYgKHN1YnRsZSkge1xuICAgIGNvbnN0IGltcG9ydEFsZ29yaXRobSA9IHtcbiAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBuZXcgVWludDhBcnJheShrZXkpLCBpbXBvcnRBbGdvcml0aG0sIGZhbHNlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbiAgICBjb25zdCBzaWcgPSBhd2FpdCBzdWJ0bGUuc2lnbihcIkhNQUNcIiwgY3J5cHRvS2V5LCBtc2cpO1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgaG1hYyA9IG5vZGVDcnlwdG8uY3JlYXRlSG1hYyhcInNoYTI1NlwiLCBCdWZmZXIuZnJvbShrZXkpKTtcbiAgaG1hYy51cGRhdGUobXNnKTtcbiAgY29uc3QgcmVzdWx0ID0gaG1hYy5kaWdlc3QoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZWZXJpZnkoa2V5LCBtc2csIHNpZykge1xuICBjb25zdCBleHBlY3RlZFNpZyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKGtleSwgbXNnKTtcbiAgcmV0dXJuIGVxdWFsQ29uc3RUaW1lKGV4cGVjdGVkU2lnLCBzaWcpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHZhbGlkIHByaXZhdGUga2V5LiBXaWxsIHVzZSB0aGUgd2luZG93LmNyeXB0byBvciB3aW5kb3cubXNDcnlwdG8gYXMgc291cmNlXG4gKiBkZXBlbmRpbmcgb24geW91ciBicm93c2VyLlxuICovXG5jb25zdCBnZW5lcmF0ZVByaXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBwcml2YXRlS2V5ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICB3aGlsZSAoIWlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpKSB7XG4gICAgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICByZXR1cm4gcHJpdmF0ZUtleTtcbn07XG5jb25zdCBnZXRQdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBzeW5jIEFQSSBzbyB3ZSB0aHJvdyBhbiBlcnJvciBpbW1lZGlhdGVseS5cbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFhYWChLYWdhbWkpOiBgZWxsaXB0aWMudXRpbHMuZW5jb2RlYCByZXR1cm5zIGFycmF5IGZvciBldmVyeVxuICAvLyBlbmNvZGluZyBleGNlcHQgYGhleGAuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoXCJhcnJheVwiKSk7XG59O1xuXG4vKipcbiAqIEdldCBjb21wcmVzc2VkIHZlcnNpb24gb2YgcHVibGljIGtleS5cbiAqL1xuY29uc3QgZ2V0UHVibGljQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93YW5kZXJlci9zZWNwMjU2azEtbm9kZS9pc3N1ZXMvNDZcbiAgY29uc3QgY29tcHJlc3NlZCA9IHRydWU7XG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgXCJhcnJheVwiKSk7XG59O1xuXG4vLyBOT1RFKEthZ2FtaSk6IFdlIGRvbid0IHVzZSBwcm9taXNlIHNoaW0gaW4gQnJvd3NlciBpbXBsZW1lbnRhdGlvblxuLy8gYmVjYXVzZSBpdCdzIHN1cHBvcnRlZCBuYXRpdmVseSBpbiBuZXcgYnJvd3NlcnMgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1wcm9taXNlcz4pIGFuZCB3ZSBjYW4gdXNlIG9ubHkgbmV3IGJyb3dzZXJzXG4vLyBiZWNhdXNlIG9mIHRoZSBXZWJDcnlwdG9BUEkgKHNlZVxuLy8gPGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1jcnlwdG9ncmFwaHk+KS5cbmNvbnN0IHNpZ24gPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnKSB7XG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA+IDAsIFwiTWVzc2FnZSBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA8PSAzMiwgXCJNZXNzYWdlIGlzIHRvbyBsb25nXCIpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMuc2lnbihtc2csIHByaXZhdGVLZXksIHtcbiAgICBjYW5vbmljYWw6IHRydWVcbiAgfSkudG9ERVIoKSk7XG59O1xuY29uc3QgdmVyaWZ5ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleSwgbXNnLCBzaWcpIHtcbiAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleS5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlbMF0gPT09IDIgfHwgcHVibGljS2V5WzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGFzc2VydChtc2cubGVuZ3RoID4gMCwgXCJNZXNzYWdlIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gIGFzc2VydChtc2cubGVuZ3RoIDw9IDMyLCBcIk1lc3NhZ2UgaXMgdG9vIGxvbmdcIik7XG4gIGlmIChlYy52ZXJpZnkobXNnLCBzaWcsIHB1YmxpY0tleSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgc2lnbmF0dXJlXCIpO1xufTtcbmNvbnN0IGRlcml2ZSA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b0FycmF5KCkpO1xufTtcbmNvbnN0IGRlcml2ZVVucGFkZGVkID0gZGVyaXZlO1xuY29uc3QgZGVyaXZlUGFkZGVkID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXlBLCBwdWJsaWNLZXlCKSB7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCKSwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgYXNzZXJ0KHByaXZhdGVLZXlBLmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUEpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDMzKSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDIgfHwgcHVibGljS2V5QlswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBjb25zdCBrZXlBID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUEpO1xuICBjb25zdCBrZXlCID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXlCKTtcbiAgY29uc3QgUHggPSBrZXlBLmRlcml2ZShrZXlCLmdldFB1YmxpYygpKTsgLy8gQk4gaW5zdGFuY2VcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFB4LnRvU3RyaW5nKDE2LCA2NCksIFwiaGV4XCIpO1xufTtcbmNvbnN0IGVuY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocHVibGljS2V5VG8sIG1zZywgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgbGV0IGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgLy8gVGhlcmUgaXMgYSB2ZXJ5IHVubGlrZWx5IHBvc3NpYmlsaXR5IHRoYXQgaXQgaXMgbm90IGEgdmFsaWQga2V5XG4gIHdoaWxlICghaXNWYWxpZFByaXZhdGVLZXkoZXBoZW1Qcml2YXRlS2V5KSkge1xuICAgIGVwaGVtUHJpdmF0ZUtleSA9IG9wdHMuZXBoZW1Qcml2YXRlS2V5IHx8IHJhbmRvbUJ5dGVzKDMyKTtcbiAgfVxuICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGdldFB1YmxpYyhlcGhlbVByaXZhdGVLZXkpO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZVVucGFkZGVkKGVwaGVtUHJpdmF0ZUtleSwgcHVibGljS2V5VG8pO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgY29uc3QgaXYgPSBvcHRzLml2IHx8IHJhbmRvbUJ5dGVzKDE2KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGFlc0NiY0VuY3J5cHQoaXYsIEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25LZXkpLCBtc2cpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gZGF0YTtcbiAgY29uc3QgZGF0YVRvTWFjID0gQnVmZmVyLmNvbmNhdChbaXYsIGVwaGVtUHVibGljS2V5LCBjaXBoZXJ0ZXh0XSk7XG4gIGNvbnN0IG1hYyA9IGF3YWl0IGhtYWNTaGEyNTZTaWduKEJ1ZmZlci5mcm9tKG1hY0tleSksIGRhdGFUb01hYyk7XG4gIHJldHVybiB7XG4gICAgaXYsXG4gICAgZXBoZW1QdWJsaWNLZXksXG4gICAgY2lwaGVydGV4dCxcbiAgICBtYWNcbiAgfTtcbn07XG5jb25zdCBkZWNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG9wdHMsIF9wYWRkaW5nKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBfcGFkZGluZyAhPT0gbnVsbCAmJiBfcGFkZGluZyAhPT0gdm9pZCAwID8gX3BhZGRpbmcgOiBmYWxzZTtcbiAgY29uc3QgZGVyaXZlTG9jYWwgPSBwYWRkaW5nID8gZGVyaXZlUGFkZGVkIDogZGVyaXZlVW5wYWRkZWQ7XG4gIGNvbnN0IFB4ID0gYXdhaXQgZGVyaXZlTG9jYWwocHJpdmF0ZUtleSwgb3B0cy5lcGhlbVB1YmxpY0tleSk7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBzaGE1MTIoUHgpO1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gaGFzaC5zbGljZSgwLCAzMik7XG4gIGNvbnN0IG1hY0tleSA9IGhhc2guc2xpY2UoMzIpO1xuICBjb25zdCBkYXRhVG9NYWMgPSBCdWZmZXIuY29uY2F0KFtvcHRzLml2LCBvcHRzLmVwaGVtUHVibGljS2V5LCBvcHRzLmNpcGhlcnRleHRdKTtcbiAgY29uc3QgbWFjR29vZCA9IGF3YWl0IGhtYWNTaGEyNTZWZXJpZnkoQnVmZmVyLmZyb20obWFjS2V5KSwgZGF0YVRvTWFjLCBvcHRzLm1hYyk7XG4gIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSBmYWxzZSkge1xuICAgIHJldHVybiBkZWNyeXB0KHByaXZhdGVLZXksIG9wdHMsIHRydWUpO1xuICB9IGVsc2UgaWYgKCFtYWNHb29kICYmIHBhZGRpbmcgPT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgTUFDIGFmdGVyIHRyeWluZyBwYWRkZWRcIik7XG4gIH1cbiAgY29uc3QgbXNnID0gYXdhaXQgYWVzQ2JjRGVjcnlwdChvcHRzLml2LCBCdWZmZXIuZnJvbShlbmNyeXB0aW9uS2V5KSwgb3B0cy5jaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KG1zZykpO1xufTtcblxuZXhwb3J0IHsgZGVjcnlwdCwgZGVyaXZlLCBkZXJpdmVQYWRkZWQsIGRlcml2ZVVucGFkZGVkLCBlbmNyeXB0LCBnZW5lcmF0ZVByaXZhdGUsIGdldFB1YmxpYywgZ2V0UHVibGljQ29tcHJlc3NlZCwgc2lnbiwgdmVyaWZ5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2NyeXB0by5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n  sentry = _sentry;\n  tracingOrigins.push(..._tracingOrigins);\n  tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n}\n\n// #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n  let _url = null;\n  try {\n    _url = new URL(url);\n  } catch (error) {}\n  if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n    const transaction = sentry.startTransaction({\n      name: url\n    });\n    const span = transaction.startChild({\n      op: \"http\"\n    }); // This function returns a Span\n\n    const response = await fetch(url, init);\n    span.finish(); // Remember that only finished spans will be sent with the transaction\n\n    transaction.finish(); // Finishing the transaction will send it to Sentry\n\n    return response;\n  }\n  return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\nfunction debugLogResponse(response) {\n  log.info(`Response: ${response.status} ${response.statusText}`);\n  log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n  const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n  if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise) => {\n  let timeoutFunc = null;\n  try {\n    const timeout = new Promise((_resolve, reject) => {\n      timeoutFunc = setTimeout(() => {\n        reject(new Error(`Timed out in ${ms}ms`));\n      }, ms);\n    });\n    const result = await Promise.race([promise, timeout]);\n    // promise.race will return the first resolved promise\n    // then we clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    return result;\n  } catch (err) {\n    // clear the timeout\n    if (timeoutFunc != null) {\n      clearTimeout(timeoutFunc);\n    }\n    // rethrow the original error\n    throw err;\n  }\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"POST\"\n  });\n\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then(response => {\n    if (customOptions.logTracingHeader) {\n      logTracingHeader(response);\n    }\n    if (response.ok) {\n      const responseContentType = response.headers.get(\"content-type\");\n      if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n        return response.json();\n      }\n      return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PATCH\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst put = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"PUT\"\n  });\n  // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n  // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n  const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data;\n    // If url encoded data, this must not be the content type\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n  const response = await fetchAndTrace(url, options);\n  if (response.ok) {\n    const responseContentType = response.headers.get(\"content-type\");\n    if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n      return response.json();\n    }\n    return response.text();\n  }\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzL2Rpc3QvaHR0cEhlbHBlcnMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNoQztBQUNXOztBQUU1QyxZQUFZLHlEQUFrQjtBQUM5QixhQUFhLDRDQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBLG1CQUFtQjs7QUFFbkIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQixFQUFFLG9CQUFvQjtBQUMvRCxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QyxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJFQUFhLENBQUMsMkVBQWEsR0FBRztBQUMzRDtBQUNBLGtCQUFrQixtREFBSztBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBYSxDQUFDLDJFQUFhLEdBQUc7QUFDM0Q7QUFDQSxrQkFBa0IsbURBQUs7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkVBQWEsQ0FBQywyRUFBYSxHQUFHO0FBQzNEO0FBQ0Esa0JBQWtCLG1EQUFLO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUV5UCIsInNvdXJjZXMiOlsid2VicGFjazovL2xlZGdlcmxpZnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzL2Rpc3QvaHR0cEhlbHBlcnMuZXNtLmpzPzRlMzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gubWVyZ2UnO1xuaW1wb3J0IGxvZ0xldmVsLCB7IGxldmVscyB9IGZyb20gJ2xvZ2xldmVsJztcblxuY29uc3QgbG9nID0gbG9nTGV2ZWwuZ2V0TG9nZ2VyKFwiaHR0cC1oZWxwZXJzXCIpO1xubG9nLnNldExldmVsKGxldmVscy5JTkZPKTtcbmxldCBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIjtcbmxldCBlbWJlZEhvc3QgPSBcIlwiO1xuXG4vLyAjcmVnaW9uIEFQSSBLZXlzXG5jb25zdCBnYXRld2F5QXV0aEhlYWRlciA9IFwieC1hcGkta2V5XCI7XG5jb25zdCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyID0gXCJ4LWVtYmVkLWhvc3RcIjtcbmxldCBzZW50cnkgPSBudWxsO1xuY29uc3QgdHJhY2luZ09yaWdpbnMgPSBbXTtcbmNvbnN0IHRyYWNpbmdQYXRocyA9IFtdO1xuZnVuY3Rpb24gZW5hYmxlU2VudHJ5VHJhY2luZyhfc2VudHJ5LCBfdHJhY2luZ09yaWdpbnMsIF90cmFjaW5nUGF0aHMpIHtcbiAgc2VudHJ5ID0gX3NlbnRyeTtcbiAgdHJhY2luZ09yaWdpbnMucHVzaCguLi5fdHJhY2luZ09yaWdpbnMpO1xuICB0cmFjaW5nUGF0aHMucHVzaCguLi5fdHJhY2luZ1BhdGhzKTtcbn1cbmZ1bmN0aW9uIHNldEVtYmVkSG9zdChlbWJlZEhvc3RfKSB7XG4gIGVtYmVkSG9zdCA9IGVtYmVkSG9zdF87XG59XG5mdW5jdGlvbiBjbGVhckVtYmVkSG9zdCgpIHtcbiAgZW1iZWRIb3N0ID0gXCJcIjtcbn1cbmZ1bmN0aW9uIGdldEVtYmVkSG9zdCgpIHtcbiAgcmV0dXJuIGVtYmVkSG9zdDtcbn1cbmZ1bmN0aW9uIHNldEFQSUtleShhcGlLZXlfKSB7XG4gIGFwaUtleSA9IGFwaUtleV87XG59XG5mdW5jdGlvbiBjbGVhckFQSUtleSgpIHtcbiAgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG59XG5mdW5jdGlvbiBnZXRBUElLZXkoKSB7XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vICNlbmRyZWdpb25cblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgbG9nLnNldExldmVsKGxldmVsKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kVHJhY2UodXJsLCBpbml0KSB7XG4gIGxldCBfdXJsID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBfdXJsID0gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnJvcikge31cbiAgaWYgKHNlbnRyeSAmJiBfdXJsICYmICh0cmFjaW5nT3JpZ2lucy5pbmNsdWRlcyhfdXJsLm9yaWdpbikgfHwgdHJhY2luZ1BhdGhzLmluY2x1ZGVzKF91cmwucGF0aG5hbWUpKSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc2VudHJ5LnN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgbmFtZTogdXJsXG4gICAgfSk7XG4gICAgY29uc3Qgc3BhbiA9IHRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgb3A6IFwiaHR0cFwiXG4gICAgfSk7IC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFNwYW5cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBpbml0KTtcbiAgICBzcGFuLmZpbmlzaCgpOyAvLyBSZW1lbWJlciB0aGF0IG9ubHkgZmluaXNoZWQgc3BhbnMgd2lsbCBiZSBzZW50IHdpdGggdGhlIHRyYW5zYWN0aW9uXG5cbiAgICB0cmFuc2FjdGlvbi5maW5pc2goKTsgLy8gRmluaXNoaW5nIHRoZSB0cmFuc2FjdGlvbiB3aWxsIHNlbmQgaXQgdG8gU2VudHJ5XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgcmV0dXJuIGZldGNoKHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlIZWFkZXJzKCkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChhcGlLZXkpIGhlYWRlcnNbZ2F0ZXdheUF1dGhIZWFkZXJdID0gYXBpS2V5O1xuICBpZiAoZW1iZWRIb3N0KSBoZWFkZXJzW2dhdGV3YXlFbWJlZEhvc3RIZWFkZXJdID0gZW1iZWRIb3N0O1xuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgbG9nLmluZm8oYFJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICBsb2cuaW5mbyhgVXJsOiAke3Jlc3BvbnNlLnVybH1gKTtcbn1cbmZ1bmN0aW9uIGxvZ1RyYWNpbmdIZWFkZXIocmVzcG9uc2UpIHtcbiAgY29uc3QgdHJhY2luZ0hlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC13ZWIzLWNvcnJlbGF0aW9uLWlkXCIpO1xuICBpZiAodHJhY2luZ0hlYWRlcikgbG9nLmluZm8oYFJlcXVlc3QgdHJhY2luZyB3aXRoIHRyYWNlSUQgPSAke3RyYWNpbmdIZWFkZXJ9YCk7XG59XG5jb25zdCBwcm9taXNlVGltZW91dCA9IGFzeW5jIChtcywgcHJvbWlzZSkgPT4ge1xuICBsZXQgdGltZW91dEZ1bmMgPSBudWxsO1xuICB0cnkge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZWQgb3V0IGluICR7bXN9bXNgKSk7XG4gICAgICB9LCBtcyk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lb3V0XSk7XG4gICAgLy8gcHJvbWlzZS5yYWNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlXG4gICAgLy8gdGhlbiB3ZSBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmICh0aW1lb3V0RnVuYyAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dEZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBjbGVhciB0aGUgdGltZW91dFxuICAgIGlmICh0aW1lb3V0RnVuYyAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dEZ1bmMpO1xuICAgIH1cbiAgICAvLyByZXRocm93IHRoZSBvcmlnaW5hbCBlcnJvclxuICAgIHRocm93IGVycjtcbiAgfVxufTtcbmNvbnN0IGdldCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7fVxuICB9O1xuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiXG4gIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcG9zdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIlxuICB9KTtcblxuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2VUaW1lb3V0KGN1c3RvbU9wdGlvbnMudGltZW91dCB8fCA2MDAwMCwgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmIChjdXN0b21PcHRpb25zLmxvZ1RyYWNpbmdIZWFkZXIpIHtcbiAgICAgIGxvZ1RyYWNpbmdIZWFkZXIocmVzcG9uc2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9XG4gICAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gICAgdGhyb3cgcmVzcG9uc2U7XG4gIH0pKTtcbn07XG5jb25zdCBwYXRjaCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBBVENIXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcHV0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiUFVUXCJcbiAgfSk7XG4gIC8vIGRlZXAgbWVyZ2UgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIGZvcm0gZGF0YSBhbmQgdXJsIGVuY29kZWQgZGF0YSAsXG4gIC8vIHNvIHdlIHNob3VsZCBub3QgZGVlcG1lcmdlIGJvZHkgZGF0YVxuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgcmVtb3ZlID0gYXN5bmMgZnVuY3Rpb24gKHVybCkge1xuICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH07XG4gIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gIGlmIChjdXN0b21PcHRpb25zLnVzZUFQSUtleSkge1xuICAgIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRPcHRpb25zLmhlYWRlcnMpLCBnZXRBcGlLZXlIZWFkZXJzKCkpO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZShkZWZhdWx0T3B0aW9ucywgb3B0aW9uc18sIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCJcbiAgfSk7XG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hBbmRUcmFjZSh1cmwsIG9wdGlvbnMpO1xuICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgaWYgKHJlc3BvbnNlQ29udGVudFR5cGUgIT09IG51bGwgJiYgcmVzcG9uc2VDb250ZW50VHlwZSAhPT0gdm9pZCAwICYmIHJlc3BvbnNlQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICB0aHJvdyByZXNwb25zZTtcbn07XG5jb25zdCBnZW5lcmF0ZUpzb25SUENPYmplY3QgPSAobWV0aG9kLCBwYXJhbWV0ZXJzKSA9PiAoe1xuICBqc29ucnBjOiBcIjIuMFwiLFxuICBtZXRob2QsXG4gIGlkOiAxMCxcbiAgcGFyYW1zOiBwYXJhbWV0ZXJzXG59KTtcbmNvbnN0IHByb21pc2VSYWNlID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNjAwMDA7XG4gIHJldHVybiBQcm9taXNlLnJhY2UoW2dldCh1cmwsIG9wdGlvbnMpLCBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRpbWVkIG91dFwiKSk7XG4gICAgfSwgdGltZW91dCk7XG4gIH0pXSk7XG59O1xuXG5leHBvcnQgeyBjbGVhckFQSUtleSwgY2xlYXJFbWJlZEhvc3QsIGVuYWJsZVNlbnRyeVRyYWNpbmcsIGdhdGV3YXlBdXRoSGVhZGVyLCBnYXRld2F5RW1iZWRIb3N0SGVhZGVyLCBnZW5lcmF0ZUpzb25SUENPYmplY3QsIGdldCwgZ2V0QVBJS2V5LCBnZXRFbWJlZEhvc3QsIHBhdGNoLCBwb3N0LCBwcm9taXNlUmFjZSwgcHJvbWlzZVRpbWVvdXQsIHB1dCwgcmVtb3ZlLCBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgc2V0TG9nTGV2ZWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/./node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n\n\n\n\n\n\n\n\nfunction keccak256(a) {\n  return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_4__.ec(\"secp256k1\");\n\nclass MetadataStorageLayer {\n  // ms\n\n  constructor() {\n    let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n    let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"metadataHost\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"serverTimeOffset\", void 0);\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n  static setAPIKey(apiKey) {\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setEmbedHost)(embedHost);\n  }\n  generateMetadataParams(message, privateKeyHex) {\n    var _sig$recoveryParam$to, _sig$recoveryParam;\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(setData), \"utf8\")));\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64)\n    };\n  }\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n}\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16, 64),\n    pub_key_Y: pubKey.getY().toString(16, 64)\n  }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvbWV0YWRhdGEtaGVscGVycy9kaXN0L21ldGFkYXRhSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ0c7QUFDSTtBQUMxQjtBQUNSO0FBQ2tDO0FBQ047O0FBRWxFO0FBQ0EscUJBQXFCLHVFQUFXO0FBQ2hDO0FBQ0EsZUFBZSx3Q0FBSTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRFQUFlO0FBQ25CLElBQUksNEVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFTO0FBQ2I7QUFDQTtBQUNBLElBQUkscUVBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkVBQWEsQ0FBQywyRUFBYSxHQUFHLFdBQVc7QUFDakY7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLDZEQUFJLElBQUksa0JBQWtCO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyRUFBYSxDQUFDLDJFQUFhLEdBQUcsYUFBYTtBQUNuRjtBQUNBLEtBQUs7QUFDTCxtQ0FBbUMsNkRBQUksSUFBSSxrQkFBa0I7QUFDN0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0REFBTyxDQUFDLDhEQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDREQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0REFBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzL2Rpc3QvbWV0YWRhdGFIZWxwZXJzLmVzbS5qcz84NjNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgc2V0QVBJS2V5LCBzZXRFbWJlZEhvc3QsIHBvc3QgfSBmcm9tICdAdG9ydXNsYWJzL2h0dHAtaGVscGVycyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJ2pzb24tc3RhYmxlLXN0cmluZ2lmeSc7XG5pbXBvcnQgeyBlYyBhcyBlYyQxIH0gZnJvbSAnZWxsaXB0aWMnO1xuaW1wb3J0IHsga2VjY2FrMjU2IGFzIGtlY2NhazI1NiQxIH0gZnJvbSAnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhayc7XG5pbXBvcnQgeyBlbmNyeXB0LCBnZXRQdWJsaWMsIGRlY3J5cHQgfSBmcm9tICdAdG9ydXNsYWJzL2VjY3J5cHRvJztcblxuZnVuY3Rpb24ga2VjY2FrMjU2KGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtlY2NhazI1NiQxKGEpKTtcbn1cbmNvbnN0IGVjID0gbmV3IGVjJDEoXCJzZWNwMjU2azFcIik7XG5cbmNsYXNzIE1ldGFkYXRhU3RvcmFnZUxheWVyIHtcbiAgLy8gbXNcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgbWV0YWRhdGFIb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcImh0dHBzOi8vbWV0YWRhdGEudG9yLnVzXCI7XG4gICAgbGV0IHNlcnZlclRpbWVPZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFIb3N0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VydmVyVGltZU9mZnNldFwiLCB2b2lkIDApO1xuICAgIHRoaXMubWV0YWRhdGFIb3N0ID0gbWV0YWRhdGFIb3N0O1xuICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IHNlcnZlclRpbWVPZmZzZXQ7XG4gIH1cbiAgc3RhdGljIHNldEFQSUtleShhcGlLZXkpIHtcbiAgICBzZXRBUElLZXkoYXBpS2V5KTtcbiAgfVxuICBzdGF0aWMgc2V0RW1iZWRIb3N0KGVtYmVkSG9zdCkge1xuICAgIHNldEVtYmVkSG9zdChlbWJlZEhvc3QpO1xuICB9XG4gIGdlbmVyYXRlTWV0YWRhdGFQYXJhbXMobWVzc2FnZSwgcHJpdmF0ZUtleUhleCkge1xuICAgIHZhciBfc2lnJHJlY292ZXJ5UGFyYW0kdG8sIF9zaWckcmVjb3ZlcnlQYXJhbTtcbiAgICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5SGV4LCBcImhleFwiKTtcbiAgICBjb25zdCBzZXREYXRhID0ge1xuICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcih0aGlzLnNlcnZlclRpbWVPZmZzZXQgKyBEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoMTYpXG4gICAgfTtcbiAgICBjb25zdCBzaWcgPSBrZXkuc2lnbihrZWNjYWsyNTYoQnVmZmVyLmZyb20oc3RyaW5naWZ5KHNldERhdGEpLCBcInV0ZjhcIikpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViX2tleV9YOiBrZXkuZ2V0UHVibGljKCkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgICBwdWJfa2V5X1k6IGtleS5nZXRQdWJsaWMoKS5nZXRZKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHNldF9kYXRhOiBzZXREYXRhLFxuICAgICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuci50b1N0cmluZygxNiwgNjQpICsgc2lnLnMudG9TdHJpbmcoMTYsIDY0KSArICgoX3NpZyRyZWNvdmVyeVBhcmFtJHRvID0gKF9zaWckcmVjb3ZlcnlQYXJhbSA9IHNpZy5yZWNvdmVyeVBhcmFtKSA9PT0gbnVsbCB8fCBfc2lnJHJlY292ZXJ5UGFyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zaWckcmVjb3ZlcnlQYXJhbS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLnNsaWNlKC0yKSkgIT09IG51bGwgJiYgX3NpZyRyZWNvdmVyeVBhcmFtJHRvICE9PSB2b2lkIDAgPyBfc2lnJHJlY292ZXJ5UGFyYW0kdG8gOiBcIjAwXCIpLCBcImhleFwiKS50b1N0cmluZyhcImJhc2U2NFwiKVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVQdWJLZXlQYXJhbXMocHJpdmF0ZUtleUhleCkge1xuICAgIGNvbnN0IGtleSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlIZXgsIFwiaGV4XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWJfa2V5X1g6IGtleS5nZXRQdWJsaWMoKS5nZXRYKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHB1Yl9rZXlfWToga2V5LmdldFB1YmxpYygpLmdldFkoKS50b1N0cmluZygxNiwgNjQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBzZXRNZXRhZGF0YShkYXRhLCBuYW1lc3BhY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuYW1lc3BhY2UgIT09IG51bGwgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRhdGEpLCB7fSwge1xuICAgICAgbmFtZXNwYWNlXG4gICAgfSkgOiBkYXRhO1xuICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMubWV0YWRhdGFIb3N0fS9zZXRgLCBwYXJhbXMsIG9wdGlvbnMsIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhZGF0YVJlc3BvbnNlLm1lc3NhZ2U7XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEocHViS2V5LCBuYW1lc3BhY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuYW1lc3BhY2UgIT09IG51bGwgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHB1YktleSksIHt9LCB7XG4gICAgICBuYW1lc3BhY2VcbiAgICB9KSA6IHB1YktleTtcbiAgICBjb25zdCBtZXRhZGF0YVJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLm1ldGFkYXRhSG9zdH0vZ2V0YCwgcGFyYW1zLCBvcHRpb25zLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbWV0YWRhdGFSZXNwb25zZS5tZXNzYWdlO1xuICB9XG59XG5cbmNvbnN0IFdFQkFVVEhOX1RPUlVTX1NIQVJFID0gXCJ3ZWJhdXRobl90b3J1c19zaGFyZVwiO1xuY29uc3QgV0VCQVVUSE5fREVWSUNFX1NIQVJFID0gXCJ3ZWJhdXRobl9kZXZpY2Vfc2hhcmVcIjtcbmZ1bmN0aW9uIGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCkge1xuICByZXR1cm4ge1xuICAgIGl2OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguaXYsIFwiaGV4XCIpLFxuICAgIGVwaGVtUHVibGljS2V5OiBCdWZmZXIuZnJvbShlbmNQYXJhbXNIZXguZXBoZW1QdWJsaWNLZXksIFwiaGV4XCIpLFxuICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5jaXBoZXJ0ZXh0LCBcImhleFwiKSxcbiAgICBtYWM6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5tYWMsIFwiaGV4XCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNQYXJhbXNCdWZUb0hleChlbmNQYXJhbXMpIHtcbiAgcmV0dXJuIHtcbiAgICBpdjogQnVmZmVyLmZyb20oZW5jUGFyYW1zLml2KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBlcGhlbVB1YmxpY0tleTogQnVmZmVyLmZyb20oZW5jUGFyYW1zLmVwaGVtUHVibGljS2V5KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBjaXBoZXJ0ZXh0OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuY2lwaGVydGV4dCkudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgbWFjOiBCdWZmZXIuZnJvbShlbmNQYXJhbXMubWFjKS50b1N0cmluZyhcImhleFwiKVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdERhdGEocHJpdktleUhleCwgZCkge1xuICBjb25zdCBzZXJpYWxpemVkRGVjID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRCdWYgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkRGVjLCBcInV0Zi04XCIpO1xuICBjb25zdCBlbmNQYXJhbXMgPSBhd2FpdCBlbmNyeXB0KGdldFB1YmxpYyhCdWZmZXIuZnJvbShwcml2S2V5SGV4LCBcImhleFwiKSksIHNlcmlhbGl6ZWRCdWYpO1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBlbmNQYXJhbXNCdWZUb0hleChlbmNQYXJhbXMpO1xuICBjb25zdCBzRGF0YSA9IEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtc0hleCk7XG4gIHJldHVybiBzRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpIHtcbiAgY29uc3QgZW5jUGFyYW1zSGV4ID0gSlNPTi5wYXJzZShkKTtcbiAgY29uc3QgZW5jUGFyYW1zID0gZW5jUGFyYW1zSGV4VG9CdWYoZW5jUGFyYW1zSGV4KTtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZLZXlIZXgpO1xuICBjb25zdCBzZXJpYWxpemVkQnVmID0gYXdhaXQgZGVjcnlwdChCdWZmZXIuZnJvbShrZXlQYWlyLmdldFByaXZhdGUoKS50b1N0cmluZyhcImhleFwiLCA2NCksIFwiaGV4XCIpLCBlbmNQYXJhbXMpO1xuICBjb25zdCBzZXJpYWxpemVkRGVjID0gc2VyaWFsaXplZEJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xuICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkRGVjKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRBbmREZWNyeXB0RGF0YShtLCBwcml2S2V5SGV4LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZLZXlIZXgsIFwiaGV4XCIpO1xuICBjb25zdCBwdWJLZXkgPSBrZXlQYWlyLmdldFB1YmxpYygpO1xuICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IGF3YWl0IG0uZ2V0TWV0YWRhdGEoe1xuICAgIHB1Yl9rZXlfWDogcHViS2V5LmdldFgoKS50b1N0cmluZygxNiwgNjQpLFxuICAgIHB1Yl9rZXlfWTogcHViS2V5LmdldFkoKS50b1N0cmluZygxNiwgNjQpXG4gIH0sIG5hbWVzcGFjZSk7XG4gIGlmICghc2VyaWFsaXplZERhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgZGVjcnlwdERhdGEocHJpdktleUhleCwgc2VyaWFsaXplZERhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXlIZXgsIGQsIG5hbWVzcGFjZSkge1xuICBjb25zdCBzRGF0YSA9IGF3YWl0IGVuY3J5cHREYXRhKHByaXZLZXlIZXgsIGQpO1xuICBjb25zdCBtZXRhZGF0YVBhcmFtcyA9IG0uZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyhzRGF0YSwgcHJpdktleUhleCk7XG4gIGF3YWl0IG0uc2V0TWV0YWRhdGEobWV0YWRhdGFQYXJhbXMsIG5hbWVzcGFjZSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRUb3J1c1NoYXJlKG0sIHdlYkF1dGhuUHViS2V5LCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UsIHN1YnNwYWNlRGF0YSkge1xuICBjb25zdCByZWZLZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5SZWZIZXgpO1xuICBjb25zdCBwcml2S2V5ID0gcmVmS2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IHB1YktleSA9IGVjLmtleUZyb21QdWJsaWMoe1xuICAgIHg6IHdlYkF1dGhuUHViS2V5LnB1Yl9rZXlfWCxcbiAgICB5OiB3ZWJBdXRoblB1YktleS5wdWJfa2V5X1lcbiAgfSk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xuICBsZXQgZCA9IHt9O1xuICBpZiAoZGF0YSkgZCA9IGRhdGE7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEgPSBKU09OLnN0cmluZ2lmeShzdWJzcGFjZURhdGEpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZFN1YnNwYWNlRGF0YSwgXCJ1dGYtOFwiKTtcbiAgY29uc3QgZW5jU3Vic3BhY2VEYXRhID0gYXdhaXQgZW5jcnlwdChCdWZmZXIuZnJvbShwdWJLZXkuZ2V0UHVibGljKFwiaGV4XCIpLCBcImhleFwiKSwgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1Zik7XG4gIGNvbnN0IGVuY1N1YnNwYWNlRGF0YUhleCA9IGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1N1YnNwYWNlRGF0YSk7XG4gIGRbc3Vic3BhY2VdID0gZW5jU3Vic3BhY2VEYXRhSGV4O1xuICBhd2FpdCBlbmNyeXB0QW5kU2V0RGF0YShtLCBwcml2S2V5LnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgZCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0RGV2aWNlU2hhcmUobSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlLCBzdWJzcGFjZURhdGEpIHtcbiAgY29uc3Qga2V5UGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHdlYkF1dGhuUmVmSGV4KTtcbiAgY29uc3QgcHJpdktleSA9IGtleVBhaXIuZ2V0UHJpdmF0ZSgpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG4gIGxldCBkID0ge307XG4gIGlmIChkYXRhKSBkID0gZGF0YTtcbiAgZFtzdWJzcGFjZV0gPSBzdWJzcGFjZURhdGE7XG4gIGF3YWl0IGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBkLCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9ydXNTaGFyZShtLCB3ZWJBdXRobktleUhleCwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fVE9SVVNfU0hBUkUpO1xuICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBkYXRhW3N1YnNwYWNlXTtcbiAgaWYgKCFlbmNQYXJhbXNIZXgpIHJldHVybiBudWxsO1xuICBjb25zdCBlbmNQYXJhbXMgPSBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpO1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5LZXlIZXgpO1xuICBjb25zdCBwcml2S2V5ID0ga2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYgPSBhd2FpdCBkZWNyeXB0KEJ1ZmZlci5mcm9tKHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBcImhleFwiKSwgZW5jUGFyYW1zKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YSA9IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYudG9TdHJpbmcoXCJ1dGYtOFwiKTtcbiAgY29uc3Qgc3Vic3BhY2VEYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkU3Vic3BhY2VEYXRhKTtcbiAgcmV0dXJuIHN1YnNwYWNlRGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldERldmljZVNoYXJlKG0sIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSkge1xuICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0QW5kRGVjcnlwdERhdGEobSwgd2ViQXV0aG5SZWZIZXgsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG4gIGlmIChkYXRhKSByZXR1cm4gZGF0YVtzdWJzcGFjZV07XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBkZWNyeXB0RGF0YSwgTWV0YWRhdGFTdG9yYWdlTGF5ZXIgYXMgZGVmYXVsdCwgZWMsIGVuY1BhcmFtc0J1ZlRvSGV4LCBlbmNQYXJhbXNIZXhUb0J1ZiwgZW5jcnlwdEFuZFNldERhdGEsIGVuY3J5cHREYXRhLCBnZXRBbmREZWNyeXB0RGF0YSwgZ2V0RGV2aWNlU2hhcmUsIGdldFRvcnVzU2hhcmUsIGtlY2NhazI1Niwgc2V0RGV2aWNlU2hhcmUsIHNldFRvcnVzU2hhcmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/secure-pub-sub/dist/securePubSub.esm.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/secure-pub-sub/dist/securePubSub.esm.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SecurePubSub: () => (/* binding */ SecurePubSub)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! socket.io-client */ \"(ssr)/./node_modules/socket.io-client/build/esm-debug/index.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_5___default().getLogger(\"SecurePubSub\");\n\nclass SecurePubSub {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"options\", void 0);\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"SOCKET_CONN\", null);\n    this.options = options;\n    this.options.timeout = options.timeout || 600; // 10 mins is default timeout\n    this.options.serverUrl = options.serverUrl || \"https://session.web3auth.io\";\n    this.options.enableLogging = options.enableLogging || false;\n    this.options.namespace = options.namespace || \"\";\n    this.options.sameIpCheck = options.sameIpCheck || false;\n    this.options.sameOriginCheck = options.sameOriginCheck || false;\n    if (this.options.enableLogging) log.enableAll();else log.disableAll();\n  }\n  static setLogLevel(level) {\n    log.setLevel(level);\n    (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setLogLevel)(level);\n  }\n  async publish(topic, message) {\n    const topicPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(topic, \"utf8\"));\n    const encryptedData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(topicPrivKey.toString(\"hex\"), message);\n    const signature = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_1__.sign)(topicPrivKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encryptedData, \"utf8\")));\n    const fetchBody = {\n      key: (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_1__.getPublic)(topicPrivKey).toString(\"hex\"),\n      // already padded\n      data: encryptedData,\n      signature: signature.toString(\"hex\"),\n      timeout: this.options.timeout,\n      namespace: this.options.namespace,\n      sameIpCheck: this.options.sameIpCheck,\n      sameOriginCheck: this.options.sameOriginCheck\n    };\n    return (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.options.serverUrl}/channel/set`, fetchBody);\n  }\n  async subscribe(topic) {\n    let isPromisePending = true;\n    const topicPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(topic, \"utf8\"));\n    const topicPubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_1__.getPublic)(topicPrivKey).toString(\"hex\"); // already padded\n    const currentSocketConnection = this.getSocketConnection();\n    if (currentSocketConnection.connected) {\n      log.debug(\"already connected with socket\");\n      currentSocketConnection.emit(\"check_auth_status\", topicPubKey, {\n        namespace: this.options.namespace,\n        sameIpCheck: this.options.sameIpCheck,\n        sameOriginCheck: this.options.sameOriginCheck\n      });\n    } else {\n      currentSocketConnection.once(\"connect\", () => {\n        log.debug(\"connected with socket\");\n        currentSocketConnection.emit(\"check_auth_status\", topicPubKey, {\n          namespace: this.options.namespace,\n          sameIpCheck: this.options.sameIpCheck,\n          sameOriginCheck: this.options.sameOriginCheck\n        });\n      });\n    }\n    const reconnect = () => {\n      currentSocketConnection.once(\"connect\", async () => {\n        log.debug(\"connected with socket using reconnect\");\n        if (isPromisePending) currentSocketConnection.emit(\"check_auth_status\", topicPubKey, {\n          namespace: this.options.namespace,\n          sameIpCheck: this.options.sameIpCheck,\n          sameOriginCheck: this.options.sameOriginCheck\n        });\n      });\n    };\n    const visibilityListener = () => {\n      if (!isPromisePending) document.removeEventListener(\"visibilitychange\", visibilityListener);\n      // if not connected, then wait for connection and ping server for latest msg.\n      if (!currentSocketConnection.connected && document.visibilityState === \"visible\") {\n        reconnect();\n      }\n    };\n    const disconnectListener = () => {\n      log.debug(\"socket disconnected\", isPromisePending);\n      if (isPromisePending) {\n        log.error(\"socket disconnected unexpectedly, reconnecting socket\");\n        reconnect();\n      } else {\n        currentSocketConnection.removeListener(\"disconnect\", disconnectListener);\n      }\n    };\n    currentSocketConnection.on(\"disconnect\", disconnectListener);\n    const returnPromise = new Promise((resolve, reject) => {\n      const listener = async ev => {\n        try {\n          const decData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.decryptData)(topicPrivKey.toString(\"hex\"), ev);\n          log.info(\"got data\", decData);\n          resolve(decData);\n        } catch (error) {\n          log.error(error);\n          reject(error);\n        } finally {\n          isPromisePending = false;\n          document.removeEventListener(\"visibilitychange\", visibilityListener);\n        }\n      };\n      log.info(\"listening to\", `${topicPubKey}_success`);\n      currentSocketConnection.once(`${topicPubKey}_success`, listener);\n    });\n    if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", visibilityListener);\n    return returnPromise;\n  }\n  cleanup() {\n    if (this.SOCKET_CONN) {\n      this.SOCKET_CONN.disconnect();\n      this.SOCKET_CONN = null;\n    }\n  }\n  getSocketConnection() {\n    if (this.SOCKET_CONN) return this.SOCKET_CONN;\n    const localSocketConnection = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_4__.io)(this.options.serverUrl, {\n      transports: [\"websocket\", \"polling\"],\n      // use WebSocket first, if available\n      withCredentials: true,\n      reconnectionDelayMax: 10000,\n      reconnectionAttempts: 10\n    });\n    localSocketConnection.on(\"connect_error\", err => {\n      // revert to classic upgrade\n      localSocketConnection.io.opts.transports = [\"polling\", \"websocket\"];\n      log.error(\"connect error\", err);\n    });\n    localSocketConnection.on(\"connect\", async () => {\n      const {\n        engine\n      } = localSocketConnection.io;\n      log.debug(\"initially connected to\", engine.transport.name); // in most cases, prints \"polling\"\n      engine.once(\"upgrade\", () => {\n        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n        log.debug(\"upgraded\", engine.transport.name); // in most cases, prints \"websocket\"\n      });\n      engine.once(\"close\", reason => {\n        // called when the underlying connection is closed\n        log.debug(\"connection closed\", reason);\n      });\n    });\n    localSocketConnection.on(\"error\", err => {\n      log.error(\"socket errored\", err);\n      localSocketConnection.disconnect();\n    });\n    this.SOCKET_CONN = localSocketConnection;\n    return this.SOCKET_CONN;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvc2VjdXJlLXB1Yi1zdWIvZGlzdC9zZWN1cmVQdWJTdWIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNkO0FBQ007QUFDc0I7QUFDNUM7QUFDVDs7QUFFN0IsVUFBVSx5REFBZTs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0RUFBZTtBQUNuQixJQUFJLDRFQUFlO0FBQ25CO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvRUFBVztBQUNmO0FBQ0E7QUFDQSx5QkFBeUIsc0VBQVM7QUFDbEMsZ0NBQWdDLHdFQUFXO0FBQzNDLDRCQUE0Qix5REFBSSxlQUFlLHNFQUFTO0FBQ3hEO0FBQ0EsV0FBVyw4REFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBSSxJQUFJLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0VBQVM7QUFDbEMsd0JBQXdCLDhEQUFTLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3RUFBVztBQUMzQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxzQ0FBc0MsWUFBWTtBQUNsRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBRTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVkZ2VybGlmdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zZWN1cmUtcHViLXN1Yi9kaXN0L3NlY3VyZVB1YlN1Yi5lc20uanM/ZmIzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgc2lnbiwgZ2V0UHVibGljIH0gZnJvbSAnQHRvcnVzbGFicy9lY2NyeXB0byc7XG5pbXBvcnQgeyBzZXRMb2dMZXZlbCwgcG9zdCB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCB7IGtlY2NhazI1NiwgZW5jcnlwdERhdGEsIGRlY3J5cHREYXRhIH0gZnJvbSAnQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzJztcbmltcG9ydCB7IGlvIH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgbG9nJDEgZnJvbSAnbG9nbGV2ZWwnO1xuXG52YXIgbG9nID0gbG9nJDEuZ2V0TG9nZ2VyKFwiU2VjdXJlUHViU3ViXCIpO1xuXG5jbGFzcyBTZWN1cmVQdWJTdWIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlNPQ0tFVF9DT05OXCIsIG51bGwpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgNjAwOyAvLyAxMCBtaW5zIGlzIGRlZmF1bHQgdGltZW91dFxuICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSBvcHRpb25zLnNlcnZlclVybCB8fCBcImh0dHBzOi8vc2Vzc2lvbi53ZWIzYXV0aC5pb1wiO1xuICAgIHRoaXMub3B0aW9ucy5lbmFibGVMb2dnaW5nID0gb3B0aW9ucy5lbmFibGVMb2dnaW5nIHx8IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucy5uYW1lc3BhY2UgPSBvcHRpb25zLm5hbWVzcGFjZSB8fCBcIlwiO1xuICAgIHRoaXMub3B0aW9ucy5zYW1lSXBDaGVjayA9IG9wdGlvbnMuc2FtZUlwQ2hlY2sgfHwgZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zLnNhbWVPcmlnaW5DaGVjayA9IG9wdGlvbnMuc2FtZU9yaWdpbkNoZWNrIHx8IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTG9nZ2luZykgbG9nLmVuYWJsZUFsbCgpO2Vsc2UgbG9nLmRpc2FibGVBbGwoKTtcbiAgfVxuICBzdGF0aWMgc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHRvcGljLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgdG9waWNQcml2S2V5ID0ga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHRvcGljLCBcInV0ZjhcIikpO1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBhd2FpdCBlbmNyeXB0RGF0YSh0b3BpY1ByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiksIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ24odG9waWNQcml2S2V5LCBrZWNjYWsyNTYoQnVmZmVyLmZyb20oZW5jcnlwdGVkRGF0YSwgXCJ1dGY4XCIpKSk7XG4gICAgY29uc3QgZmV0Y2hCb2R5ID0ge1xuICAgICAga2V5OiBnZXRQdWJsaWModG9waWNQcml2S2V5KS50b1N0cmluZyhcImhleFwiKSxcbiAgICAgIC8vIGFscmVhZHkgcGFkZGVkXG4gICAgICBkYXRhOiBlbmNyeXB0ZWREYXRhLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMudGltZW91dCxcbiAgICAgIG5hbWVzcGFjZTogdGhpcy5vcHRpb25zLm5hbWVzcGFjZSxcbiAgICAgIHNhbWVJcENoZWNrOiB0aGlzLm9wdGlvbnMuc2FtZUlwQ2hlY2ssXG4gICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRoaXMub3B0aW9ucy5zYW1lT3JpZ2luQ2hlY2tcbiAgICB9O1xuICAgIHJldHVybiBwb3N0KGAke3RoaXMub3B0aW9ucy5zZXJ2ZXJVcmx9L2NoYW5uZWwvc2V0YCwgZmV0Y2hCb2R5KTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUodG9waWMpIHtcbiAgICBsZXQgaXNQcm9taXNlUGVuZGluZyA9IHRydWU7XG4gICAgY29uc3QgdG9waWNQcml2S2V5ID0ga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHRvcGljLCBcInV0ZjhcIikpO1xuICAgIGNvbnN0IHRvcGljUHViS2V5ID0gZ2V0UHVibGljKHRvcGljUHJpdktleSkudG9TdHJpbmcoXCJoZXhcIik7IC8vIGFscmVhZHkgcGFkZGVkXG4gICAgY29uc3QgY3VycmVudFNvY2tldENvbm5lY3Rpb24gPSB0aGlzLmdldFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICBpZiAoY3VycmVudFNvY2tldENvbm5lY3Rpb24uY29ubmVjdGVkKSB7XG4gICAgICBsb2cuZGVidWcoXCJhbHJlYWR5IGNvbm5lY3RlZCB3aXRoIHNvY2tldFwiKTtcbiAgICAgIGN1cnJlbnRTb2NrZXRDb25uZWN0aW9uLmVtaXQoXCJjaGVja19hdXRoX3N0YXR1c1wiLCB0b3BpY1B1YktleSwge1xuICAgICAgICBuYW1lc3BhY2U6IHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsXG4gICAgICAgIHNhbWVJcENoZWNrOiB0aGlzLm9wdGlvbnMuc2FtZUlwQ2hlY2ssXG4gICAgICAgIHNhbWVPcmlnaW5DaGVjazogdGhpcy5vcHRpb25zLnNhbWVPcmlnaW5DaGVja1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRTb2NrZXRDb25uZWN0aW9uLm9uY2UoXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgbG9nLmRlYnVnKFwiY29ubmVjdGVkIHdpdGggc29ja2V0XCIpO1xuICAgICAgICBjdXJyZW50U29ja2V0Q29ubmVjdGlvbi5lbWl0KFwiY2hlY2tfYXV0aF9zdGF0dXNcIiwgdG9waWNQdWJLZXksIHtcbiAgICAgICAgICBuYW1lc3BhY2U6IHRoaXMub3B0aW9ucy5uYW1lc3BhY2UsXG4gICAgICAgICAgc2FtZUlwQ2hlY2s6IHRoaXMub3B0aW9ucy5zYW1lSXBDaGVjayxcbiAgICAgICAgICBzYW1lT3JpZ2luQ2hlY2s6IHRoaXMub3B0aW9ucy5zYW1lT3JpZ2luQ2hlY2tcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVjb25uZWN0ID0gKCkgPT4ge1xuICAgICAgY3VycmVudFNvY2tldENvbm5lY3Rpb24ub25jZShcImNvbm5lY3RcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBsb2cuZGVidWcoXCJjb25uZWN0ZWQgd2l0aCBzb2NrZXQgdXNpbmcgcmVjb25uZWN0XCIpO1xuICAgICAgICBpZiAoaXNQcm9taXNlUGVuZGluZykgY3VycmVudFNvY2tldENvbm5lY3Rpb24uZW1pdChcImNoZWNrX2F1dGhfc3RhdHVzXCIsIHRvcGljUHViS2V5LCB7XG4gICAgICAgICAgbmFtZXNwYWNlOiB0aGlzLm9wdGlvbnMubmFtZXNwYWNlLFxuICAgICAgICAgIHNhbWVJcENoZWNrOiB0aGlzLm9wdGlvbnMuc2FtZUlwQ2hlY2ssXG4gICAgICAgICAgc2FtZU9yaWdpbkNoZWNrOiB0aGlzLm9wdGlvbnMuc2FtZU9yaWdpbkNoZWNrXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB2aXNpYmlsaXR5TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIWlzUHJvbWlzZVBlbmRpbmcpIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlMaXN0ZW5lcik7XG4gICAgICAvLyBpZiBub3QgY29ubmVjdGVkLCB0aGVuIHdhaXQgZm9yIGNvbm5lY3Rpb24gYW5kIHBpbmcgc2VydmVyIGZvciBsYXRlc3QgbXNnLlxuICAgICAgaWYgKCFjdXJyZW50U29ja2V0Q29ubmVjdGlvbi5jb25uZWN0ZWQgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICByZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRpc2Nvbm5lY3RMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIGxvZy5kZWJ1ZyhcInNvY2tldCBkaXNjb25uZWN0ZWRcIiwgaXNQcm9taXNlUGVuZGluZyk7XG4gICAgICBpZiAoaXNQcm9taXNlUGVuZGluZykge1xuICAgICAgICBsb2cuZXJyb3IoXCJzb2NrZXQgZGlzY29ubmVjdGVkIHVuZXhwZWN0ZWRseSwgcmVjb25uZWN0aW5nIHNvY2tldFwiKTtcbiAgICAgICAgcmVjb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50U29ja2V0Q29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnJlbnRTb2NrZXRDb25uZWN0aW9uLm9uKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0TGlzdGVuZXIpO1xuICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGFzeW5jIGV2ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWNEYXRhID0gYXdhaXQgZGVjcnlwdERhdGEodG9waWNQcml2S2V5LnRvU3RyaW5nKFwiaGV4XCIpLCBldik7XG4gICAgICAgICAgbG9nLmluZm8oXCJnb3QgZGF0YVwiLCBkZWNEYXRhKTtcbiAgICAgICAgICByZXNvbHZlKGRlY0RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpc1Byb21pc2VQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdmlzaWJpbGl0eUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxvZy5pbmZvKFwibGlzdGVuaW5nIHRvXCIsIGAke3RvcGljUHViS2V5fV9zdWNjZXNzYCk7XG4gICAgICBjdXJyZW50U29ja2V0Q29ubmVjdGlvbi5vbmNlKGAke3RvcGljUHViS2V5fV9zdWNjZXNzYCwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHJldHVyblByb21pc2U7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5TT0NLRVRfQ09OTikge1xuICAgICAgdGhpcy5TT0NLRVRfQ09OTi5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLlNPQ0tFVF9DT05OID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0U29ja2V0Q29ubmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5TT0NLRVRfQ09OTikgcmV0dXJuIHRoaXMuU09DS0VUX0NPTk47XG4gICAgY29uc3QgbG9jYWxTb2NrZXRDb25uZWN0aW9uID0gaW8odGhpcy5vcHRpb25zLnNlcnZlclVybCwge1xuICAgICAgdHJhbnNwb3J0czogW1wid2Vic29ja2V0XCIsIFwicG9sbGluZ1wiXSxcbiAgICAgIC8vIHVzZSBXZWJTb2NrZXQgZmlyc3QsIGlmIGF2YWlsYWJsZVxuICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDEwMDAwLFxuICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IDEwXG4gICAgfSk7XG4gICAgbG9jYWxTb2NrZXRDb25uZWN0aW9uLm9uKFwiY29ubmVjdF9lcnJvclwiLCBlcnIgPT4ge1xuICAgICAgLy8gcmV2ZXJ0IHRvIGNsYXNzaWMgdXBncmFkZVxuICAgICAgbG9jYWxTb2NrZXRDb25uZWN0aW9uLmlvLm9wdHMudHJhbnNwb3J0cyA9IFtcInBvbGxpbmdcIiwgXCJ3ZWJzb2NrZXRcIl07XG4gICAgICBsb2cuZXJyb3IoXCJjb25uZWN0IGVycm9yXCIsIGVycik7XG4gICAgfSk7XG4gICAgbG9jYWxTb2NrZXRDb25uZWN0aW9uLm9uKFwiY29ubmVjdFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuZ2luZVxuICAgICAgfSA9IGxvY2FsU29ja2V0Q29ubmVjdGlvbi5pbztcbiAgICAgIGxvZy5kZWJ1ZyhcImluaXRpYWxseSBjb25uZWN0ZWQgdG9cIiwgZW5naW5lLnRyYW5zcG9ydC5uYW1lKTsgLy8gaW4gbW9zdCBjYXNlcywgcHJpbnRzIFwicG9sbGluZ1wiXG4gICAgICBlbmdpbmUub25jZShcInVwZ3JhZGVcIiwgKCkgPT4ge1xuICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNwb3J0IGlzIHVwZ3JhZGVkIChpLmUuIGZyb20gSFRUUCBsb25nLXBvbGxpbmcgdG8gV2ViU29ja2V0KVxuICAgICAgICBsb2cuZGVidWcoXCJ1cGdyYWRlZFwiLCBlbmdpbmUudHJhbnNwb3J0Lm5hbWUpOyAvLyBpbiBtb3N0IGNhc2VzLCBwcmludHMgXCJ3ZWJzb2NrZXRcIlxuICAgICAgfSk7XG4gICAgICBlbmdpbmUub25jZShcImNsb3NlXCIsIHJlYXNvbiA9PiB7XG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAgICAgIGxvZy5kZWJ1ZyhcImNvbm5lY3Rpb24gY2xvc2VkXCIsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsb2NhbFNvY2tldENvbm5lY3Rpb24ub24oXCJlcnJvclwiLCBlcnIgPT4ge1xuICAgICAgbG9nLmVycm9yKFwic29ja2V0IGVycm9yZWRcIiwgZXJyKTtcbiAgICAgIGxvY2FsU29ja2V0Q29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgdGhpcy5TT0NLRVRfQ09OTiA9IGxvY2FsU29ja2V0Q29ubmVjdGlvbjtcbiAgICByZXR1cm4gdGhpcy5TT0NLRVRfQ09OTjtcbiAgfVxufVxuXG5leHBvcnQgeyBTZWN1cmVQdWJTdWIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin/node_modules/@toruslabs/secure-pub-sub/dist/securePubSub.esm.js\n");

/***/ })

};
;